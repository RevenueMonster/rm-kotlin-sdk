{"version":3,"file":"ktor-ktor-io-js-legacy.js","sources":["../../../../../ktor-io/common/src/io/ktor/utils/io/ByteChannelSequential.kt","generated/_ComparisonsJs.kt","util/Preconditions.kt","kotlin/UShort.kt","kotlin/UInt.kt","kotlin/ULong.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/charsets/Encoding.kt","text/StringBuilder.kt","kotlin/UByte.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryPrimitivesJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputArrays.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Buffers.kt","util/Standard.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ByteReadChannel.kt","coroutines/Continuation.kt","text/Strings.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ByteChannelCtor.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Strings.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Require.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Packet.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Buffer.kt","kotlin/math.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ByteWriteChannel.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Builder.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ChannelLittleEndian.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/Coroutines.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/ReadSession.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/WriterSession.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/ByteOrder.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/Memory.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Numbers.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/MemoryFactory.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/MemoryPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/bits/PrimiteArrays.kt","generated/_UArrays.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryFactoryJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Output.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/AbstractInput.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/PacketDirect.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Input.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/UTF8.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/AbstractOutput.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferAppend.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferCompatibility.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferFactory.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/BytePacketBuilder.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Preview.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/ByteReadPacket.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Closeable.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Copy.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Experimental.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputLittleEndian.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputPeek.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/InputPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/OutputLittleEndian.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/OutputPrimitives.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Scanner.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/UnsignedTypes.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/Use.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/concurrent/SharedJs.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/ChunkBuffer.kt","../../../../../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Unsafe.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/errors/Errors.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/internal/AwaitingSlot.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/internal/SequentialCopyTo.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/pool/ByteArrayPool.kt","../../../../../ktor-io/common/src/io/ktor/utils/io/pool/Pool.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ByteChannelJS.kt","generated/_Arrays.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ByteChannelSequentialBaseSharedStateJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ByteReadChannelJs.kt","util/Lazy.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ConditionJS.kt","util/Result.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/ExceptionUtilsJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/NativeUtilsJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/ByteOrderJs.kt","kotlin/numbers_js-v1.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/bits/PrimitiveArraysJs.kt","org.w3c/org.khronos.webgl.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/charsets/CharsetJS.kt","kotlin/text/string.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/IoBufferJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/TextDecoders.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/Decoder.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/charsets/DecodeBuffer.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/charsets/ISO88591.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/AbstractInputSharedStateJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/AbstractOutputSharedStateJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/BufferSharedStateJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/ByteOrderJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/ByteReadPacket.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/CloseableJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/InputArraysJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/InputJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/OutputJs.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/PacketJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/ScannerJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/core/StringsJS.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/errors/IOException.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/TextDecoder.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/TextDecoderFallback.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/TypedArrays.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/WebSockets.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/XMLHttpRequest.kt","org.w3c/org.w3c.xhr.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/pool/DefaultPool.kt","../../../../../ktor-io/js/src/io/ktor/utils/io/js/Win1252Table.kt"],"sourcesContent":["package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlinx.atomicfu.locks.*\nimport kotlin.math.*\n\n@Deprecated(\"This is going to become internal. Use ByteReadChannel receiver instead.\", level = DeprecationLevel.ERROR)\npublic suspend fun ByteChannelSequentialBase.joinTo(dst: ByteChannelSequentialBase, closeOnEnd: Boolean) {\n    return joinToImpl(dst, closeOnEnd)\n}\n\n@Deprecated(\"This is going to become internal. Use ByteReadChannel receiver instead.\", level = DeprecationLevel.ERROR)\npublic suspend fun ByteChannelSequentialBase.copyTo(\n    dst: ByteChannelSequentialBase,\n    limit: Long = Long.MAX_VALUE\n): Long {\n    return copyToSequentialImpl(dst, limit)\n}\n\nprivate const val EXPECTED_CAPACITY: Long = 4088L\n\n/**\n * Sequential (non-concurrent) byte channel implementation\n */\n@Suppress(\"OverridingDeprecatedMember\")\n@DangerousInternalIoApi\npublic abstract class ByteChannelSequentialBase(\n    initial: IoBuffer,\n    override val autoFlush: Boolean,\n    pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n) : ByteChannel, ByteReadChannel, ByteWriteChannel, SuspendableReadSession, HasReadSession, HasWriteSession {\n\n    @Suppress(\"unused\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(initial: IoBuffer, autoFlush: Boolean) : this(initial, autoFlush, ChunkBuffer.Pool)\n\n    private val state = ByteChannelSequentialBaseSharedState()\n\n    protected var closed: Boolean\n        get() = state.closed\n        set(value) {\n            state.closed = value\n        }\n\n    protected val writable: BytePacketBuilder = BytePacketBuilder(0, pool)\n    protected val readable: ByteReadPacket = ByteReadPacket(initial, pool)\n\n    private val slot = AwaitingSlot()\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun totalPending(): Int = availableForRead + writable.size\n\n    private val flushSize: Int get() = flushBuffer.size\n\n    override val availableForRead: Int\n        get() = flushSize + readable.remaining.toInt()\n\n    override val availableForWrite: Int\n        get() = maxOf(0, EXPECTED_CAPACITY.toInt() - totalPending())\n\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    override var readByteOrder: ByteOrder\n        get() = state.readByteOrder\n        set(value) {\n            state.readByteOrder = value\n        }\n\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    override var writeByteOrder: ByteOrder\n        get() = state.writeByteOrder\n        set(value) {\n            state.writeByteOrder = value\n        }\n\n    override val isClosedForRead: Boolean\n        get() = closed && readable.isEmpty && flushSize == 0 && writable.isEmpty\n\n    override val isClosedForWrite: Boolean\n        get() = closed\n\n    private var _totalBytesRead: Long\n        get() = state.totalBytesRead\n        set(value) {\n            state.totalBytesRead = value\n        }\n\n    override val totalBytesRead: Long get() = state.totalBytesRead\n\n    private var _totalBytesWritten: Long\n        get() = state.totalBytesWritten\n        set(value) {\n            state.totalBytesWritten = value\n        }\n\n    override val totalBytesWritten: Long get() = state.totalBytesWritten\n\n    final override var closedCause: Throwable?\n        get() = state.closedCause\n        private set(value) {\n            state.closedCause = value\n        }\n\n    private val flushMutex = SynchronizedObject()\n    private val flushBuffer: BytePacketBuilder = BytePacketBuilder()\n\n    internal suspend fun awaitAtLeastNBytesAvailableForWrite(count: Int) {\n        while (availableForWrite < count && !closed) {\n            if (!flushImpl()) {\n                slot.sleep()\n            }\n        }\n    }\n\n    internal suspend fun awaitAtLeastNBytesAvailableForRead(count: Int) {\n        while (availableForRead < count && !closed) {\n            slot.sleep()\n        }\n    }\n\n    override fun flush() {\n        flushImpl()\n    }\n\n    private fun flushImpl(): Boolean {\n        if (writable.isEmpty) {\n            return false\n        }\n\n        flushWrittenBytes()\n        slot.resume()\n        return true\n    }\n\n    /**\n     * Send bytes to thread-safe storage.\n     *\n     * This method is writer-only safe.\n     */\n    private fun flushWrittenBytes() {\n        synchronized(flushMutex) {\n            val buffer = writable.stealAll()!!\n            flushBuffer.writeChunkBuffer(buffer)\n        }\n    }\n\n    /**\n     * Take flushed bytes before read.\n     *\n     * This method is reader-only safe.\n     */\n    protected fun prepareFlushedBytes() {\n        synchronized(flushMutex) {\n            readable.unsafeAppend(flushBuffer)\n        }\n    }\n\n    private fun ensureNotClosed() {\n        if (closed) {\n            throw closedCause ?: ClosedWriteChannelException(\"Channel is already closed\")\n        }\n    }\n\n    private fun ensureNotFailed() {\n        closedCause?.let { throw it }\n    }\n\n    private fun ensureNotFailed(closeable: BytePacketBuilder) {\n        closedCause?.let { cause ->\n            closeable.release()\n            throw cause\n        }\n    }\n\n    override suspend fun writeByte(b: Byte) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        writable.writeByte(b)\n        afterWrite(1)\n    }\n\n    private inline fun <T : Any> reverseWrite(value: () -> T, reversed: () -> T): T {\n        @Suppress(\"DEPRECATION_ERROR\")\n        return if (writeByteOrder == ByteOrder.BIG_ENDIAN) {\n            value()\n        } else {\n            reversed()\n        }\n    }\n\n    override suspend fun writeShort(s: Short) {\n        awaitAtLeastNBytesAvailableForWrite(2)\n        writable.writeShort(reverseWrite({ s }, { s.reverseByteOrder() }))\n        afterWrite(2)\n    }\n\n    override suspend fun writeInt(i: Int) {\n        awaitAtLeastNBytesAvailableForWrite(4)\n        writable.writeInt(reverseWrite({ i }, { i.reverseByteOrder() }))\n        afterWrite(4)\n    }\n\n    override suspend fun writeLong(l: Long) {\n        awaitAtLeastNBytesAvailableForWrite(8)\n        writable.writeLong(reverseWrite({ l }, { l.reverseByteOrder() }))\n        afterWrite(8)\n    }\n\n    override suspend fun writeFloat(f: Float) {\n        awaitAtLeastNBytesAvailableForWrite(4)\n        writable.writeFloat(reverseWrite({ f }, { f.reverseByteOrder() }))\n        afterWrite(4)\n    }\n\n    override suspend fun writeDouble(d: Double) {\n        awaitAtLeastNBytesAvailableForWrite(8)\n        writable.writeDouble(reverseWrite({ d }, { d.reverseByteOrder() }))\n        afterWrite(8)\n    }\n\n    override suspend fun writePacket(packet: ByteReadPacket) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        val size = packet.remaining.toInt()\n        writable.writePacket(packet)\n        afterWrite(size)\n    }\n\n    override suspend fun writeFully(src: IoBuffer) {\n        writeFully(src as Buffer)\n    }\n\n    override suspend fun writeFully(src: Buffer) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        val count = src.readRemaining\n        writable.writeFully(src)\n        afterWrite(count)\n    }\n\n    override suspend fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        var currentIndex = offset\n        val endIndex = offset + length\n\n        while (currentIndex < endIndex) {\n            awaitAtLeastNBytesAvailableForWrite(1)\n\n            val bytesCount = min(availableForWrite, endIndex - currentIndex)\n            writable.writeFully(src, currentIndex, bytesCount)\n\n            currentIndex += bytesCount\n            afterWrite(bytesCount)\n        }\n    }\n\n    override suspend fun writeFully(memory: Memory, startIndex: Int, endIndex: Int) {\n        var currentIndex = startIndex\n\n        while (currentIndex < endIndex) {\n            awaitAtLeastNBytesAvailableForWrite(1)\n\n            val bytesCount = min(availableForWrite, endIndex - currentIndex)\n            writable.writeFully(memory, currentIndex, bytesCount)\n\n            currentIndex += bytesCount\n            afterWrite(bytesCount)\n        }\n    }\n\n    override suspend fun writeAvailable(src: IoBuffer): Int {\n        val srcRemaining = src.readRemaining\n        if (srcRemaining == 0) return 0\n        val size = minOf(srcRemaining, availableForWrite)\n\n        return if (size == 0) writeAvailableSuspend(src)\n        else {\n            writable.writeFully(src, size)\n            afterWrite(size)\n            size\n        }\n    }\n\n    override suspend fun writeAvailable(src: ByteArray, offset: Int, length: Int): Int {\n        if (length == 0) return 0\n        val size = minOf(length, availableForWrite)\n\n        return if (size == 0) writeAvailableSuspend(src, offset, length)\n        else {\n            writable.writeFully(src, offset, size)\n            afterWrite(size)\n            size\n        }\n    }\n\n    @ExperimentalIoApi\n    @Suppress(\"DEPRECATION\")\n    override suspend fun writeSuspendSession(visitor: suspend WriterSuspendSession.() -> Unit) {\n        val session = beginWriteSession()\n        visitor(session)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    override fun beginWriteSession(): WriterSuspendSession {\n        return object : WriterSuspendSession {\n            override fun request(min: Int): IoBuffer? {\n                if (availableForWrite == 0) return null\n                return writable.prepareWriteHead(min) as IoBuffer\n            }\n\n            override fun written(n: Int) {\n                writable.afterHeadWrite()\n                afterWrite(n)\n            }\n\n            override fun flush() {\n                this@ByteChannelSequentialBase.flush()\n            }\n\n            override suspend fun tryAwait(n: Int) {\n                if (availableForWrite < n) {\n                    awaitAtLeastNBytesAvailableForWrite(n)\n                }\n            }\n        }\n    }\n\n    override fun endWriteSession(written: Int) {\n        writable.afterHeadWrite()\n        afterWrite(written)\n    }\n\n    override suspend fun readByte(): Byte {\n        return if (readable.isNotEmpty) {\n            readable.readByte().also { afterRead(1) }\n        } else {\n            readByteSlow()\n        }\n    }\n\n    private fun checkClosed(remaining: Int, closeable: BytePacketBuilder? = null) {\n        closedCause?.let {\n            closeable?.close()\n            throw it\n        }\n        if (closed && availableForRead < remaining) {\n            closeable?.close()\n            throw EOFException(\"$remaining bytes required but EOF reached\")\n        }\n    }\n\n    private suspend fun readByteSlow(): Byte {\n        do {\n            awaitSuspend(1)\n\n            if (readable.isNotEmpty) return readable.readByte().also { afterRead(1) }\n            checkClosed(1)\n        } while (true)\n    }\n\n    override suspend fun readShort(): Short {\n        return if (readable.hasBytes(2)) {\n            readable.readShort().reverseRead().also { afterRead(2) }\n        } else {\n            readShortSlow()\n        }\n    }\n\n    private suspend fun readShortSlow(): Short {\n        readNSlow(2) { return readable.readShort().reverseRead().also { afterRead(2) } }\n    }\n\n    @Deprecated(\"Consider providing consumed count of bytes\", level = DeprecationLevel.ERROR)\n    protected fun afterRead() {\n        afterRead(0)\n    }\n\n    protected fun afterRead(count: Int) {\n        _totalBytesRead += count\n        slot.resume()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Short.reverseRead(): Short = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Int.reverseRead(): Int = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Long.reverseRead(): Long = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Float.reverseRead(): Float = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Double.reverseRead(): Double = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    override suspend fun readInt(): Int {\n        return if (readable.hasBytes(4)) {\n            readable.readInt().reverseRead().also { afterRead(4) }\n        } else {\n            readIntSlow()\n        }\n    }\n\n    private suspend fun readIntSlow(): Int {\n        readNSlow(4) {\n            return readable.readInt().reverseRead().also { afterRead(4) }\n        }\n    }\n\n    override suspend fun readLong(): Long {\n        return if (readable.hasBytes(8)) {\n            readable.readLong().reverseRead().also { afterRead(8) }\n        } else {\n            readLongSlow()\n        }\n    }\n\n    private suspend fun readLongSlow(): Long {\n        readNSlow(8) {\n            return readable.readLong().reverseRead().also { afterRead(8) }\n        }\n    }\n\n    override suspend fun readFloat(): Float = if (readable.hasBytes(4)) {\n        readable.readFloat().reverseRead().also { afterRead(4) }\n    } else {\n        readFloatSlow()\n    }\n\n    private suspend fun readFloatSlow(): Float {\n        readNSlow(4) {\n            return readable.readFloat().reverseRead().also { afterRead(4) }\n        }\n    }\n\n    override suspend fun readDouble(): Double = if (readable.hasBytes(8)) {\n        readable.readDouble().reverseRead().also { afterRead(8) }\n    } else {\n        readDoubleSlow()\n    }\n\n    private suspend fun readDoubleSlow(): Double {\n        readNSlow(8) {\n            return readable.readDouble().reverseRead().also { afterRead(8) }\n        }\n    }\n\n    override suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket {\n        ensureNotFailed()\n\n        val builder = BytePacketBuilder(headerSizeHint)\n\n        val size = minOf(limit, readable.remaining)\n        builder.writePacket(readable, size)\n        val remaining = limit - builder.size\n\n        return if (remaining == 0L || isClosedForRead) {\n            afterRead(remaining.toInt())\n            ensureNotFailed(builder)\n            builder.build()\n        } else {\n            readRemainingSuspend(builder, limit)\n        }\n    }\n\n    private suspend fun readRemainingSuspend(builder: BytePacketBuilder, limit: Long): ByteReadPacket {\n        while (builder.size < limit) {\n            val partLimit = minOf(limit - builder.size, readable.remaining)\n            builder.writePacket(readable, partLimit)\n            afterRead(partLimit.toInt())\n            ensureNotFailed(builder)\n\n            if (isClosedForRead || builder.size == limit.toInt()) {\n                break\n            }\n\n            awaitSuspend(1)\n        }\n\n        ensureNotFailed(builder)\n        return builder.build()\n    }\n\n    override suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket {\n        checkClosed(size)\n\n        val builder = BytePacketBuilder(headerSizeHint)\n\n        var remaining = size\n        val partSize = minOf(remaining.toLong(), readable.remaining).toInt()\n        remaining -= partSize\n        builder.writePacket(readable, partSize)\n        afterRead(partSize)\n        checkClosed(remaining, builder)\n\n        return if (remaining > 0) readPacketSuspend(builder, remaining)\n        else builder.build()\n    }\n\n    private suspend fun readPacketSuspend(builder: BytePacketBuilder, size: Int): ByteReadPacket {\n        var remaining = size\n        while (remaining > 0) {\n            val partSize = minOf(remaining.toLong(), readable.remaining).toInt()\n            remaining -= partSize\n            builder.writePacket(readable, partSize)\n            afterRead(partSize)\n            checkClosed(remaining, builder)\n\n            if (remaining > 0) {\n                awaitSuspend(1)\n            }\n        }\n\n        checkClosed(remaining, builder)\n        return builder.build()\n    }\n\n    protected fun readAvailableClosed(): Int {\n        closedCause?.let { throw it }\n\n        if (availableForRead > 0) {\n            prepareFlushedBytes()\n        }\n\n        return -1\n    }\n\n    override suspend fun readAvailable(dst: IoBuffer): Int = readAvailable(dst as Buffer)\n\n    internal suspend fun readAvailable(dst: Buffer): Int {\n        closedCause?.let { throw it }\n        if (closed && availableForRead == 0) return -1\n\n        if (dst.writeRemaining == 0) return 0\n\n        if (availableForRead == 0) {\n            awaitSuspend(1)\n        }\n\n        if (!readable.canRead()) {\n            prepareFlushedBytes()\n        }\n\n        val size = minOf(dst.writeRemaining.toLong(), readable.remaining).toInt()\n        readable.readFully(dst, size)\n        afterRead(size)\n        return size\n    }\n\n    override suspend fun readFully(dst: IoBuffer, n: Int) {\n        readFully(dst as Buffer, n)\n    }\n\n    private suspend fun readFully(dst: Buffer, n: Int) {\n        require(n <= dst.writeRemaining) { \"Not enough space in the destination buffer to write $n bytes\" }\n        require(n >= 0) { \"n shouldn't be negative\" }\n\n        return when {\n            closedCause != null -> throw closedCause!!\n            readable.remaining >= n -> readable.readFully(dst, n).also { afterRead(n) }\n            closed -> throw EOFException(\n                \"Channel is closed and not enough bytes available: required $n but $availableForRead available\"\n            )\n            else -> readFullySuspend(dst, n)\n        }\n    }\n\n    private suspend fun readFullySuspend(dst: Buffer, n: Int) {\n        awaitSuspend(n)\n        return readFully(dst, n)\n    }\n\n    override suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        closedCause?.let { throw it }\n        if (closed && availableForRead == 0) return -1\n\n        if (length == 0) return 0\n\n        if (availableForRead == 0) {\n            awaitSuspend(1)\n        }\n\n        if (!readable.canRead()) {\n            prepareFlushedBytes()\n        }\n\n        val size = minOf(length.toLong(), readable.remaining).toInt()\n        readable.readFully(dst, offset, size)\n        afterRead(size)\n        return size\n    }\n\n    override suspend fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc == length) return\n        if (rc == -1) throw EOFException(\"Unexpected end of stream\")\n\n        return readFullySuspend(dst, offset + rc, length - rc)\n    }\n\n    private suspend fun readFullySuspend(dst: ByteArray, offset: Int, length: Int) {\n        var written = 0\n\n        while (written < length) {\n            val rc = readAvailable(dst, offset + written, length - written)\n            if (rc == -1) throw EOFException(\"Unexpected end of stream\")\n            written += rc\n        }\n    }\n\n    override suspend fun readBoolean(): Boolean {\n        return if (readable.canRead()) (readable.readByte() == 1.toByte()).also { afterRead(1) }\n        else readBooleanSlow()\n    }\n\n    private suspend fun readBooleanSlow(): Boolean {\n        awaitSuspend(1)\n        checkClosed(1)\n        return readBoolean()\n    }\n\n    private var lastReadAvailable: Int\n        get() = state.lastReadAvailable\n        set(value) {\n            state.lastReadAvailable = value\n        }\n\n    private var lastReadView: ChunkBuffer\n        get() = state.lastReadView\n        set(value) {\n            state.lastReadView = value\n        }\n\n    private fun completeReading() {\n        val remaining = lastReadView.readRemaining\n        val delta = lastReadAvailable - remaining\n        if (lastReadView !== Buffer.Empty) {\n            readable.completeReadHead(lastReadView)\n        }\n        if (delta > 0) {\n            afterRead(delta)\n        }\n        lastReadAvailable = 0\n        lastReadView = ChunkBuffer.Empty\n    }\n\n    override suspend fun await(atLeast: Int): Boolean {\n        require(atLeast >= 0) { \"atLeast parameter shouldn't be negative: $atLeast\" }\n        require(atLeast <= EXPECTED_CAPACITY) {\n            \"atLeast parameter shouldn't be larger than max buffer size of $EXPECTED_CAPACITY: $atLeast\"\n        }\n\n        completeReading()\n\n        if (atLeast == 0) return !isClosedForRead\n        if (readable.remaining >= atLeast) return true\n\n        return awaitSuspend(atLeast)\n    }\n\n    internal suspend fun awaitInternalAtLeast1(): Boolean = if (readable.isNotEmpty) {\n        true\n    } else {\n        awaitSuspend(1)\n    }\n\n    protected suspend fun awaitSuspend(atLeast: Int): Boolean {\n        require(atLeast >= 0)\n\n        awaitAtLeastNBytesAvailableForRead(atLeast)\n        prepareFlushedBytes()\n\n        closedCause?.let { throw it }\n        return !isClosedForRead && availableForRead >= atLeast\n    }\n\n    override fun discard(n: Int): Int {\n        closedCause?.let { throw it }\n\n        if (n == 0) {\n            return 0\n        }\n\n        return readable.discard(n).also {\n            afterRead(n)\n            requestNextView(1)\n        }\n    }\n\n    override fun request(atLeast: Int): IoBuffer? {\n        closedCause?.let { throw it }\n\n        completeReading()\n\n        return requestNextView(atLeast)\n    }\n\n    private fun requestNextView(atLeast: Int): IoBuffer? {\n        if (readable.isEmpty) {\n            prepareFlushedBytes()\n        }\n\n        val view = readable.prepareReadHead(atLeast) as IoBuffer?\n\n        if (view == null) {\n            lastReadView = ChunkBuffer.Empty\n            lastReadAvailable = 0\n        } else {\n            lastReadView = view\n            lastReadAvailable = view.readRemaining\n        }\n\n        return view\n    }\n\n    override suspend fun discard(max: Long): Long {\n        val discarded = readable.discard(max)\n\n        return if (discarded == max || isClosedForRead) {\n            ensureNotFailed()\n            return discarded\n        } else {\n            discardSuspend(max, discarded)\n        }\n    }\n\n    private suspend fun discardSuspend(max: Long, discarded0: Long): Long {\n        var discarded = discarded0\n\n        do {\n            if (!await(1)) break\n            discarded += readable.discard(max - discarded)\n        } while (discarded < max && !isClosedForRead)\n\n        ensureNotFailed()\n\n        return discarded\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read instead.\")\n    override fun readSession(consumer: ReadSession.() -> Unit) {\n        try {\n            consumer(this)\n        } finally {\n            completeReading()\n        }\n    }\n\n    override fun startReadSession(): SuspendableReadSession = this\n\n    override fun endReadSession() {\n        completeReading()\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read instead.\")\n    override suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit) {\n        try {\n            consumer(this)\n        } finally {\n            completeReading()\n        }\n    }\n\n    override suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean {\n        if (isClosedForRead) {\n            val cause = closedCause\n            if (cause != null) {\n                throw cause\n            }\n\n            return false\n        }\n\n        @OptIn(DangerousInternalIoApi::class)\n        return decodeUTF8LineLoopSuspend(out, limit) { size ->\n            afterRead(size)\n            if (await(size)) readable\n            else null\n        }\n    }\n\n    override suspend fun readUTF8Line(limit: Int): String? {\n        val sb = StringBuilder()\n        if (!readUTF8LineTo(sb, limit)) {\n            return null\n        }\n\n        return sb.toString()\n    }\n\n    override fun cancel(cause: Throwable?): Boolean {\n        if (closedCause != null || closed) {\n            return false\n        }\n\n        return close(cause ?: io.ktor.utils.io.CancellationException(\"Channel cancelled\"))\n    }\n\n    override fun close(cause: Throwable?): Boolean {\n        if (closed || closedCause != null) return false\n        closedCause = cause\n        closed = true\n        if (cause != null) {\n            readable.release()\n            writable.release()\n            flushBuffer.release()\n        } else {\n            flush()\n        }\n\n        slot.cancel(cause)\n        return true\n    }\n\n    internal fun transferTo(dst: ByteChannelSequentialBase, limit: Long): Long {\n        val size = readable.remaining\n        return if (size <= limit) {\n            dst.writable.writePacket(readable)\n            dst.afterWrite(size.toInt())\n            afterRead(size.toInt())\n            size\n        } else {\n            0\n        }\n    }\n\n    private suspend inline fun readNSlow(n: Int, block: () -> Nothing): Nothing {\n        do {\n            awaitSuspend(n)\n\n            if (readable.hasBytes(n)) block()\n            checkClosed(n)\n        } while (true)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    private suspend fun writeAvailableSuspend(src: IoBuffer): Int {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        return writeAvailable(src)\n    }\n\n    private suspend fun writeAvailableSuspend(src: ByteArray, offset: Int, length: Int): Int {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        return writeAvailable(src, offset, length)\n    }\n\n    @Deprecated(\"Consider providing written count of bytes\", level = DeprecationLevel.ERROR)\n    protected fun afterWrite() {\n        afterWrite(0)\n    }\n\n    protected fun afterWrite(count: Int) {\n        _totalBytesWritten += count\n\n        if (closed) {\n            writable.release()\n            ensureNotClosed()\n        }\n        if (autoFlush || availableForWrite == 0) {\n            flush()\n        }\n    }\n\n    override suspend fun awaitFreeSpace() {\n        flush()\n        awaitAtLeastNBytesAvailableForWrite(1)\n        ensureNotClosed()\n    }\n\n    final override suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long {\n        var bytesCopied = 0L\n\n        @Suppress(\"DEPRECATION\")\n        readSuspendableSession {\n            val desiredSize = (min + offset).coerceAtMost(EXPECTED_CAPACITY).toInt()\n\n            await(desiredSize)\n\n            val buffer = request(1) ?: IoBuffer.Empty\n            if (buffer.readRemaining > offset) {\n                bytesCopied = minOf(buffer.readRemaining.toLong() - offset, max, destination.size - destinationOffset)\n                buffer.memory.copyTo(destination, offset, bytesCopied, destinationOffset)\n            }\n        }\n\n        return bytesCopied\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = div(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = rem(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = div(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toULong()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toULong()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.mod(other.toULong()).toUInt()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = rem(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\n\npublic expect abstract class Charset {\n    @ExperimentalIoApi\n    public abstract fun newEncoder(): CharsetEncoder\n\n    @ExperimentalIoApi\n    public abstract fun newDecoder(): CharsetDecoder\n\n    public companion object {\n        public fun forName(name: String): Charset\n    }\n}\n\npublic expect val Charset.name: String\n\n// ----------------------------- ENCODER -------------------------------------------------------------------------------\n@ExperimentalIoApi\npublic expect abstract class CharsetEncoder\n\npublic expect val CharsetEncoder.charset: Charset\n\n@Deprecated(\n    \"Use writeText on Output instead.\",\n    ReplaceWith(\"dst.writeText(input, fromIndex, toIndex, charset)\", \"io.ktor.utils.io.core.writeText\")\n)\npublic fun CharsetEncoder.encode(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Output) {\n    encodeToImpl(dst, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\npublic expect fun CharsetEncoder.encodeToByteArray(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray\n\n@Deprecated(\n    \"Internal API. Will be hidden in future releases. Use encodeToByteArray instead.\",\n    replaceWith = ReplaceWith(\"encodeToByteArray(input, fromIndex, toIndex)\")\n)\npublic fun CharsetEncoder.encodeToByteArrayImpl(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    return encodeToByteArray(input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\npublic expect fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output)\n\n@ExperimentalIoApi\npublic fun CharsetEncoder.encode(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteReadPacket = buildPacket {\n    encodeToImpl(this, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\npublic fun CharsetEncoder.encodeUTF8(input: ByteReadPacket): ByteReadPacket = buildPacket {\n    encodeUTF8(input, this)\n}\n\n@ExperimentalIoApi\npublic fun CharsetEncoder.encode(input: CharArray, fromIndex: Int, toIndex: Int, dst: Output) {\n    var start = fromIndex\n\n    if (start >= toIndex) return\n    dst.writeWhileSize(1) { view: Buffer ->\n        val rc = encodeArrayImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    encodeCompleteImpl(dst)\n}\n\n// ----------------------------- DECODER -------------------------------------------------------------------------------\n\n@ExperimentalIoApi\npublic expect abstract class CharsetDecoder\n\n/**\n * Decoder's charset it is created for.\n */\npublic expect val CharsetDecoder.charset: Charset\n\n@ExperimentalIoApi\npublic fun CharsetDecoder.decode(input: Input, max: Int = Int.MAX_VALUE): String =\n    buildString(minOf(max.toLong(), input.sizeEstimate()).toInt()) {\n        decode(input, this, max)\n    }\n\n@ExperimentalIoApi\npublic expect fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int\n\n@ExperimentalIoApi\npublic expect fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String\n\n// ----------------------------- REGISTRY ------------------------------------------------------------------------------\npublic expect object Charsets {\n    public val UTF_8: Charset\n    public val ISO_8859_1: Charset\n}\n\npublic expect open class MalformedInputException(message: String) : Throwable\n\npublic class TooLongLineException(message: String) : MalformedInputException(message)\n\n// ----------------------------- INTERNALS -----------------------------------------------------------------------------\n\ninternal fun CharsetEncoder.encodeArrayImpl(input: CharArray, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    val length = toIndex - fromIndex\n    return encodeImpl(CharArraySequence(input, fromIndex, length), 0, length, dst)\n}\n\ninternal expect fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int\n\ninternal expect fun CharsetEncoder.encodeComplete(dst: Buffer): Boolean\n\ninternal expect fun CharsetDecoder.decodeBuffer(\n    input: Buffer,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int = Int.MAX_VALUE\n): Int\n\ninternal fun CharsetEncoder.encodeToByteArrayImpl1(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    var start = fromIndex\n    if (start >= toIndex) return EmptyByteArray\n    val single = ChunkBuffer.Pool.borrow()\n\n    try {\n        val rc = encodeImpl(input, start, toIndex, single)\n        start += rc\n        if (start == toIndex) {\n            val result = ByteArray(single.readRemaining)\n            single.readFully(result)\n            return result\n        }\n\n        return buildPacket {\n            appendSingleChunk(single.duplicate())\n            encodeToImpl(this, input, start, toIndex)\n        }.readBytes()\n    } finally {\n        single.release(ChunkBuffer.Pool)\n    }\n}\n\ninternal fun Input.sizeEstimate(): Long = when (this) {\n    is ByteReadPacket -> remaining\n    is AbstractInput -> maxOf(remaining, 16)\n    else -> 16\n}\n\nprivate fun CharsetEncoder.encodeCompleteImpl(dst: Output): Int {\n    var size = 1\n    var bytesWritten = 0\n\n    dst.writeWhile { view ->\n        val before = view.writeRemaining\n        if (encodeComplete(view)) {\n            size = 0\n        } else {\n            size++\n        }\n        bytesWritten += before - view.writeRemaining\n        size > 0\n    }\n\n    return bytesWritten\n}\n\ninternal fun CharsetEncoder.encodeToImpl(\n    destination: Output,\n    input: CharSequence,\n    fromIndex: Int,\n    toIndex: Int\n): Int {\n    var start = fromIndex\n    if (start >= toIndex) return 0\n\n    var bytesWritten = 0\n\n    destination.writeWhileSize(1) { view: Buffer ->\n        val before = view.writeRemaining\n        val rc = encodeImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n        bytesWritten += before - view.writeRemaining\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    bytesWritten += encodeCompleteImpl(destination)\n    return bytesWritten\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /** Increments this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n    /** Decrements this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\n\npublic actual inline fun Memory.loadShortAt(offset: Int): Short = view.getInt16(offset, false)\n\npublic actual inline fun Memory.loadShortAt(offset: Long): Short = loadShortAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadIntAt(offset: Int): Int = view.getInt32(offset, false)\n\npublic actual inline fun Memory.loadIntAt(offset: Long): Int = loadIntAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadLongAt(offset: Int): Long =\n    (view.getUint32(offset, false).toLong() shl 32) or\n        view.getUint32(offset + 4, false).toLong()\n\npublic actual inline fun Memory.loadLongAt(offset: Long): Long = loadLongAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadFloatAt(offset: Int): Float = view.getFloat32(offset, false)\n\npublic actual inline fun Memory.loadFloatAt(offset: Long): Float = loadFloatAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadDoubleAt(offset: Int): Double = view.getFloat64(offset, false)\n\npublic actual inline fun Memory.loadDoubleAt(offset: Long): Double = loadDoubleAt(offset.toIntOrFail(\"offset\"))\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeIntAt(offset: Int, value: Int) {\n    view.setInt32(offset, value, littleEndian = false)\n}\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeIntAt(offset: Long, value: Int) {\n    view.setInt32(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeShortAt(offset: Int, value: Short) {\n    view.setInt16(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeShortAt(offset: Long, value: Short) {\n    view.setInt16(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeLongAt(offset: Int, value: Long) {\n    view.setInt32(offset, (value shr 32).toInt(), littleEndian = false)\n    view.setInt32(offset + 4, (value and 0xffffffffL).toInt(), littleEndian = false)\n}\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeLongAt(offset: Long, value: Long) {\n    storeLongAt(offset.toIntOrFail(\"offset\"), value)\n}\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeFloatAt(offset: Int, value: Float) {\n    view.setFloat32(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeFloatAt(offset: Long, value: Float) {\n    view.setFloat32(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeDoubleAt(offset: Int, value: Double) {\n    view.setFloat64(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeDoubleAt(offset: Long, value: Double) {\n    view.setFloat64(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyBytesTemplate(offset, length) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 2) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: Buffer, length: Int = dst.writeRemaining) {\n    readFullyBytesTemplate(0, length) { src, _, count ->\n        src.readFully(dst, count)\n    }.requireNoRemaining()\n}\n\npublic fun Input.readFully(destination: Memory, destinationOffset: Int, length: Int) {\n    readFully(destination, destinationOffset.toLong(), length.toLong())\n}\n\npublic fun Input.readFully(destination: Memory, destinationOffset: Long, length: Long) {\n    if (readAvailable(destination, destinationOffset, length) != length) {\n        prematureEndOfStream(length)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyBytesTemplate(offset, length) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 2) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\npublic fun Input.readAvailable(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    return length - readFullyBytesTemplate(0, length) { src, _, count ->\n        src.readFully(dst, count)\n    }\n}\n\npublic fun Input.readAvailable(destination: Memory, destinationOffset: Int, length: Int): Int {\n    return readAvailable(destination, destinationOffset.toLong(), length.toLong()).toInt()\n}\n\npublic fun Input.readAvailable(destination: Memory, destinationOffset: Long, length: Long): Long {\n    val remaining = readFullyBytesTemplate(destinationOffset, length) { src, srcOffset, dstOffset, count ->\n        src.copyTo(destination, srcOffset, count.toLong(), dstOffset)\n    }\n    val result = length - remaining\n    return when {\n        result == 0L && endOfInput -> -1\n        else -> result\n    }\n}\n\n/**\n * @return number of bytes remaining or 0 if all [length] bytes were copied\n */\nprivate inline fun Input.readFullyBytesTemplate(\n    initialDstOffset: Int,\n    length: Int,\n    readBlock: (src: Buffer, dstOffset: Int, count: Int) -> Unit\n): Int {\n    var remaining = length\n    var dstOffset = initialDstOffset\n\n    takeWhile { buffer ->\n        val count = minOf(remaining, buffer.readRemaining)\n        readBlock(buffer, dstOffset, count)\n        remaining -= count\n        dstOffset += count\n\n        remaining > 0\n    }\n\n    return remaining\n}\n\n/**\n * @return number of bytes remaining or 0 if all [length] bytes were copied\n */\nprivate inline fun Input.readFullyBytesTemplate(\n    initialDstOffset: Long,\n    length: Long,\n    readBlock: (src: Memory, srcOffset: Long, dstOffset: Long, count: Int) -> Unit\n): Long {\n    var remaining = length\n    var dstOffset = initialDstOffset\n\n    takeWhile { buffer ->\n        val count = minOf(remaining, buffer.readRemaining.toLong()).toInt()\n        readBlock(buffer.memory, buffer.readPosition.toLong(), dstOffset, count)\n        buffer.discardExact(count)\n        remaining -= count\n        dstOffset += count\n\n        remaining > 0\n    }\n\n    return remaining\n}\n\n/**\n * @return number of elements remaining or 0 if all [length] elements were copied\n */\nprivate inline fun Input.readFullyTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    readBlock: (src: Buffer, dstOffset: Int, count: Int) -> Unit\n): Int {\n    var remaining = length\n    var dstOffset = offset\n\n    takeWhileSize { buffer ->\n        val count = minOf(remaining, buffer.readRemaining / componentSize)\n        readBlock(buffer, dstOffset, count)\n        remaining -= count\n        dstOffset += count\n\n        when {\n            remaining > 0 -> componentSize\n            else -> 0\n        }\n    }\n\n    return remaining\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Int.requireNoRemaining() {\n    if (this > 0) {\n        prematureEndOfStream(this)\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.contracts.*\n\n/**\n * A read-write facade to actual buffer of fixed size. Multiple views could share the same actual buffer.\n * Concurrent unsafe. The only concurrent-safe operation is [release].\n * In most cases [ByteReadPacket] and [BytePacketBuilder] should be used instead.\n */\n@Suppress(\"DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES\", \"DEPRECATION\")\n@Deprecated(\"Use Memory, Input or Output instead.\")\npublic expect class IoBuffer : Input, Output, ChunkBuffer {\n\n    @Suppress(\"ConvertSecondaryConstructorToPrimary\")\n    public constructor(memory: Memory, origin: ChunkBuffer?)\n\n    internal constructor(memory: Memory, origin: ChunkBuffer?, parentPool: ObjectPool<IoBuffer>?)\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n            \"do readXXX/writeXXX with X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder\n\n    override fun close()\n\n    final override fun flush()\n\n    public fun release(pool: ObjectPool<IoBuffer>)\n\n    @Suppress(\"DEPRECATION\")\n    public companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [ChunkBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        public val ReservedSize: Int\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        public val Empty: IoBuffer\n\n        /**\n         * The default buffer pool\n         */\n        public val Pool: ObjectPool<IoBuffer>\n\n        /**\n         * Pool that always instantiates new buffers instead of reusing it\n         */\n        public val NoPool: ObjectPool<IoBuffer>\n\n        /**\n         * A pool that always returns [IoBuffer.Empty]\n         */\n        public val EmptyPool: ObjectPool<IoBuffer>\n    }\n}\n\n/**\n * Read the specified number of bytes specified (optional, read all remaining by default)\n */\npublic fun Buffer.readBytes(count: Int = readRemaining): ByteArray {\n    if (count == 0) {\n        return EmptyByteArray\n    }\n\n    val result = ByteArray(count)\n    readFully(result)\n    return result\n}\n\n@Suppress(\"DEPRECATION\")\ninternal fun IoBuffer.releaseImpl() {\n    releaseImpl(IoBuffer.Pool)\n}\n\n@Deprecated(\n    \"IoBuffer now contains ObjectPool reference\",\n    level = DeprecationLevel.WARNING,\n    replaceWith = ReplaceWith(\"releaseImpl()\")\n)\n@Suppress(\"DEPRECATION\")\ninternal fun IoBuffer.releaseImpl(pool: ObjectPool<IoBuffer>) {\n    if (!release()) return\n\n    val origin = origin\n    val poolToUse = (parentPool ?: pool) as ObjectPool<IoBuffer>\n\n    when (origin) {\n        is IoBuffer -> {\n            unlink()\n            origin.release(pool)\n        }\n        else -> {\n            poolToUse.recycle(this)\n        }\n    }\n}\n\n@Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\ninternal object EmptyBufferPoolImpl : NoPoolImpl<IoBuffer>() {\n    override fun borrow() = IoBuffer.Empty\n}\n\ninternal fun ChunkBuffer?.releaseAll(pool: ObjectPool<ChunkBuffer>) {\n    var current = this\n    while (current != null) {\n        val next = current.cleanNext()\n        current.release(pool)\n        current = next\n    }\n}\n\ninternal inline fun ChunkBuffer.forEachChunk(block: (ChunkBuffer) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    var current = this\n    do {\n        block(current)\n        current = current.next ?: break\n    } while (true)\n}\n\n/**\n * Copy every element of the chain starting from this and setup next links.\n */\ninternal fun ChunkBuffer.copyAll(): ChunkBuffer {\n    val copied = duplicate()\n    val next = this.next ?: return copied\n\n    return next.copyAll(copied, copied)\n}\n\nprivate tailrec fun ChunkBuffer.copyAll(head: ChunkBuffer, prev: ChunkBuffer): ChunkBuffer {\n    val copied = duplicate()\n    prev.next = copied\n\n    val next = this.next ?: return head\n\n    return next.copyAll(head, copied)\n}\n\ninternal tailrec fun ChunkBuffer.findTail(): ChunkBuffer {\n    val next = this.next ?: return this\n    return next.findTail()\n}\n\n/**\n * Summarize remainings of all elements of the chain\n */\n@DangerousInternalIoApi\npublic fun ChunkBuffer.remainingAll(): Long = remainingAll(0L)\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun remainingAll(buffer: IoBuffer): Long = buffer.remainingAll()\n\nprivate tailrec fun ChunkBuffer.remainingAll(n: Long): Long {\n    val rem = readRemaining.toLong() + n\n    val next = this.next ?: return rem\n\n    return next.remainingAll(rem)\n}\n\ninternal tailrec fun ChunkBuffer.isEmpty(): Boolean {\n    if (readRemaining > 0) return false\n    val next = this.next ?: return true\n    return next.isEmpty()\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxInt(): Int = minOf(this, Int.MAX_VALUE.toLong()).toInt()\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxIntOrFail(message: String): Int {\n    if (this > Int.MAX_VALUE.toLong()) throw IllegalArgumentException(message)\n    return this.toInt()\n}\n\ninternal fun Buffer.peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n    val size = minOf(\n        destination.size - destinationOffset,\n        max,\n        readRemaining.toLong()\n    )\n\n    memory.copyTo(\n        destination,\n        readPosition + offset,\n        size,\n        destinationOffset\n    )\n\n    return size\n}\n\npublic class BufferLimitExceededException(message: String) : Exception(message)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous reading of sequences of bytes.\n * This is a **single-reader channel**.\n *\n * Operations on this channel cannot be invoked concurrently.\n */\npublic expect interface ByteReadChannel {\n    /**\n     * Returns number of bytes that can be read without suspension. Read operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for read.\n     */\n    public val availableForRead: Int\n\n    /**\n     * Returns `true` if the channel is closed and no remaining bytes are available for read.\n     * It implies that [availableForRead] is zero.\n     */\n    public val isClosedForRead: Boolean\n\n    public val isClosedForWrite: Boolean\n\n    /**\n     * An closure cause exception or `null` if closed successfully or not yet closed\n     */\n    public val closedCause: Throwable?\n\n    /**\n     * Byte order that is used for multi-byte read operations\n     * (such as [readShort], [readInt], [readLong], [readFloat], and [readDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var readByteOrder: ByteOrder\n\n    /**\n     * Number of bytes read from the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of long running read operation.\n     */\n    public val totalBytesRead: Long\n\n    /**\n     * Reads all available bytes to [dst] buffer and returns immediately or suspends if no bytes available\n     * @return number of bytes were read or `-1` if the channel has been closed\n     */\n    public suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    public suspend fun readAvailable(dst: IoBuffer): Int\n\n    /**\n     * Reads all [length] bytes to [dst] buffer or fails if channel has been closed.\n     * Suspends if not enough bytes available.\n     */\n    public suspend fun readFully(dst: ByteArray, offset: Int, length: Int)\n    public suspend fun readFully(dst: IoBuffer, n: Int)\n\n    /**\n     * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n     * and not enough bytes available. Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    public suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n     * Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    public suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads a long number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readLong(): Long\n\n    /**\n     * Reads an int number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readInt(): Int\n\n    /**\n     * Reads a short number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readShort(): Short\n\n    /**\n     * Reads a byte (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readByte(): Byte\n\n    /**\n     * Reads a boolean value (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readBoolean(): Boolean\n\n    /**\n     * Reads double number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readDouble(): Double\n\n    /**\n     * Reads float number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readFloat(): Float\n\n    /**\n     * Starts non-suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * event if there are no bytes available for read yet.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    public fun readSession(consumer: ReadSession.() -> Unit)\n\n    /**\n     * Starts a suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * even if there are no bytes available for read yet. [consumer] lambda could suspend as much as needed.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    public suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit)\n\n    /**\n     * Reads a line of UTF-8 characters to the specified [out] buffer up to [limit] characters.\n     * Supports both CR-LF and LF line endings. No line ending characters will be appended to [out] buffer.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return `true` if line has been read (possibly empty) or `false` if channel has been closed\n     * and no characters were read.\n     */\n    public suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean\n\n    /**\n     * Reads a line of UTF-8 characters up to [limit] characters.\n     * Supports both CR-LF and LF line endings.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return a line string with no line endings or `null` of channel has been closed\n     * and no characters were read.\n     */\n    public suspend fun readUTF8Line(limit: Int): String?\n\n    /**\n     * Close channel with optional [cause] cancellation. Unlike [ByteWriteChannel.close] that could close channel\n     * normally, cancel does always close with error so any operations on this channel will always fail\n     * and all suspensions will be resumed with exception.\n     *\n     * Please note that if the channel has been provided by [reader] or [writer] then the corresponding owning\n     * coroutine will be cancelled as well\n     *\n     * @see ByteWriteChannel.close\n     */\n    public fun cancel(cause: Throwable?): Boolean\n\n    /**\n     * Discard up to [max] bytes\n     *\n     * @return number of bytes were discarded\n     */\n    public suspend fun discard(max: Long): Long\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source suspending reading.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [isClosedForRead].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    public suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long = 0,\n        min: Long = 1,\n        max: Long = Long.MAX_VALUE\n    ): Long\n\n    public companion object {\n        public val Empty: ByteReadChannel\n    }\n}\n\n/**\n * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n * and not enough bytes available.\n */\npublic suspend fun ByteReadChannel.readPacket(size: Int): ByteReadPacket = readPacket(size, 0)\n\n/**\n * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n */\npublic suspend fun ByteReadChannel.readRemaining(limit: Long): ByteReadPacket = readRemaining(limit, 0)\n\n/**\n * Reads all remaining bytes and makes a byte packet\n */\npublic suspend fun ByteReadChannel.readRemaining(): ByteReadPacket = readRemaining(Long.MAX_VALUE, 0)\n\npublic suspend fun ByteReadChannel.readFully(dst: IoBuffer) {\n    readFully(dst, dst.writeRemaining)\n}\n\npublic suspend fun ByteReadChannel.readUTF8LineTo(out: Appendable): Boolean {\n    return readUTF8LineTo(out, Int.MAX_VALUE)\n}\n\npublic suspend fun ByteReadChannel.readUTF8Line(): String? {\n    return readUTF8Line(Int.MAX_VALUE)\n}\n\npublic fun ByteReadChannel.cancel(): Boolean = cancel(null)\n\n/**\n * Discards all bytes in the channel and suspends until end of stream.\n */\npublic suspend fun ByteReadChannel.discard(): Long = discard(Long.MAX_VALUE)\n\n/**\n * Discards exactly [n] bytes or fails if not enough bytes in the channel\n */\npublic suspend inline fun ByteReadChannel.discardExact(n: Long) {\n    if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes\")\n}\n\npublic suspend fun ByteReadChannel.readAvailable(dst: ByteArray): Int = readAvailable(dst, 0, dst.size)\n\npublic suspend fun ByteReadChannel.readFully(dst: ByteArray): Unit = readFully(dst, 0, dst.size)\n\npublic expect suspend fun ByteReadChannel.joinTo(dst: ByteWriteChannel, closeOnEnd: Boolean)\n\n/**\n * Reads bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel): Long = copyTo(dst, limit = Long.MAX_VALUE)\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic expect suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel, limit: Long): Long\n\n/**\n * Reads all the bytes from receiver channel and writes them to [dst] channel and then closes it.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic suspend fun ByteReadChannel.copyAndClose(dst: ByteWriteChannel, limit: Long = Long.MAX_VALUE): Long {\n    val count = copyTo(dst, limit)\n    dst.close()\n    return count\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\n@OptIn(ExperimentalStdlibApi::class)\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","/*\n * Copyright 2016-2017 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\n\n/**\n * Channel for asynchronous reading and writing of sequences of bytes.\n * This is a buffered **single-reader single-writer channel**.\n *\n * Read operations can be invoked concurrently with write operations, but multiple reads or multiple writes\n * cannot be invoked concurrently with themselves. Exceptions are [close] and [flush] which can be invoked\n * concurrently with any other operations and between themselves at any time.\n */\npublic interface ByteChannel : ByteReadChannel, ByteWriteChannel {\n    public fun attachJob(job: Job)\n}\n\n/**\n * Creates buffered channel for asynchronous reading and writing of sequences of bytes.\n */\npublic expect fun ByteChannel(autoFlush: Boolean = false): ByteChannel\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy it's bytes depending on the platform.\n */\npublic fun ByteReadChannel(content: ByteArray): ByteReadChannel =\n    ByteReadChannel(content, 0, content.size)\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy it's bytes depending on the platform.\n */\npublic fun ByteReadChannel(content: ByteArray, offset: Int): ByteReadChannel =\n    ByteReadChannel(content, offset, content.size)\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy it's bytes depending on the platform\n */\npublic expect fun ByteReadChannel(content: ByteArray, offset: Int, length: Int): ByteReadChannel\n\npublic fun ByteReadChannel(text: String, charset: Charset = Charsets.UTF_8): ByteReadChannel =\n    ByteReadChannel(text.toByteArray(charset)) // TODO optimize to encode parts on demand\n\n/**\n * Byte channel that is always empty.\n */\n@Deprecated(\n    \"Use ByteReadChannel.Empty instead\",\n    ReplaceWith(\"ByteReadChannel.Empty\"),\n    level = DeprecationLevel.ERROR\n)\npublic val EmptyByteReadChannel: ByteReadChannel\n    get() = ByteReadChannel.Empty\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\n\n@Suppress(\"NOTHING_TO_INLINE\")\npublic inline fun String.toByteArray(charset: Charset = Charsets.UTF_8): ByteArray =\n    charset.newEncoder().encodeToByteArray(this, 0, length)\n\n/**\n * Create an instance of [String] from the specified [bytes] range starting at [offset] and bytes [length]\n * interpreting characters in the specified [charset].\n */\n@Suppress(\"FunctionName\")\npublic expect fun String(\n    bytes: ByteArray,\n    offset: Int = 0,\n    length: Int = bytes.size,\n    charset: Charset = Charsets.UTF_8\n): String\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\npublic fun ByteReadPacket.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    if (isEmpty) return null\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\npublic fun Input.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read UTF-8 line and append all line characters to [out] except line endings. Does support CR, LF and CR+LF\n * @return `true` if some characters were appended or line ending reached (empty line) or `false` if packet\n * if empty\n */\npublic fun Input.readUTF8LineTo(out: Appendable, limit: Int): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    takeWhileSize { buffer ->\n        var skip = 0\n        size = buffer.decodeUTF8 { ch ->\n            when (ch) {\n                '\\r' -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n                    cr = true\n                    true\n                }\n                '\\n' -> {\n                    end = true\n                    skip = 1\n                    false\n                }\n                else -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n\n                    if (decoded == limit) bufferLimitExceeded(limit)\n                    decoded++\n                    out.append(ch)\n                    true\n                }\n            }\n        }\n\n        if (skip > 0) {\n            buffer.discardExact(skip)\n        }\n\n        if (end) 0 else size.coerceAtLeast(1)\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded > 0 || !endOfInput\n}\n\n/**\n * Reads UTF-8 characters until one of the specified [delimiters] found, [limit] exceeded or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns a string of characters read before delimiter\n */\npublic fun Input.readUTF8UntilDelimiter(delimiters: String, limit: Int = Int.MAX_VALUE): String {\n    return buildString {\n        readUTF8UntilDelimiterTo(this, delimiters, limit)\n    }\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\npublic fun Input.readUTF8UntilDelimiterTo(out: Appendable, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n    }\n\n    if (!delimiter) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\npublic fun Input.readUTF8UntilDelimiterTo(out: Output, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    val delimitersCount = delimiters.length\n    if (delimitersCount == 1 && delimiters[0].isAsciiChar()) {\n        return readUntilDelimiter(delimiters[0].toByte(), out).toInt()\n    } else if (delimitersCount == 2 && delimiters[0].isAsciiChar() && delimiters[1].isAsciiChar()) {\n        return readUntilDelimiters(delimiters[0].toByte(), delimiters[1].toByte(), out).toInt()\n    }\n\n    return readUTFUntilDelimiterToSlowAscii(delimiters, limit, out)\n}\n\n@Suppress(\"unused\", \"DEPRECATION_ERROR\")\n@Deprecated(\"Use Output version instead\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readUTF8UntilDelimiterTo(\n    out: BytePacketBuilderBase,\n    delimiters: String,\n    limit: Int = Int.MAX_VALUE\n): Int {\n    return readUTF8UntilDelimiterTo(out as Output, delimiters, limit)\n}\n\n/**\n * Read exactly [n] bytes (consumes all remaining if [n] is not specified but up to [Int.MAX_VALUE] bytes).\n * Does fail if not enough bytes remaining.\n */\npublic fun ByteReadPacket.readBytes(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to convert to a ByteArray: packet is too big\")\n): ByteArray = when {\n    n != 0 -> ByteArray(n).also { readFully(it, 0, n) }\n    else -> EmptyByteArray\n}\n\n/**\n * Reads exactly [n] bytes from the input or fails if not enough bytes available.\n */\npublic fun Input.readBytes(n: Int): ByteArray = readBytesOf(n, n)\n\n/**\n * Reads all remaining bytes from the input\n */\npublic fun Input.readBytes(): ByteArray = readBytesOf()\n\n/**\n * Reads at least [min] but no more than [max] bytes from the input to a new byte array\n * @throws EOFException if not enough bytes available to get [min] bytes\n */\npublic fun Input.readBytesOf(min: Int = 0, max: Int = Int.MAX_VALUE): ByteArray = if (min == max && min == 0) {\n    EmptyByteArray\n} else if (min == max) {\n    ByteArray(min).also { readFully(it, 0, min) }\n} else {\n    var array = ByteArray(max.toLong().coerceAtMost(sizeEstimate()).coerceAtLeast(min.toLong()).toInt())\n    var size = 0\n\n    while (size < max) {\n        val partSize = minOf(max, array.size) - size\n        val rc = readAvailable(array, size, partSize)\n        if (rc <= 0) break\n        size += rc\n        if (array.size == size) {\n            array = array.copyOf(size * 2)\n        }\n    }\n\n    if (size < min) {\n        throw EOFException(\"Not enough bytes available to read $min bytes: ${min - size} more required\")\n    }\n\n    if (size == array.size) array else array.copyOf(size)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, out, max)\", \"io.ktor.utils.io.charsets.decode\"),\n    level = DeprecationLevel.ERROR\n)\npublic fun Input.readText(out: Appendable, decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): Int {\n    return decoder.decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\npublic fun Input.readText(out: Appendable, charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): Int {\n    return charset.newDecoder().decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, max)\", \"io.ktor.utils.io.charsets.decode\")\n)\npublic fun Input.readText(decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): String {\n    return decoder.decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\npublic fun Input.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String {\n    return charset.newDecoder().decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\npublic fun Buffer.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String = buildString {\n    charset.newDecoder().decodeBuffer(this@readText, this, true, max)\n}\n\n/**\n * Read exactly [n] characters interpreting bytes in the specified [charset].\n */\n@Deprecated(\n    \"Use readTextExactCharacters instead.\",\n    ReplaceWith(\"readTextExactCharacters(n, charset)\")\n)\npublic fun Input.readTextExact(charset: Charset = Charsets.UTF_8, n: Int): String {\n    return readTextExactCharacters(n, charset)\n}\n\n/**\n * Read exactly [charactersCount] characters interpreting bytes in the specified [charset].\n */\npublic fun Input.readTextExactCharacters(charactersCount: Int, charset: Charset = Charsets.UTF_8): String {\n    val s = readText(charset, charactersCount)\n    if (s.length < charactersCount) {\n        prematureEndOfStreamToReadChars(charactersCount)\n    }\n    return s\n}\n\n/**\n * Read exactly the specified number of [bytes]\n * interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\n@Deprecated(\"Parameters order is changed.\", ReplaceWith(\"readTextExactBytes(bytes, charset)\"))\npublic fun Input.readTextExactBytes(charset: Charset = Charsets.UTF_8, bytes: Int): String {\n    return readTextExactBytes(bytes, charset)\n}\n\n/**\n * Read exactly [bytesCount] interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\npublic fun Input.readTextExactBytes(bytesCount: Int, charset: Charset = Charsets.UTF_8): String {\n    return charset.newDecoder().decodeExactBytes(this, inputLength = bytesCount)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [encoder]\n */\n@Deprecated(\n    \"Use the implementation with Charset instead\",\n    ReplaceWith(\n        \"writeText(text, fromIndex, toIndex, encoder.charset)\",\n        \"io.ktor.utils.io.charsets.charset\"\n    ),\n    level = DeprecationLevel.ERROR\n)\npublic fun Output.writeText(\n    text: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = text.length,\n    encoder: CharsetEncoder\n) {\n    encoder.encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\npublic fun Output.writeText(\n    text: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = text.length,\n    charset: Charset = Charsets.UTF_8\n) {\n    if (charset === Charsets.UTF_8) {\n        return writeTextUtf8(text, fromIndex, toIndex)\n    }\n\n    charset.newEncoder().encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\npublic fun Output.writeText(\n    text: CharArray,\n    fromIndex: Int = 0,\n    toIndex: Int = text.size,\n    charset: Charset = Charsets.UTF_8\n) {\n    if (charset === Charsets.UTF_8) {\n        return writeTextUtf8(CharArraySequence(text, 0, text.size), fromIndex, toIndex)\n    }\n\n    charset.newEncoder().encode(text, fromIndex, toIndex, this)\n}\n\nprivate fun Output.writeTextUtf8(text: CharSequence, fromIndex: Int, toIndex: Int) {\n    var index = fromIndex\n    writeWhileSize(1) { buffer ->\n        val memory = buffer.memory\n        val dstOffset = buffer.writePosition\n        val dstLimit = buffer.limit\n\n        val (characters, bytes) = memory.encodeUTF8(text, index, toIndex, dstOffset, dstLimit)\n\n        index += characters.toInt()\n        buffer.commitWritten(bytes.toInt())\n\n        when {\n            characters.toInt() == 0 && index < toIndex -> 8\n            index < toIndex -> 1\n            else -> 0\n        }\n    }\n}\n\ninternal expect fun String.getCharsInternal(dst: CharArray, dstOffset: Int)\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Char.isAsciiChar() = toInt() <= 0x7f\n\nprivate fun Input.readUTFUntilDelimiterToSlowAscii(delimiters: String, limit: Int, out: Output): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        val before = buffer.readRemaining\n\n        val rc = buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.rewind(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        rc\n    }\n\n    if (!delimiter && !endOfInput) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Output,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        val before = buffer.readRemaining\n\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.rewind(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Appendable,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun bufferLimitExceeded(limit: Int): Nothing {\n    throw BufferLimitExceededException(\"Too many characters before delimiter: limit $limit exceeded\")\n}\n\n@PublishedApi\ninternal fun prematureEndOfStream(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes\")\n\n@PublishedApi\ninternal fun prematureEndOfStream(size: Long): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes\")\n\nprivate fun prematureEndOfStreamToReadChars(charactersCount: Int): Nothing =\n    throw EOFException(\"Not enough input bytes to read $charactersCount characters.\")\n","package io.ktor.utils.io.core.internal\n\nimport kotlin.contracts.*\n\n@PublishedApi\ninternal inline fun require(condition: Boolean, crossinline message: () -> String) {\n    contract {\n        returns() implies condition\n    }\n\n    if (!condition) {\n        val m = object : RequireFailureCapture() {\n            override fun doFail(): Nothing {\n                throw IllegalArgumentException(message())\n            }\n        }\n        m.doFail()\n    }\n}\n\n@PublishedApi\ninternal abstract class RequireFailureCapture {\n    abstract fun doFail(): Nothing\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.errors.*\nimport io.ktor.utils.io.pool.*\n\n@DangerousInternalIoApi\n@Deprecated(\n    \"Will be removed in the future releases. Use Input or AbstractInput instead.\",\n    ReplaceWith(\"AbstractInput\", \"io.ktor.utils.io.core.AbstractInput\")\n)\npublic abstract class ByteReadPacketBase(\n    head: ChunkBuffer,\n    remaining: Long,\n    pool: ObjectPool<ChunkBuffer>\n) : AbstractInput(head, remaining, pool) {\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(\n        head: IoBuffer,\n        remaining: Long,\n        pool: ObjectPool<ChunkBuffer>\n    ) : this(head as ChunkBuffer, remaining, pool)\n\n    public companion object {\n        @Deprecated(\n            \"Use ByteReadPacket.Empty instead\",\n            ReplaceWith(\"ByteReadPacket.Empty\"),\n            level = DeprecationLevel.ERROR\n        )\n        public val Empty: ByteReadPacket\n            get() = ByteReadPacket.Empty\n    }\n}\n\npublic expect class EOFException(message: String) : IOException\n\n/**\n * For streaming input it should be [Input.endOfInput] instead.\n */\n@Deprecated(\"Use endOfInput property instead\", ReplaceWith(\"endOfInput\"))\npublic inline val Input.isEmpty: Boolean\n    get() = endOfInput\n\n/**\n * For streaming input there is no reliable way to detect it without triggering bytes population from the underlying\n * source. Consider using [Input.endOfInput] or use [ByteReadPacket] instead.\n */\n@Deprecated(\n    \"This makes no sense for streaming inputs. Some use-cases are covered by endOfInput property\",\n    ReplaceWith(\"!endOfInput\")\n)\npublic val Input.isNotEmpty: Boolean\n    get() {\n        if (endOfInput) return false\n        prepareReadFirstHead(1)?.let { found ->\n            completeReadHead(found)\n            return true\n        }\n        return false\n    }\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic inline val ByteReadPacket.isEmpty: Boolean\n    get() = endOfInput\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic inline val ByteReadPacket.isNotEmpty: Boolean\n    get() = !endOfInput\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.errors.EOFException\nimport kotlin.contracts.*\n\n/**\n * Represents a buffer with read and write positions.\n *\n * Concurrent unsafe: the same memory could be shared between different instances of [Buffer] however you can't\n * read/write using the same [Buffer] instance from different threads.\n */\n@DangerousInternalIoApi\npublic open class Buffer(public val memory: Memory) {\n    private val bufferState: BufferSharedState = BufferSharedState(memory.size32)\n\n    /**\n     * Current read position. It is always non-negative and will never run ahead of the [writePosition].\n     * It is usually greater or equal to [startGap] reservation.\n     * This position is affected by [discard], [rewind], [resetForRead], [resetForWrite], [reserveStartGap]\n     * and [reserveEndGap].\n     */\n    public var readPosition: Int\n        get() = bufferState.readPosition\n        private set(value) {\n            bufferState.readPosition = value\n        }\n\n    /**\n     * Current write position. It is always non-negative and will never run ahead of the [limit].\n     * It is always greater or equal to the [readPosition].\n     * * This position is affected by [resetForRead], [resetForWrite], [reserveStartGap]\n     * and [reserveEndGap].\n     */\n    public var writePosition: Int\n        get() = bufferState.writePosition\n        private set(value) {\n            bufferState.writePosition = value\n        }\n\n    /**\n     * Start gap is a reserved space in the beginning. The reserved space is usually used to write a packet length\n     * in the case when it's not known before the packet constructed.\n     */\n    public var startGap: Int\n        get() = bufferState.startGap\n        private set(value) {\n            bufferState.startGap = value\n        }\n\n    /**\n     * Write position limit. No bytes could be written ahead of this limit. When the limit is less than the [capacity]\n     * then this means that there are reserved bytes in the end ([endGap]). Such a reserved space in the end could be used\n     * to write size, hash and so on. Also it is useful when several buffers are connected into a chain and some\n     * primitive value (e.g. `kotlin.Int`) is separated into two chunks so bytes from the second chain could be copied\n     * to the reserved space of the first chunk and then the whole value could be read at once.\n     */\n    public var limit: Int\n        get() = bufferState.limit\n        private set(value) {\n            bufferState.limit = value\n        }\n\n    /**\n     * Number of bytes reserved in the end.\n     */\n    public inline val endGap: Int get() = capacity - limit\n\n    /**\n     * Buffer's capacity (including reserved [startGap] and [endGap]. Value for released buffer is unspecified.\n     */\n    public val capacity: Int = memory.size32\n\n    /**\n     * Number of bytes available for reading.\n     */\n    public inline val readRemaining: Int get() = writePosition - readPosition\n\n    /**\n     * Size of the free space available for writing in bytes.\n     */\n    public inline val writeRemaining: Int get() = limit - writePosition\n\n    /**\n     * User data: could be a session, connection or anything useful\n     */\n    @Deprecated(\"Will be removed. Inherit Buffer and add required fields instead.\")\n    @ExperimentalIoApi\n    public var attachment: Any?\n        get() = bufferState.attachment\n        set(value) {\n            bufferState.attachment = value\n        }\n\n    /**\n     * Discard [count] readable bytes.\n     *\n     * @throws EOFException if [count] is bigger than available bytes.\n     */\n    public fun discardExact(count: Int = readRemaining) {\n        if (count == 0) return\n\n        val newReadPosition = readPosition + count\n        if (count < 0 || newReadPosition > writePosition) {\n            discardFailed(count, readRemaining)\n        }\n        readPosition = newReadPosition\n    }\n\n    @Deprecated(\"Use discardExact instead.\", level = DeprecationLevel.ERROR)\n    public fun discard(count: Int): Int {\n        val size = minOf(count, readRemaining)\n        discardExact(size)\n        return size\n    }\n\n    @Deprecated(\"Use discardExact instead.\", level = DeprecationLevel.ERROR)\n    public final fun discard(count: Long): Long {\n        val size = minOf(count, readRemaining.toLong()).toInt()\n        discardExact(size)\n        return size.toLong()\n    }\n\n    @DangerousInternalIoApi\n    public fun commitWritten(count: Int) {\n        val newWritePosition = writePosition + count\n        if (count < 0 || newWritePosition > limit) {\n            commitWrittenFailed(count, writeRemaining)\n        }\n        writePosition = newWritePosition\n    }\n\n    /**\n     * @return `true` if there is free space\n     */\n    @PublishedApi\n    internal fun commitWrittenUntilIndex(position: Int): Boolean {\n        val limit = limit\n        if (position < writePosition) {\n            commitWrittenFailed(position - writePosition, writeRemaining)\n        }\n        if (position >= limit) {\n            if (position == limit) {\n                writePosition = position\n                return false\n            }\n            commitWrittenFailed(position - writePosition, writeRemaining)\n        }\n\n        writePosition = position\n        return true\n    }\n\n    internal fun discardUntilIndex(position: Int) {\n        if (position < 0 || position > writePosition) {\n            discardFailed(position - readPosition, readRemaining)\n        }\n\n        if (readPosition != position) {\n            readPosition = position\n        }\n    }\n\n    /**\n     * Rewind [readPosition] backward to make [count] bytes available for reading again.\n     * @throws IllegalArgumentException when [count] is too big and not enough bytes available before the [readPosition]\n     */\n    public fun rewind(count: Int = readPosition - startGap) {\n        val newReadPosition = readPosition - count\n        if (newReadPosition < startGap) {\n            rewindFailed(count, readPosition - startGap)\n        }\n        readPosition = newReadPosition\n    }\n\n    /**\n     * Reserve [startGap] bytes in the beginning.\n     * May move [readPosition] and [writePosition] if no bytes available for reading.\n     */\n    public fun reserveStartGap(startGap: Int) {\n        require(startGap >= 0) { \"startGap shouldn't be negative: $startGap\" }\n\n        if (readPosition >= startGap) {\n            this.startGap = startGap\n            return\n        }\n\n        if (readPosition == writePosition) {\n            if (startGap > limit) {\n                startGapReservationFailedDueToLimit(startGap)\n            }\n\n            this.writePosition = startGap\n            this.readPosition = startGap\n            this.startGap = startGap\n            return\n        }\n\n        startGapReservationFailed(startGap)\n    }\n\n    /**\n     * Reserve [endGap] bytes in the end.\n     * Could move [readPosition] and [writePosition] to reserve space but only when no bytes were written or\n     * all written bytes are marked as consumed (were read or discarded).\n     */\n    public fun reserveEndGap(endGap: Int) {\n        require(endGap >= 0) { \"endGap shouldn't be negative: $endGap\" }\n\n        val newLimit = capacity - endGap\n        if (newLimit >= writePosition) {\n            limit = newLimit\n            return\n        }\n\n        if (newLimit < 0) {\n            endGapReservationFailedDueToCapacity(endGap)\n        }\n        if (newLimit < startGap) {\n            endGapReservationFailedDueToStartGap(endGap)\n        }\n\n        if (readPosition == writePosition) {\n            limit = newLimit\n            readPosition = newLimit\n            writePosition = newLimit\n            return\n        }\n\n        endGapReservationFailedDueToContent(endGap)\n    }\n\n    /**\n     * Marks the whole buffer available for read and no for write\n     */\n    public fun resetForRead() {\n        startGap = 0\n        readPosition = 0\n\n        val capacity = capacity\n        writePosition = capacity\n    }\n\n    /**\n     * Marks all capacity writable except the start gap reserved before. The end gap reservation is discarded.\n     */\n    public fun resetForWrite() {\n        resetForWrite(capacity - startGap)\n    }\n\n    /**\n     * Marks up to [limit] bytes of the buffer available for write and no bytes for read.\n     * It does respect [startGap] already reserved. All extra bytes after the specified [limit]\n     * are considered as [endGap].\n     */\n    public fun resetForWrite(limit: Int) {\n        val startGap = startGap\n        readPosition = startGap\n        writePosition = startGap\n        this.limit = limit\n    }\n\n    /**\n     * Forget start/end gap reservations.\n     */\n    internal fun releaseGaps() {\n        releaseStartGap(0)\n        releaseEndGap()\n    }\n\n    internal fun releaseEndGap() {\n        limit = capacity\n    }\n\n    internal fun releaseStartGap(newReadPosition: Int) {\n        require(newReadPosition >= 0) { \"newReadPosition shouldn't be negative: $newReadPosition\" }\n        require(newReadPosition <= readPosition) {\n            \"newReadPosition shouldn't be ahead of the read position: $newReadPosition > $readPosition\"\n        }\n\n        readPosition = newReadPosition\n        if (startGap > newReadPosition) {\n            startGap = newReadPosition\n        }\n    }\n\n    protected open fun duplicateTo(copy: Buffer) {\n        copy.limit = limit\n        copy.startGap = startGap\n        copy.readPosition = readPosition\n        copy.writePosition = writePosition\n    }\n\n    /**\n     * Create a new [Buffer] instance pointing to the same memory and having the same positions.\n     */\n    public open fun duplicate(): Buffer = Buffer(memory).apply {\n        duplicateTo(this)\n    }\n\n    /**\n     * Peek the next unsigned byte or return `-1` if no more bytes available for reading. No bytes will be marked\n     * as consumed in any case.\n     * @return an unsigned byte or `-1` if not even a byte is available for reading.\n     * @see tryReadByte\n     * @see readByte\n     */\n    public fun tryPeekByte(): Int {\n        val readPosition = readPosition\n        if (readPosition == writePosition) return -1\n        return memory[readPosition].toInt() and 0xff\n    }\n\n    /**\n     * Read the next unsigned byte or return `-1` if no more bytes available for reading. The returned byte is marked\n     * as consumed.\n     * @return an unsigned byte or `-1` if not even a byte is available for reading.\n     * @see tryPeekByte\n     * @see readByte\n     */\n    public fun tryReadByte(): Int {\n        val readPosition = readPosition\n        if (readPosition == writePosition) return -1\n        this.readPosition = readPosition + 1\n        return memory[readPosition].toInt() and 0xff\n    }\n\n    /**\n     * Read the next byte or fail with [EOFException] if it's not available. The returned byte is marked\n     * as consumed.\n     * @throws EOFException when not even a byte is available for reading.\n     * @see tryPeekByte\n     * @see tryReadByte\n     */\n    public fun readByte(): Byte {\n        val readPosition = readPosition\n        if (readPosition == writePosition) {\n            throw EOFException(\"No readable bytes available.\")\n        }\n        this.readPosition = readPosition + 1\n        return memory[readPosition]\n    }\n\n    /**\n     * Write a byte [value] at [writePosition] (incremented when written successfully).\n     * @throws InsufficientSpaceException when no free space in the buffer.\n     */\n    public fun writeByte(value: Byte) {\n        val writePosition = writePosition\n        if (writePosition == limit) {\n            throw InsufficientSpaceException(\"No free space in the buffer to write a byte\")\n        }\n        memory[writePosition] = value\n        this.writePosition = writePosition + 1\n    }\n\n    /**\n     * Clear buffer's state: read/write positions, gaps and so on. Byte content is not cleaned-up.\n     */\n    public open fun reset() {\n        releaseGaps()\n        resetForWrite()\n    }\n\n    override fun toString(): String {\n        return \"Buffer($readRemaining used, $writeRemaining free, ${startGap + endGap} reserved of $capacity)\"\n    }\n\n    public companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [io.ktor.utils.io.core.internal.ChunkBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        public const val ReservedSize: Int = 8\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        @Suppress(\"DEPRECATION\")\n        public val Empty: Buffer get() = IoBuffer.Empty\n    }\n}\n\n/**\n * @return `true` if there are available bytes to be read\n */\npublic inline fun Buffer.canRead(): Boolean = writePosition > readPosition\n\n/**\n * @return `true` if there is free room to for write\n */\npublic inline fun Buffer.canWrite(): Boolean = limit > writePosition\n\n/**\n * Apply [block] of code with buffer's memory providing read range indices. The returned value of [block] lambda should\n * return number of bytes to be marked as consumed.\n * No read/write functions on this buffer should be called inside of [block] otherwise an undefined behaviour may occur\n * including data damage.\n */\n@DangerousInternalIoApi\npublic inline fun Buffer.read(block: (memory: Memory, start: Int, endExclusive: Int) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val rc = block(memory, readPosition, writePosition)\n    discardExact(rc)\n    return rc\n}\n\n/**\n * Apply [block] of code with buffer's memory providing write range indices. The returned value of [block] lambda should\n * return number of bytes were written.\n * o read/write functions on this buffer should be called inside of [block] otherwise an undefined behaviour may occur\n * including data damage.\n */\n@DangerousInternalIoApi\npublic inline fun Buffer.write(block: (memory: Memory, start: Int, endExclusive: Int) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val rc = block(memory, writePosition, limit)\n    commitWritten(rc)\n    return rc\n}\n\ninternal fun discardFailed(count: Int, readRemaining: Int): Nothing {\n    throw EOFException(\"Unable to discard $count bytes: only $readRemaining available for reading\")\n}\n\ninternal fun commitWrittenFailed(count: Int, writeRemaining: Int): Nothing {\n    throw EOFException(\"Unable to discard $count bytes: only $writeRemaining available for writing\")\n}\n\ninternal fun rewindFailed(count: Int, rewindRemaining: Int): Nothing {\n    throw IllegalArgumentException(\"Unable to rewind $count bytes: only $rewindRemaining could be rewinded\")\n}\n\ninternal fun Buffer.startGapReservationFailedDueToLimit(startGap: Int): Nothing {\n    if (startGap > capacity) {\n        throw IllegalArgumentException(\"Start gap $startGap is bigger than the capacity $capacity\")\n    }\n\n    throw IllegalStateException(\n        \"Unable to reserve $startGap start gap: there are already $endGap bytes reserved in the end\"\n    )\n}\n\ninternal fun Buffer.startGapReservationFailed(startGap: Int): Nothing {\n    throw IllegalStateException(\n        \"Unable to reserve $startGap start gap: \" +\n            \"there are already $readRemaining content bytes starting at offset $readPosition\"\n    )\n}\n\ninternal fun Buffer.endGapReservationFailedDueToCapacity(endGap: Int) {\n    throw IllegalArgumentException(\"End gap $endGap is too big: capacity is $capacity\")\n}\n\ninternal fun Buffer.endGapReservationFailedDueToStartGap(endGap: Int) {\n    throw IllegalArgumentException(\n        \"End gap $endGap is too big: there are already $startGap bytes reserved in the beginning\"\n    )\n}\n\ninternal fun Buffer.endGapReservationFailedDueToContent(endGap: Int) {\n    throw IllegalArgumentException(\n        \"Unable to reserve end gap $endGap:\" +\n            \" there are already $readRemaining content bytes at offset $readPosition\"\n    )\n}\n\ninternal fun Buffer.restoreStartGap(size: Int) {\n    releaseStartGap(readPosition - size)\n}\n\n@ExperimentalIoApi\npublic class InsufficientSpaceException(message: String = \"Not enough free space\") : Exception(message) {\n    public constructor(\n        size: Int,\n        availableSpace: Int\n    ) : this(\"Not enough free space to write $size bytes, available $availableSpace bytes.\")\n\n    public constructor(\n        name: String,\n        size: Int,\n        availableSpace: Int\n    ) : this(\"Not enough free space to write $name of $size bytes, available $availableSpace bytes.\")\n\n    public constructor(\n        size: Long,\n        availableSpace: Long\n    ) : this(\"Not enough free space to write $size bytes, available $availableSpace bytes.\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.require\n\n/**\n * Represents a linear range of bytes.\n */\npublic actual class Memory @DangerousInternalIoApi constructor(public val view: DataView) {\n    /**\n     * Size of memory range in bytes.\n     */\n    public actual inline val size: Long get() = view.byteLength.toLong()\n\n    /**\n     * Size of memory range in bytes represented as signed 32bit integer\n     * @throws IllegalStateException when size doesn't fit into a signed 32bit integer\n     */\n    public actual inline val size32: Int get() = view.byteLength\n\n    /**\n     * Returns byte at [index] position.\n     */\n    public actual inline fun loadAt(index: Int): Byte {\n        return view.getInt8(index)\n    }\n\n    /**\n     * Returns byte at [index] position.\n     */\n    public actual inline fun loadAt(index: Long): Byte {\n        return view.getInt8(index.toIntOrFail(\"index\"))\n    }\n\n    /**\n     * Write [value] at the specified [index].\n     */\n    public actual inline fun storeAt(index: Int, value: Byte) {\n        view.setInt8(index, value)\n    }\n\n    /**\n     * Write [value] at the specified [index]\n     */\n    public actual inline fun storeAt(index: Long, value: Byte) {\n        view.setInt8(index.toIntOrFail(\"index\"), value)\n    }\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    public actual fun slice(offset: Int, length: Int): Memory {\n        require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        if (offset + length > size) {\n            throw IndexOutOfBoundsException(\"offset + length > size: $offset + $length > $size\")\n        }\n\n        return Memory(\n            DataView(\n                view.buffer,\n                view.byteOffset + offset,\n                length\n            )\n        )\n    }\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    public actual fun slice(offset: Long, length: Long): Memory {\n        return slice(offset.toIntOrFail(\"offset\"), length.toIntOrFail(\"length\"))\n    }\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    public actual fun copyTo(\n        destination: Memory,\n        offset: Int,\n        length: Int,\n        destinationOffset: Int\n    ) {\n        val src = Int8Array(view.buffer, view.byteOffset + offset, length)\n        val dst = Int8Array(destination.view.buffer, destination.view.byteOffset + destinationOffset, length)\n\n        dst.set(src)\n    }\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    public actual fun copyTo(\n        destination: Memory,\n        offset: Long,\n        length: Long,\n        destinationOffset: Long\n    ) {\n        copyTo(\n            destination,\n            offset.toIntOrFail(\"offset\"),\n            length.toIntOrFail(\"length\"),\n            destinationOffset.toIntOrFail(\"destinationOffset\")\n        )\n    }\n\n    public actual companion object {\n        /**\n         * Represents an empty memory region\n         */\n        public actual val Empty: Memory = Memory(DataView(ArrayBuffer(0)))\n    }\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic actual fun Memory.copyTo(\n    destination: ByteArray,\n    offset: Int,\n    length: Int,\n    destinationOffset: Int\n) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to: Int8Array = destination.asDynamic()\n\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, destinationOffset)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic actual fun Memory.copyTo(\n    destination: ByteArray,\n    offset: Long,\n    length: Int,\n    destinationOffset: Int\n) {\n    copyTo(destination, offset.toIntOrFail(\"offset\"), length, destinationOffset)\n}\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\npublic actual fun Memory.fill(offset: Int, count: Int, value: Byte) {\n    for (index in offset until offset + count) {\n        this[index] = value\n    }\n}\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\npublic actual fun Memory.fill(offset: Long, count: Long, value: Byte) {\n    fill(offset.toIntOrFail(\"offset\"), count.toIntOrFail(\"count\"), value)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun Memory.copyTo(destination: ArrayBuffer, offset: Int, length: Int, destinationOffset: Int) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to = Int8Array(destination, destinationOffset, length)\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun Memory.copyTo(destination: ArrayBufferView, offset: Int, length: Int, destinationOffset: Int) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to = Int8Array(destination.buffer, destinationOffset + destination.byteOffset, length)\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun ArrayBuffer.copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int) {\n    val from = Int8Array(this, offset, length)\n    val to = Int8Array(destination.view.buffer, destination.view.byteOffset + destinationOffset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun ArrayBufferView.copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int) {\n    buffer.copyTo(destination, offset + byteOffset, length, destinationOffset)\n}\n\ninternal val Memory.Int8ArrayView: Int8Array get() = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous writing of sequences of bytes.\n * This is a **single-writer channel**.\n *\n * Operations on this channel cannot be invoked concurrently, unless explicitly specified otherwise\n * in description. Exceptions are [close] and [flush].\n */\npublic expect interface ByteWriteChannel {\n    /**\n     * Returns number of bytes that can be written without suspension. Write operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for write.\n     */\n    public val availableForWrite: Int\n\n    /**\n     * Returns `true` is channel has been closed and attempting to write to the channel will cause an exception.\n     */\n    public val isClosedForWrite: Boolean\n\n    /**\n     * Returns `true` if channel flushes automatically all pending bytes after every write function call.\n     * If `false` then flush only happens at manual [flush] invocation or when the buffer is full.\n     */\n    public val autoFlush: Boolean\n\n    /**\n     * Byte order that is used for multi-byte write operations\n     * (such as [writeShort], [writeInt], [writeLong], [writeFloat], and [writeDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var writeByteOrder: ByteOrder\n\n    /**\n     * Number of bytes written to the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of write operation.\n     */\n    public val totalBytesWritten: Long\n\n    /**\n     * An closure cause exception or `null` if closed successfully or not yet closed\n     */\n    public val closedCause: Throwable?\n\n    /**\n     * Writes as much as possible and only suspends if buffer is full\n     */\n    public suspend fun writeAvailable(src: ByteArray, offset: Int, length: Int): Int\n\n    public suspend fun writeAvailable(src: IoBuffer): Int\n\n    /**\n     * Writes all [src] bytes and suspends until all bytes written. Causes flush if buffer filled up or when [autoFlush]\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeFully(src: ByteArray, offset: Int, length: Int)\n\n    public suspend fun writeFully(src: IoBuffer)\n\n    public suspend fun writeFully(src: Buffer)\n\n    public suspend fun writeFully(memory: Memory, startIndex: Int, endIndex: Int)\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use write { } instead.\")\n    public suspend fun writeSuspendSession(visitor: suspend WriterSuspendSession.() -> Unit)\n\n    /**\n     * Writes a [packet] fully or fails if channel get closed before the whole packet has been written\n     */\n    public suspend fun writePacket(packet: ByteReadPacket)\n\n    /**\n     * Writes long number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeLong(l: Long)\n\n    /**\n     * Writes int number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeInt(i: Int)\n\n    /**\n     * Writes short number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeShort(s: Short)\n\n    /**\n     * Writes byte and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeByte(b: Byte)\n\n    /**\n     * Writes double number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeDouble(d: Double)\n\n    /**\n     * Writes float number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeFloat(f: Float)\n\n    /**\n     * Invokes [block] when at least 1 byte is available for write.\n     */\n    @ExperimentalIoApi\n    public suspend fun awaitFreeSpace()\n\n    /**\n     * Closes this channel with an optional exceptional [cause].\n     * It flushes all pending write bytes (via [flush]).\n     * This is an idempotent operation -- repeated invocations of this function have no effect and return `false`.\n     *\n     * A channel that was closed without a [cause], is considered to be _closed normally_.\n     * A channel that was closed with non-null [cause] is called a _failed channel_. Attempts to read or\n     * write on a failed channel throw this cause exception.\n     *\n     * After invocation of this operation [isClosedForWrite] starts returning `true` and\n     * all subsequent write operations throw [ClosedWriteChannelException] or the specified [cause].\n     * However, [isClosedForRead][ByteReadChannel.isClosedForRead] on the side of [ByteReadChannel]\n     * starts returning `true` only after all written bytes have been read.\n     *\n     * Please note that if the channel has been closed with cause and it has been provided by [reader] or [writer]\n     * coroutine then the corresponding coroutine will be cancelled with [cause]. If no [cause] provided then no\n     * cancellation will be propagated.\n     */\n    public fun close(cause: Throwable?): Boolean\n\n    /**\n     * Flushes all pending write bytes making them available for read.\n     *\n     * This function is thread-safe and can be invoked in any thread at any time.\n     * It does nothing when invoked on a closed channel.\n     */\n    public fun flush()\n}\n\npublic suspend fun ByteWriteChannel.writeAvailable(src: ByteArray): Int = writeAvailable(src, 0, src.size)\npublic suspend fun ByteWriteChannel.writeFully(src: ByteArray): Unit = writeFully(src, 0, src.size)\n\npublic suspend fun ByteWriteChannel.writeShort(s: Int) {\n    return writeShort((s and 0xffff).toShort())\n}\n\npublic suspend fun ByteWriteChannel.writeShort(s: Int, byteOrder: ByteOrder) {\n    return writeShort((s and 0xffff).toShort(), byteOrder)\n}\n\npublic suspend fun ByteWriteChannel.writeByte(b: Int) {\n    return writeByte((b and 0xff).toByte())\n}\n\npublic suspend fun ByteWriteChannel.writeInt(i: Long) {\n    return writeInt(i.toInt())\n}\n\npublic suspend fun ByteWriteChannel.writeInt(i: Long, byteOrder: ByteOrder) {\n    return writeInt(i.toInt(), byteOrder)\n}\n\n/**\n * Closes this channel with no failure (successfully)\n */\npublic fun ByteWriteChannel.close(): Boolean = close(null)\n\npublic suspend fun ByteWriteChannel.writeStringUtf8(s: CharSequence) {\n    val packet = buildPacket {\n        writeStringUtf8(s)\n    }\n\n    return writePacket(packet)\n}\n\n/*\nTODO\npublic suspend fun ByteWriteChannel.writeStringUtf8(s: CharBuffer) {\n    val packet = buildPacket {\n        writeStringUtf8(s)\n    }\n\n    return writePacket(packet)\n}*/\n\npublic suspend fun ByteWriteChannel.writeStringUtf8(s: String) {\n    val packet = buildPacket {\n        writeText(s)\n    }\n\n    return writePacket(packet)\n}\n\npublic suspend fun ByteWriteChannel.writeBoolean(b: Boolean) {\n    return writeByte(if (b) 1 else 0)\n}\n\n/**\n * Writes UTF16 character\n */\npublic suspend fun ByteWriteChannel.writeChar(ch: Char) {\n    return writeShort(ch.toInt())\n}\n\npublic suspend inline fun ByteWriteChannel.writePacket(headerSizeHint: Int = 0, builder: BytePacketBuilder.() -> Unit) {\n    return writePacket(buildPacket(headerSizeHint, builder))\n}\n\npublic suspend fun ByteWriteChannel.writePacketSuspend(builder: suspend BytePacketBuilder.() -> Unit) {\n    return writePacket(buildPacket { builder() })\n}\n\n/**\n * Indicates attempt to write on [isClosedForWrite][ByteWriteChannel.isClosedForWrite] channel\n * that was closed without a cause. A _failed_ channel rethrows the original [close][ByteWriteChannel.close] cause\n * exception on send attempts.\n */\npublic class ClosedWriteChannelException(message: String?) : CancellationException(message)\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.contracts.*\n\npublic expect val PACKET_MAX_COPY_SIZE: Int\n\n/**\n * Build a byte packet in [block] lambda. Creates a temporary builder and releases it in case of failure\n */\npublic inline fun buildPacket(headerSizeHint: Int = 0, block: BytePacketBuilder.() -> Unit): ByteReadPacket {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val builder = BytePacketBuilder(headerSizeHint)\n    try {\n        block(builder)\n        return builder.build()\n    } catch (t: Throwable) {\n        builder.release()\n        throw t\n    }\n}\n\npublic expect fun BytePacketBuilder(headerSizeHint: Int = 0): BytePacketBuilder\n\n/**\n * Discard all written bytes and prepare to build another packet.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun BytePacketBuilder.reset() {\n    release()\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\npublic abstract class BytePacketBuilderPlatformBase\ninternal constructor(pool: ObjectPool<ChunkBuffer>) : BytePacketBuilderBase(pool)\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\npublic abstract class BytePacketBuilderBase\ninternal constructor(pool: ObjectPool<ChunkBuffer>) : AbstractOutput(pool)\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\npublic suspend inline fun ByteReadChannel.readShort(byteOrder: ByteOrder): Short {\n    return readShort().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readInt(byteOrder: ByteOrder): Int {\n    return readInt().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readLong(byteOrder: ByteOrder): Long {\n    return readLong().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readFloat(byteOrder: ByteOrder): Float {\n    return readFloat().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readDouble(byteOrder: ByteOrder): Double {\n    return readDouble().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readShortLittleEndian(): Short {\n    return toLittleEndian(readShort()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readIntLittleEndian(): Int {\n    return toLittleEndian(readInt()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readLongLittleEndian(): Long {\n    return toLittleEndian(readLong()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readFloatLittleEndian(): Float {\n    return toLittleEndian(readFloat()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readDoubleLittleEndian(): Double {\n    return toLittleEndian(readDouble()) { reverseByteOrder() }\n}\n\npublic suspend fun ByteWriteChannel.writeShort(value: Short, byteOrder: ByteOrder) {\n    writeShort(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeInt(value: Int, byteOrder: ByteOrder) {\n    writeInt(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeLong(value: Long, byteOrder: ByteOrder) {\n    writeLong(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeFloat(value: Float, byteOrder: ByteOrder) {\n    writeFloat(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeDouble(value: Double, byteOrder: ByteOrder) {\n    writeDouble(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeShortLittleEndian(value: Short) {\n    writeShort(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeIntLittleEndian(value: Int) {\n    writeInt(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeLongLittleEndian(value: Long) {\n    writeLong(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeFloatLittleEndian(value: Float) {\n    writeFloat(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeDoubleLittleEndian(value: Double) {\n    writeDouble(toLittleEndian(value) { reverseByteOrder() })\n}\n\n@PublishedApi\n@Suppress(\"DEPRECATION_ERROR\")\ninternal inline fun <T> ByteReadChannel.toLittleEndian(value: T, reverseBlock: T.() -> T): T {\n    return when (readByteOrder) {\n        ByteOrder.LITTLE_ENDIAN -> value\n        else -> value.reverseBlock()\n    }\n}\n\n@Suppress(\"DEPRECATION_ERROR\")\nprivate inline fun <T> ByteWriteChannel.toLittleEndian(value: T, reverseBlock: T.() -> T): T {\n    return when (writeByteOrder) {\n        ByteOrder.LITTLE_ENDIAN -> value\n        else -> value.reverseBlock()\n    }\n}\n\n@PublishedApi\ninternal inline fun <T> T.reverseIfNeeded(byteOrder: ByteOrder, reverseBlock: T.() -> T): T {\n    return when (byteOrder) {\n        ByteOrder.BIG_ENDIAN -> this\n        else -> reverseBlock()\n    }\n}\n","package io.ktor.utils.io\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * A coroutine job that is reading from a byte channel\n */\npublic interface ReaderJob : Job {\n    /**\n     * A reference to the channel that this coroutine is reading from\n     */\n    public val channel: ByteWriteChannel\n}\n\n/**\n * A coroutine job that is writing to a byte channel\n */\npublic interface WriterJob : Job {\n    /**\n     * A reference to the channel that this coroutine is writing to\n     */\n    public val channel: ByteReadChannel\n}\n\npublic interface ReaderScope : CoroutineScope {\n    public val channel: ByteReadChannel\n}\n\npublic interface WriterScope : CoroutineScope {\n    public val channel: ByteWriteChannel\n}\n\npublic fun CoroutineScope.reader(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    channel: ByteChannel,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob = launchChannel(coroutineContext, channel, attachJob = false, block = block)\n\npublic fun CoroutineScope.reader(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    autoFlush: Boolean = false,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob = launchChannel(coroutineContext, ByteChannel(autoFlush), attachJob = true, block = block)\n\n@Deprecated(\"Use scope.reader instead\")\npublic fun reader(\n    coroutineContext: CoroutineContext,\n    channel: ByteChannel,\n    parent: Job? = null,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob {\n    val newContext = if (parent != null) GlobalScope.newCoroutineContext(coroutineContext + parent)\n    else GlobalScope.newCoroutineContext(coroutineContext)\n\n    return CoroutineScope(newContext).reader(EmptyCoroutineContext, channel, block)\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use scope.reader instead\")\npublic fun reader(\n    coroutineContext: CoroutineContext,\n    autoFlush: Boolean = false,\n    parent: Job? = null,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob {\n    val channel = ByteChannel(autoFlush)\n    return reader(coroutineContext, channel, parent, block).also {\n        channel.attachJob(it)\n    }\n}\n\npublic fun CoroutineScope.writer(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    channel: ByteChannel,\n    block: suspend WriterScope.() -> Unit\n): WriterJob = launchChannel(coroutineContext, channel, attachJob = false, block = block)\n\npublic fun CoroutineScope.writer(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    autoFlush: Boolean = false,\n    block: suspend WriterScope.() -> Unit\n): WriterJob = launchChannel(coroutineContext, ByteChannel(autoFlush), attachJob = true, block = block)\n\n@Deprecated(\"Use scope.writer instead\")\npublic fun writer(\n    coroutineContext: CoroutineContext,\n    channel: ByteChannel,\n    parent: Job? = null,\n    block: suspend WriterScope.() -> Unit\n): WriterJob {\n    val newContext = if (parent != null) GlobalScope.newCoroutineContext(coroutineContext + parent)\n    else GlobalScope.newCoroutineContext(coroutineContext)\n\n    return CoroutineScope(newContext).writer(EmptyCoroutineContext, channel, block)\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use scope.writer instead\")\npublic fun writer(\n    coroutineContext: CoroutineContext,\n    autoFlush: Boolean = false,\n    parent: Job? = null,\n    block: suspend WriterScope.() -> Unit\n): WriterJob {\n    val channel = ByteChannel(autoFlush)\n    return writer(coroutineContext, channel, parent, block).also {\n        channel.attachJob(it)\n    }\n}\n\n/**\n * @param S not exactly safe (unchecked cast is used) so should be [ReaderScope] or [WriterScope]\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun <S : CoroutineScope> CoroutineScope.launchChannel(\n    context: CoroutineContext,\n    channel: ByteChannel,\n    attachJob: Boolean,\n    block: suspend S.() -> Unit\n): ChannelJob {\n    val dispatcher = coroutineContext[CoroutineDispatcher]\n    val job = launch(context) {\n        if (attachJob) {\n            channel.attachJob(coroutineContext[Job]!!)\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val scope = ChannelScope(this, channel) as S\n\n        try {\n            block(scope)\n        } catch (cause: Throwable) {\n            if (dispatcher != Dispatchers.Unconfined && dispatcher != null) {\n                throw cause\n            }\n\n            channel.cancel(cause)\n        }\n    }\n\n    job.invokeOnCompletion { cause ->\n        channel.close(cause)\n    }\n\n    return ChannelJob(job, channel)\n}\n\nprivate class ChannelScope(\n    delegate: CoroutineScope,\n    override val channel: ByteChannel\n) : ReaderScope, WriterScope, CoroutineScope by delegate\n\nprivate class ChannelJob(\n    private val delegate: Job,\n    override val channel: ByteChannel\n) : ReaderJob, WriterJob, Job by delegate {\n    override fun toString(): String = \"ChannelJob[$delegate]\"\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * Await until at least [desiredSize] is available for read or EOF and invoke [block] function. The block function\n * should never capture a provided [Memory] instance outside otherwise an undefined behaviour may occur including\n * accidental crash or data corruption. Block function should return number of bytes consumed or 0.\n *\n * Specifying [desiredSize] larger than the channel's capacity leads to block function invocation earlier\n * when the channel is full. So specifying too big [desiredSize] is identical to specifying [desiredSize] equal to\n * the channel's capacity. The other case when a provided memory range could be less than [desiredSize] is that\n * all the requested bytes couldn't be represented as a single memory range due to internal implementation reasons.\n *\n * @return number of bytes consumed, possibly 0\n */\n@ExperimentalIoApi\npublic suspend inline fun ByteReadChannel.read(\n    desiredSize: Int = 1,\n    block: (source: Memory, start: Long, endExclusive: Long) -> Int\n): Int {\n    val buffer = requestBuffer(desiredSize) ?: Buffer.Empty\n\n    try {\n        val bytesRead = block(buffer.memory, buffer.readPosition.toLong(), buffer.writePosition.toLong())\n        completeReadingFromBuffer(buffer, bytesRead)\n        return bytesRead\n    } catch (cause: Throwable) {\n        completeReadingFromBuffer(buffer, 0)\n        throw cause\n    }\n\n    // we don't use finally here because of KT-37279\n}\n\n@Deprecated(\"Use read { } instead.\")\npublic interface ReadSession {\n    /**\n     * Number of bytes available for read. However it doesn't necessarily means that all available bytes could be\n     * requested at once\n     */\n    public val availableForRead: Int\n\n    /**\n     * Discard at most [n] available bytes or 0 if no bytes available yet\n     * @return number of bytes actually discarded, could be 0\n     */\n    public fun discard(n: Int): Int\n\n    /**\n     * Request buffer range [atLeast] bytes length\n     *\n     * There are the following reasons for this function to return `null`:\n     * - not enough bytes available yet (should be at least `atLeast` bytes available)\n     * - due to buffer fragmentation it is impossible to represent the requested range as a single buffer range\n     * - end of stream encountered and all bytes were consumed\n     *\n     * @return buffer for the requested range or `null` if it is impossible to provide such a buffer view\n     * @throws Throwable if the channel has been closed with an exception or cancelled\n     */\n    @Suppress(\"DEPRECATION\")\n    public fun request(atLeast: Int = 1): IoBuffer?\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use read { } instead.\")\npublic interface SuspendableReadSession : ReadSession {\n    /**\n     * Suspend until [atLeast] bytes become available or end of stream encountered (possibly due to exceptional close)\n     *\n     * @return true if there are [atLeast] bytes available or false if end of stream encountered (there still could be\n     * bytes available but less than [atLeast])\n     * @throws Throwable if the channel has been closed with an exception or cancelled\n     * @throws IllegalArgumentException if [atLeast] is negative to too big (usually bigger that 4088)\n     */\n    public suspend fun await(atLeast: Int = 1): Boolean\n}\n\n@PublishedApi\ninternal suspend fun ByteReadChannel.requestBuffer(desiredSize: Int): Buffer? {\n    @Suppress(\"DEPRECATION\")\n    val readSession: SuspendableReadSession? = when {\n        this is SuspendableReadSession -> this\n        this is HasReadSession -> startReadSession()\n        else -> null\n    }\n\n    if (readSession != null) {\n        val buffer = readSession.request(desiredSize.coerceAtMost(Buffer.ReservedSize))\n        if (buffer != null) {\n            return buffer\n        }\n\n        return readSession.requestBufferSuspend(desiredSize)\n    }\n\n    return requestBufferFallback(desiredSize)\n}\n\n@PublishedApi\ninternal suspend fun ByteReadChannel.completeReadingFromBuffer(buffer: Buffer?, bytesRead: Int) {\n    check(bytesRead >= 0) { \"bytesRead shouldn't be negative: $bytesRead\" }\n    @Suppress(\"DEPRECATION\")\n    val readSession: SuspendableReadSession? = readSessionFor()\n\n    if (readSession != null) {\n        readSession.discard(bytesRead)\n        if (this is HasReadSession) {\n            endReadSession()\n        }\n        return\n    }\n\n    if (buffer is ChunkBuffer && buffer !== ChunkBuffer.Empty) {\n        buffer.release(ChunkBuffer.Pool)\n        discard(bytesRead.toLong())\n    }\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun SuspendableReadSession.requestBufferSuspend(desiredSize: Int): Buffer? {\n    await(desiredSize)\n    return request(1)\n}\n\nprivate suspend fun ByteReadChannel.requestBufferFallback(desiredSize: Int): ChunkBuffer {\n    val chunk = ChunkBuffer.Pool.borrow()\n    val copied =\n        peekTo(chunk.memory, chunk.writePosition.toLong(), 0L, desiredSize.toLong(), chunk.writeRemaining.toLong())\n    chunk.commitWritten(copied.toInt())\n\n    return chunk\n}\n\ninternal interface HasReadSession {\n    @Suppress(\"DEPRECATION\")\n    public fun startReadSession(): SuspendableReadSession\n\n    public fun endReadSession()\n}\n\n@Suppress(\"DEPRECATION\", \"NOTHING_TO_INLINE\")\nprivate inline fun ByteReadChannel.readSessionFor(): SuspendableReadSession? = when {\n    this is HasReadSession -> startReadSession()\n    else -> null\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.ChunkBuffer\n\n/**\n * Await for [desiredSpace] will be available for write and invoke [block] function providing [Memory] instance and\n * the corresponding range suitable for wiring in the memory. The block function should return number of bytes were\n * written, possibly 0.\n *\n * Similar to [ByteReadChannel.read], this function may invoke block function with lesser memory range when the\n * specified [desiredSpace] is bigger that the buffer's capacity\n * or when it is impossible to represent all [desiredSpace] bytes as a single memory range\n * due to internal implementation reasons.\n */\n@ExperimentalIoApi\npublic suspend inline fun ByteWriteChannel.write(\n    desiredSpace: Int = 1,\n    block: (freeSpace: Memory, startOffset: Long, endExclusive: Long) -> Int\n): Int {\n    val buffer = requestWriteBuffer(desiredSpace) ?: Buffer.Empty\n    var bytesWritten = 0\n    try {\n        bytesWritten = block(buffer.memory, buffer.writePosition.toLong(), buffer.limit.toLong())\n        buffer.commitWritten(bytesWritten)\n        return bytesWritten\n    } finally {\n        completeWriting(buffer, bytesWritten)\n    }\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use writeMemory instead.\")\npublic interface WriterSession {\n    public fun request(min: Int): IoBuffer?\n    public fun written(n: Int)\n    public fun flush()\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use writeMemory instead.\")\npublic interface WriterSuspendSession : WriterSession {\n    public suspend fun tryAwait(n: Int)\n}\n\n@Suppress(\"DEPRECATION\")\ninternal interface HasWriteSession {\n    public fun beginWriteSession(): WriterSuspendSession?\n    public fun endWriteSession(written: Int)\n}\n\n@PublishedApi\ninternal suspend fun ByteWriteChannel.requestWriteBuffer(desiredSpace: Int): Buffer? {\n    val session = writeSessionFor()\n    if (session != null) {\n        val buffer = session.request(desiredSpace)\n        if (buffer != null) {\n            return buffer\n        }\n\n        return writeBufferSuspend(session, desiredSpace)\n    }\n\n    return writeBufferFallback()\n}\n\n@PublishedApi\ninternal suspend fun ByteWriteChannel.completeWriting(buffer: Buffer, written: Int) {\n    if (this is HasWriteSession) {\n        endWriteSession(written)\n        return\n    }\n\n    return completeWritingFallback(buffer)\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun ByteWriteChannel.completeWritingFallback(buffer: Buffer) {\n    if (buffer is IoBuffer) {\n        writeFully(buffer)\n        buffer.release(IoBuffer.Pool)\n        return\n    }\n\n    throw UnsupportedOperationException(\"Only IoBuffer instance is supported.\")\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun writeBufferSuspend(session: WriterSuspendSession, desiredSpace: Int): Buffer? {\n    session.tryAwait(desiredSpace)\n    return session.request(desiredSpace) ?: session.request(1)\n}\n\nprivate fun writeBufferFallback(): Buffer? {\n    return ChunkBuffer.Pool.borrow().also { it.resetForWrite(); it.reserveEndGap(Buffer.ReservedSize) }\n}\n\n@Suppress(\"DEPRECATION\", \"NOTHING_TO_INLINE\")\nprivate inline fun ByteWriteChannel.writeSessionFor(): WriterSuspendSession? = when {\n    this is HasWriteSession -> beginWriteSession()\n    else -> null\n}\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.ExperimentalIoApi\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Short.reverseByteOrder(): Short\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Int.reverseByteOrder(): Int\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Long.reverseByteOrder(): Long\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Float.reverseByteOrder(): Float\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Double.reverseByteOrder(): Double\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\npublic fun UShort.reverseByteOrder(): UShort = toShort().reverseByteOrder().toUShort()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\npublic fun UInt.reverseByteOrder(): UInt = toInt().reverseByteOrder().toUInt()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\npublic fun ULong.reverseByteOrder(): ULong = toLong().reverseByteOrder().toULong()\n\n@ExperimentalIoApi\npublic inline val Short.highByte: Byte get() = (toInt() ushr 8).toByte()\n\n@ExperimentalIoApi\npublic inline val Short.lowByte: Byte get() = (toInt() and 0xff).toByte()\n\n@ExperimentalIoApi\npublic inline val Int.highShort: Short get() = (this ushr 16).toShort()\n\n@ExperimentalIoApi\npublic inline val Int.lowShort: Short get() = (this and 0xffff).toShort()\n\n@ExperimentalIoApi\npublic inline val Long.highInt: Int get() = (this ushr 32).toInt()\n\n@ExperimentalIoApi\npublic inline val Long.lowInt: Int get() = (this and 0xffffffffL).toInt()\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.*\n\n/**\n * Represents a linear range of bytes.\n * All operations are guarded by range-checks by default however at some platforms they could be disabled\n * in release builds.\n *\n * Instance of this class has no additional state except the bytes themselves.\n */\n@ExperimentalIoApi\npublic expect class Memory {\n    /**\n     * Size of memory range in bytes.\n     */\n    public val size: Long\n\n    /**\n     * Size of memory range in bytes represented as signed 32bit integer\n     * @throws IllegalStateException when size doesn't fit into a signed 32bit integer\n     */\n    public val size32: Int\n\n    /**\n     * Returns byte at [index] position.\n     */\n    public inline fun loadAt(index: Int): Byte\n\n    /**\n     * Returns byte at [index] position.\n     */\n    public inline fun loadAt(index: Long): Byte\n\n    /**\n     * Write [value] at the specified [index].\n     */\n    public inline fun storeAt(index: Int, value: Byte)\n\n    /**\n     * Write [value] at the specified [index]\n     */\n    public inline fun storeAt(index: Long, value: Byte)\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    public fun slice(offset: Int, length: Int): Memory\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    public fun slice(offset: Long, length: Long): Memory\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    public fun copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int)\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    public fun copyTo(destination: Memory, offset: Long, length: Long, destinationOffset: Long)\n\n    public companion object {\n        /**\n         * Represents an empty memory region\n         */\n        public val Empty: Memory\n    }\n}\n\n/**\n * Read byte at the specified [index].\n */\npublic inline operator fun Memory.get(index: Int): Byte = loadAt(index)\n\n/**\n * Read byte at the specified [index].\n */\npublic inline operator fun Memory.get(index: Long): Byte = loadAt(index)\n\n/**\n * Index write operator to write [value] at the specified [index]\n */\npublic inline operator fun Memory.set(index: Long, value: Byte): Unit = storeAt(index, value)\n\n/**\n * Index write operator to write [value] at the specified [index]\n */\npublic inline operator fun Memory.set(index: Int, value: Byte): Unit = storeAt(index, value)\n\n/**\n * Index write operator to write [value] at the specified [index]\n */\npublic inline fun Memory.storeAt(index: Long, value: UByte): Unit = storeAt(index, value.toByte())\n\n/**\n * Index write operator to write [value] at the specified [index]\n */\npublic inline fun Memory.storeAt(index: Int, value: UByte): Unit = storeAt(index, value.toByte())\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\npublic expect fun Memory.fill(offset: Long, count: Long, value: Byte)\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\npublic expect fun Memory.fill(offset: Int, count: Int, value: Byte)\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination].\n */\npublic fun Memory.copyTo(destination: ByteArray, offset: Int, length: Int) {\n    copyTo(destination, offset, length, destinationOffset = 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic expect fun Memory.copyTo(destination: ByteArray, offset: Int, length: Int, destinationOffset: Int)\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination].\n */\npublic fun Memory.copyTo(destination: ByteArray, offset: Long, length: Int) {\n    copyTo(destination, offset, length, destinationOffset = 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic expect fun Memory.copyTo(destination: ByteArray, offset: Long, length: Int, destinationOffset: Int)\n","package io.ktor.utils.io.core.internal\n\n@PublishedApi\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.toIntOrFail(name: String): Int {\n    if (this >= Int.MAX_VALUE) failLongToIntConversion(this, name)\n    return toInt()\n}\n\n@PublishedApi\ninternal fun failLongToIntConversion(value: Long, name: String): Nothing =\n    throw IllegalArgumentException(\"Long value $value of $name doesn't fit into 32-bit integer\")\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.contracts.InvocationKind\nimport kotlin.contracts.contract\n\n// TODO: length default argument should be this.size - offset but it doesn't work due to KT-29920\n/**\n * Execute [block] of code providing a temporary instance of [Memory] view of this byte array range\n * starting at the specified [offset] and having the specified bytes [length].\n * By default, if neither [offset] nor [length] specified, the whole array is used.\n * An instance of [Memory] provided into the [block] should be never captured and used outside of lambda.\n */\n/**\n * TODO KTOR-1673: Solve design problems\n * 1. length has no default (blocked by expect/actual with default value compiler bug (fixed in KT 1.4.3))\n * 2. no inline -> can't suspend inside block (blocked by inline compiler bug)\n */\n@ExperimentalIoApi\npublic expect fun <R> ByteArray.useMemory(offset: Int = 0, length: Int, block: (Memory) -> R): R\n\n/**\n * Invoke [block] function with a temporary [Memory] instance of the specified [size] in bytes.\n * The provided instance shouldn't be captured and used outside of the [block] otherwise an undefined behaviour\n * may occur including crash and/or data corruption.\n */\n@ExperimentalIoApi\npublic inline fun <R> withMemory(size: Int, block: (Memory) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return withMemory(size.toLong(), block)\n}\n\n/**\n * Invoke [block] function with a temporary [Memory] instance of the specified [size] in bytes.\n * The provided instance shouldn't be captured and used outside of the [block] otherwise an undefined behaviour\n * may occur including crash and/or data corruption.\n */\n@ExperimentalIoApi\npublic inline fun <R> withMemory(size: Long, block: (Memory) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val allocator = DefaultAllocator\n    val memory = allocator.alloc(size)\n    return try {\n        block(memory)\n    } finally {\n        allocator.free(memory)\n    }\n}\n\n@PublishedApi\ninternal expect object DefaultAllocator : Allocator\n\n@DangerousInternalIoApi\ninternal interface Allocator {\n    fun alloc(size: Int): Memory\n\n    fun alloc(size: Long): Memory\n\n    fun free(instance: Memory)\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Read short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadShortAt(offset: Int): Short\n\n/**\n * Read short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadShortAt(offset: Long): Short\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeShortAt(offset: Int, value: Short)\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeShortAt(offset: Long, value: Short)\n\n/**\n * Read short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUShortAt(offset: Int): UShort = loadShortAt(offset).toUShort()\n\n/**\n * Read short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUShortAt(offset: Long): UShort = loadShortAt(offset).toUShort()\n\n/**\n * Write short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUShortAt(offset: Int, value: UShort): Unit = storeShortAt(offset, value.toShort())\n\n/**\n * Write short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUShortAt(offset: Long, value: UShort): Unit = storeShortAt(offset, value.toShort())\n\n/**\n * Read regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadIntAt(offset: Int): Int\n\n/**\n * Read regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadIntAt(offset: Long): Int\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeIntAt(offset: Int, value: Int)\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeIntAt(offset: Long, value: Int)\n\n/**\n * Read regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUIntAt(offset: Int): UInt = loadIntAt(offset).toUInt()\n\n/**\n * Read regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUIntAt(offset: Long): UInt = loadIntAt(offset).toUInt()\n\n/**\n * Write regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUIntAt(offset: Int, value: UInt): Unit = storeIntAt(offset, value.toInt())\n\n/**\n * Write regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUIntAt(offset: Long, value: UInt): Unit = storeIntAt(offset, value.toInt())\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadLongAt(offset: Int): Long\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadLongAt(offset: Long): Long\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeLongAt(offset: Int, value: Long)\n\n/**\n * write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeLongAt(offset: Long, value: Long)\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadULongAt(offset: Int): ULong = loadLongAt(offset).toULong()\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadULongAt(offset: Long): ULong = loadLongAt(offset).toULong()\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeULongAt(offset: Int, value: ULong): Unit = storeLongAt(offset, value.toLong())\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeULongAt(offset: Long, value: ULong): Unit = storeLongAt(offset, value.toLong())\n\n/**\n * Read short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadFloatAt(offset: Int): Float\n\n/**\n * Read short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadFloatAt(offset: Long): Float\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeFloatAt(offset: Int, value: Float)\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeFloatAt(offset: Long, value: Float)\n\n/**\n * Read short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadDoubleAt(offset: Int): Double\n\n/**\n * Read short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadDoubleAt(offset: Long): Double\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeDoubleAt(offset: Int, value: Double)\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeDoubleAt(offset: Long, value: Double)\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset].\n */\npublic inline fun Memory.loadByteArray(\n    offset: Int,\n    destination: ByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination, offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadByteArray(\n    offset: Long,\n    destination: ByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination, offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUByteArray(\n    offset: Int,\n    destination: UByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination.asByteArray(), offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUByteArray(\n    offset: Long,\n    destination: UByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination.asByteArray(), offset, count, destinationOffset)\n}\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadShortArray(\n    offset: Int,\n    destination: ShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadShortArray(\n    offset: Long,\n    destination: ShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUShortArray(\n    offset: Int,\n    destination: UShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadShortArray(offset, destination.asShortArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUShortArray(\n    offset: Long,\n    destination: UShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadShortArray(offset, destination.asShortArray(), destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadIntArray(\n    offset: Int,\n    destination: IntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadIntArray(\n    offset: Long,\n    destination: IntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUIntArray(\n    offset: Int,\n    destination: UIntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadIntArray(offset, destination.asIntArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUIntArray(\n    offset: Long,\n    destination: UIntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadIntArray(offset, destination.asIntArray(), destinationOffset, count)\n}\n\n/**\n * Copies long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadLongArray(\n    offset: Int,\n    destination: LongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadLongArray(\n    offset: Long,\n    destination: LongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadULongArray(\n    offset: Int,\n    destination: ULongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadLongArray(offset, destination.asLongArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadULongArray(\n    offset: Long,\n    destination: ULongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadLongArray(offset, destination.asLongArray(), destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadFloatArray(\n    offset: Int,\n    destination: FloatArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadFloatArray(\n    offset: Long,\n    destination: FloatArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadDoubleArray(\n    offset: Int,\n    destination: DoubleArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadDoubleArray(\n    offset: Long,\n    destination: DoubleArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeByteArray(\n    offset: Int,\n    source: ByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    source.useMemory(sourceOffset, count) { sourceMemory ->\n        sourceMemory.copyTo(this, 0, count, offset)\n    }\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeByteArray(\n    offset: Long,\n    source: ByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    source.useMemory(sourceOffset, count) { sourceMemory ->\n        sourceMemory.copyTo(this, 0L, count.toLong(), offset)\n    }\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUByteArray(\n    offset: Int,\n    source: UByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeByteArray(offset, source.asByteArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUByteArray(\n    offset: Long,\n    source: UByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeByteArray(offset, source.asByteArray(), sourceOffset, count)\n}\n\n/**\n * Copies shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeShortArray(\n    offset: Int,\n    source: ShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeShortArray(\n    offset: Long,\n    source: ShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUShortArray(\n    offset: Int,\n    source: UShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeShortArray(offset, source.asShortArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUShortArray(\n    offset: Long,\n    source: UShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeShortArray(offset, source.asShortArray(), sourceOffset, count)\n}\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeIntArray(\n    offset: Int,\n    source: IntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeIntArray(\n    offset: Long,\n    source: IntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUIntArray(\n    offset: Int,\n    source: UIntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeIntArray(offset, source.asIntArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUIntArray(\n    offset: Long,\n    source: UIntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeIntArray(offset, source.asIntArray(), sourceOffset, count)\n}\n\n/**\n * Copies long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeLongArray(\n    offset: Int,\n    source: LongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeLongArray(\n    offset: Long,\n    source: LongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeULongArray(\n    offset: Int,\n    source: ULongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeLongArray(offset, source.asLongArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeULongArray(\n    offset: Long,\n    source: ULongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeLongArray(offset, source.asLongArray(), sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeFloatArray(\n    offset: Int,\n    source: FloatArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeFloatArray(\n    offset: Long,\n    source: FloatArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeDoubleArray(\n    offset: Int,\n    source: DoubleArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeDoubleArray(\n    offset: Long,\n    source: DoubleArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"UArraysKt\")\n@file:kotlin.jvm.JvmPackageName(\"kotlin.collections.unsigned\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component1(): UInt {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component1(): ULong {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component1(): UByte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component1(): UShort {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component2(): UInt {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component2(): ULong {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component2(): UByte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component2(): UShort {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component3(): UInt {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component3(): ULong {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component3(): UByte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component3(): UShort {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component4(): UInt {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component4(): ULong {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component4(): UByte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component4(): UShort {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component5(): UInt {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component5(): ULong {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component5(): UByte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component5(): UShort {\n    return get(4)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.elementAt(index: Int): UInt\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.elementAt(index: Int): ULong\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.elementAt(index: Int): UByte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.elementAt(index: Int): UShort\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrNull(index: Int): UInt? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrNull(index: Int): ULong? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrNull(index: Int): UByte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrNull(index: Int): UShort? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.find(predicate: (UInt) -> Boolean): UInt? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.find(predicate: (ULong) -> Boolean): ULong? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.find(predicate: (UByte) -> Boolean): UByte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.find(predicate: (UShort) -> Boolean): UShort? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.findLast(predicate: (UInt) -> Boolean): UInt? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.findLast(predicate: (ULong) -> Boolean): ULong? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.findLast(predicate: (UByte) -> Boolean): UByte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.findLast(predicate: (UShort) -> Boolean): UShort? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(): UInt {\n    return storage.first().toUInt()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(): ULong {\n    return storage.first().toULong()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(): UByte {\n    return storage.first().toUByte()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(): UShort {\n    return storage.first().toUShort()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(predicate: (UInt) -> Boolean): UInt {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(predicate: (ULong) -> Boolean): ULong {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(predicate: (UByte) -> Boolean): UByte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(predicate: (UShort) -> Boolean): UShort {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.firstOrNull(): UInt? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.firstOrNull(): ULong? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.firstOrNull(): UByte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.firstOrNull(): UShort? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.firstOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.firstOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.firstOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.firstOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.getOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.getOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.getOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.getOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.getOrNull(index: Int): UInt? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.getOrNull(index: Int): ULong? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.getOrNull(index: Int): UByte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.getOrNull(index: Int): UShort? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOf(element: UInt): Int {\n    return storage.indexOf(element.toInt())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOf(element: ULong): Int {\n    return storage.indexOf(element.toLong())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOf(element: UByte): Int {\n    return storage.indexOf(element.toByte())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOf(element: UShort): Int {\n    return storage.indexOf(element.toShort())\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfFirst(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfFirst(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfFirst(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfFirst(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUShort()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfLast(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfLast(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfLast(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfLast(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUShort()) }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(): UInt {\n    return storage.last().toUInt()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(): ULong {\n    return storage.last().toULong()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(): UByte {\n    return storage.last().toUByte()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(): UShort {\n    return storage.last().toUShort()\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(predicate: (UInt) -> Boolean): UInt {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(predicate: (ULong) -> Boolean): ULong {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(predicate: (UByte) -> Boolean): UByte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(predicate: (UShort) -> Boolean): UShort {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastIndexOf(element: UInt): Int {\n    return storage.lastIndexOf(element.toInt())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastIndexOf(element: ULong): Int {\n    return storage.lastIndexOf(element.toLong())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastIndexOf(element: UByte): Int {\n    return storage.lastIndexOf(element.toByte())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastIndexOf(element: UShort): Int {\n    return storage.lastIndexOf(element.toShort())\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.lastOrNull(): UInt? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.lastOrNull(): ULong? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.lastOrNull(): UByte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.lastOrNull(): UShort? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.random(): UInt {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.random(): ULong {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.random(): UByte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.random(): UShort {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.random(random: Random): UInt {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.random(random: Random): ULong {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.random(random: Random): UByte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.random(random: Random): UShort {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.randomOrNull(): UInt? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.randomOrNull(): ULong? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.randomOrNull(): UByte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.randomOrNull(): UShort? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun UIntArray.randomOrNull(random: Random): UInt? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ULongArray.randomOrNull(random: Random): ULong? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun UByteArray.randomOrNull(random: Random): UByte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun UShortArray.randomOrNull(random: Random): UShort? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(): UInt {\n    return storage.single().toUInt()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(): ULong {\n    return storage.single().toULong()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(): UByte {\n    return storage.single().toUByte()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(): UShort {\n    return storage.single().toUShort()\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(predicate: (UInt) -> Boolean): UInt {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UInt\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(predicate: (ULong) -> Boolean): ULong {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as ULong\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(predicate: (UByte) -> Boolean): UByte {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UByte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(predicate: (UShort) -> Boolean): UShort {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UShort\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.singleOrNull(): UInt? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.singleOrNull(): ULong? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.singleOrNull(): UByte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.singleOrNull(): UShort? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.singleOrNull(predicate: (UInt) -> Boolean): UInt? {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.singleOrNull(predicate: (ULong) -> Boolean): ULong? {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.singleOrNull(predicate: (UByte) -> Boolean): UByte? {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.singleOrNull(predicate: (UShort) -> Boolean): UShort? {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.drop(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.drop(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.drop(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.drop(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.dropLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.dropLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.dropLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.dropLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    var yielding = false\n    val list = ArrayList<UInt>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    var yielding = false\n    val list = ArrayList<ULong>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    var yielding = false\n    val list = ArrayList<UByte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    var yielding = false\n    val list = ArrayList<UShort>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filter(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filter(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filter(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filter(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterIndexed(predicate: (index: Int, UInt) -> Boolean): List<UInt> {\n    return filterIndexedTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterIndexed(predicate: (index: Int, ULong) -> Boolean): List<ULong> {\n    return filterIndexedTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterIndexed(predicate: (index: Int, UByte) -> Boolean): List<UByte> {\n    return filterIndexedTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterIndexed(predicate: (index: Int, UShort) -> Boolean): List<UShort> {\n    return filterIndexedTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterIndexedTo(destination: C, predicate: (index: Int, UInt) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterIndexedTo(destination: C, predicate: (index: Int, ULong) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterIndexedTo(destination: C, predicate: (index: Int, UByte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterIndexedTo(destination: C, predicate: (index: Int, UShort) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterNot(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterNotTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterNot(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterNotTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterNot(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterNotTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterNot(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterNotTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterNotTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterNotTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterNotTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterNotTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: IntRange): List<UInt> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: IntRange): List<ULong> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: IntRange): List<UByte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: IntRange): List<UShort> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: Iterable<Int>): List<UInt> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UInt>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: Iterable<Int>): List<ULong> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<ULong>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: Iterable<Int>): List<UByte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UByte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: Iterable<Int>): List<UShort> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UShort>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: Collection<Int>): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: Collection<Int>): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: Collection<Int>): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: Collection<Int>): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: IntRange): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: IntRange): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: IntRange): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: IntRange): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.take(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UInt>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.take(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<ULong>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.take(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UByte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.take(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UShort>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.takeLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UInt>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.takeLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<ULong>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.takeLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UByte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.takeLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UShort>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    val list = ArrayList<UInt>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    val list = ArrayList<ULong>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    val list = ArrayList<UByte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    val list = ArrayList<UShort>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.reversed(): List<UInt> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.reversed(): List<ULong> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.reversed(): List<UByte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.reversed(): List<UShort> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reversedArray(): UIntArray {\n    return UIntArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reversedArray(): ULongArray {\n    return ULongArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reversedArray(): UByteArray {\n    return UByteArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reversedArray(): UShortArray {\n    return UShortArray(storage.reversedArray())\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sorted(): List<UInt> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sorted(): List<ULong> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sorted(): List<UByte> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sorted(): List<UShort> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArray(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArray(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArray(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArray(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArrayDescending(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArrayDescending(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArrayDescending(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArrayDescending(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedDescending(): List<UInt> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedDescending(): List<ULong> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedDescending(): List<UByte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedDescending(): List<UShort> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns an array of type [ByteArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.asByteArray(): ByteArray {\n    return storage\n}\n\n/**\n * Returns an array of type [IntArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.asIntArray(): IntArray {\n    return storage\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.asList(): List<UInt>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.asList(): List<ULong>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.asList(): List<UByte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.asList(): List<UShort>\n\n/**\n * Returns an array of type [LongArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.asLongArray(): LongArray {\n    return storage\n}\n\n/**\n * Returns an array of type [ShortArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.asShortArray(): ShortArray {\n    return storage\n}\n\n/**\n * Returns an array of type [UByteArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.asUByteArray(): UByteArray {\n    return UByteArray(this)\n}\n\n/**\n * Returns an array of type [UIntArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.asUIntArray(): UIntArray {\n    return UIntArray(this)\n}\n\n/**\n * Returns an array of type [ULongArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.asULongArray(): ULongArray {\n    return ULongArray(this)\n}\n\n/**\n * Returns an array of type [UShortArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.asUShortArray(): UShortArray {\n    return UShortArray(this)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.contentEquals(other: UIntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.contentEquals(other: ULongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.contentEquals(other: UByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.contentEquals(other: UShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray?.contentEquals(other: UIntArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray?.contentEquals(other: ULongArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray?.contentEquals(other: UByteArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray?.contentEquals(other: UShortArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyInto(destination: UIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UIntArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyInto(destination: ULongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ULongArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyInto(destination: UByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UByteArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyInto(destination: UShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UShortArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(): UIntArray {\n    return UIntArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(): ULongArray {\n    return ULongArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(): UByteArray {\n    return UByteArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(): UShortArray {\n    return UShortArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(newSize: Int): UIntArray {\n    return UIntArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(newSize: Int): ULongArray {\n    return ULongArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(newSize: Int): UByteArray {\n    return UByteArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(newSize: Int): UShortArray {\n    return UShortArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOfRange(fromIndex: Int, toIndex: Int): UIntArray {\n    return UIntArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOfRange(fromIndex: Int, toIndex: Int): ULongArray {\n    return ULongArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOfRange(fromIndex: Int, toIndex: Int): UByteArray {\n    return UByteArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOfRange(fromIndex: Int, toIndex: Int): UShortArray {\n    return UShortArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.fill(element: UInt, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toInt(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.fill(element: ULong, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toLong(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.fill(element: UByte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toByte(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.fill(element: UShort, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toShort(), fromIndex, toIndex)\n}\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray {\n    return UIntArray(storage + element.toInt())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray {\n    return ULongArray(storage + element.toLong())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray {\n    return UByteArray(storage + element.toByte())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray {\n    return UShortArray(storage + element.toShort())\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toInt()\n    return UIntArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toLong()\n    return ULongArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toByte()\n    return UByteArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toShort()\n    return UShortArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray {\n    return UIntArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray {\n    return ULongArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray {\n    return UByteArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray {\n    return UShortArray(storage + elements.storage)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns an array of type [ByteArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.toByteArray(): ByteArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [IntArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.toIntArray(): IntArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [LongArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.toLongArray(): LongArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [ShortArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.toShortArray(): ShortArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.toTypedArray(): Array<UInt> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.toTypedArray(): Array<ULong> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.toTypedArray(): Array<UByte> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.toTypedArray(): Array<UShort> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of UByte containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.toUByteArray(): UByteArray {\n    return UByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UByteArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.toUByteArray(): UByteArray {\n    return UByteArray(this.copyOf())\n}\n\n/**\n * Returns an array of UInt containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.toUIntArray(): UIntArray {\n    return UIntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UIntArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.toUIntArray(): UIntArray {\n    return UIntArray(this.copyOf())\n}\n\n/**\n * Returns an array of ULong containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.toULongArray(): ULongArray {\n    return ULongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [ULongArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.toULongArray(): ULongArray {\n    return ULongArray(this.copyOf())\n}\n\n/**\n * Returns an array of UShort containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.toUShortArray(): UShortArray {\n    return UShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UShortArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.toUShortArray(): UShortArray {\n    return UShortArray(this.copyOf())\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.associateWith(valueSelector: (UInt) -> V): Map<UInt, V> {\n    val result = LinkedHashMap<UInt, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.associateWith(valueSelector: (ULong) -> V): Map<ULong, V> {\n    val result = LinkedHashMap<ULong, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.associateWith(valueSelector: (UByte) -> V): Map<UByte, V> {\n    val result = LinkedHashMap<UByte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.associateWith(valueSelector: (UShort) -> V): Map<UShort, V> {\n    val result = LinkedHashMap<UShort, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UInt, in V>> UIntArray.associateWithTo(destination: M, valueSelector: (UInt) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in ULong, in V>> ULongArray.associateWithTo(destination: M, valueSelector: (ULong) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UByte, in V>> UByteArray.associateWithTo(destination: M, valueSelector: (UByte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UShort, in V>> UShortArray.associateWithTo(destination: M, valueSelector: (UShort) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMap(transform: (UInt) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMap(transform: (ULong) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMap(transform: (UByte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMap(transform: (UShort) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMapIndexed(transform: (index: Int, UInt) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMapIndexed(transform: (index: Int, ULong) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMapIndexed(transform: (index: Int, UByte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMapIndexed(transform: (index: Int, UShort) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapIndexedTo(destination: C, transform: (index: Int, UInt) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapIndexedTo(destination: C, transform: (index: Int, ULong) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, UByte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, UShort) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapTo(destination: C, transform: (UInt) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapTo(destination: C, transform: (ULong) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapTo(destination: C, transform: (UByte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapTo(destination: C, transform: (UShort) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UInt>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>> {\n    return groupByTo(LinkedHashMap<K, MutableList<ULong>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UByte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UShort>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UIntArray.groupBy(keySelector: (UInt) -> K, valueTransform: (UInt) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> ULongArray.groupBy(keySelector: (ULong) -> K, valueTransform: (ULong) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UByteArray.groupBy(keySelector: (UByte) -> K, valueTransform: (UByte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UShortArray.groupBy(keySelector: (UShort) -> K, valueTransform: (UShort) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UInt>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UInt>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<ULong>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<ULong>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UByte>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UByte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UShort>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UShort>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K, valueTransform: (UInt) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K, valueTransform: (ULong) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K, valueTransform: (UByte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K, valueTransform: (UShort) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.map(transform: (UInt) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.map(transform: (ULong) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.map(transform: (UByte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.map(transform: (UShort) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.mapIndexed(transform: (index: Int, UInt) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.mapIndexed(transform: (index: Int, ULong) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.mapIndexed(transform: (index: Int, UByte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.mapIndexed(transform: (index: Int, UShort) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapIndexedTo(destination: C, transform: (index: Int, UInt) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapIndexedTo(destination: C, transform: (index: Int, ULong) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapIndexedTo(destination: C, transform: (index: Int, UByte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapIndexedTo(destination: C, transform: (index: Int, UShort) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapTo(destination: C, transform: (UInt) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapTo(destination: C, transform: (ULong) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapTo(destination: C, transform: (UByte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapTo(destination: C, transform: (UShort) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.withIndex(): Iterable<IndexedValue<UInt>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.withIndex(): Iterable<IndexedValue<ULong>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.withIndex(): Iterable<IndexedValue<UByte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.withIndex(): Iterable<IndexedValue<UShort>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.all(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.all(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.all(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.all(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.count(predicate: (UInt) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.count(predicate: (ULong) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.count(predicate: (UByte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.count(predicate: (UShort) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.fold(initial: R, operation: (acc: R, UInt) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.fold(initial: R, operation: (acc: R, ULong) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.fold(initial: R, operation: (acc: R, UByte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.fold(initial: R, operation: (acc: R, UShort) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRight(initial: R, operation: (UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRight(initial: R, operation: (ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRight(initial: R, operation: (UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRight(initial: R, operation: (UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRightIndexed(initial: R, operation: (index: Int, UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRightIndexed(initial: R, operation: (index: Int, ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRightIndexed(initial: R, operation: (index: Int, UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRightIndexed(initial: R, operation: (index: Int, UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEach(action: (UInt) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEach(action: (ULong) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEach(action: (UByte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEach(action: (UShort) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEachIndexed(action: (index: Int, UInt) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEachIndexed(action: (index: Int, ULong) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEachIndexed(action: (index: Int, UByte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEachIndexed(action: (index: Int, UShort) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.max(): UInt? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.max(): ULong? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.max(): UByte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.max(): UShort? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxBy(selector: (UInt) -> R): UInt? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxBy(selector: (ULong) -> R): ULong? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxBy(selector: (UByte) -> R): UByte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxBy(selector: (UShort) -> R): UShort? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxOrNull(): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxOrNull(): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxOrNull(): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxOrNull(): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWith(comparator: Comparator<in UInt>): UInt? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWith(comparator: Comparator<in ULong>): ULong? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWith(comparator: Comparator<in UByte>): UByte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWith(comparator: Comparator<in UShort>): UShort? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.min(): UInt? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.min(): ULong? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.min(): UByte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.min(): UShort? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minBy(selector: (UInt) -> R): UInt? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minBy(selector: (ULong) -> R): ULong? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minBy(selector: (UByte) -> R): UByte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minBy(selector: (UShort) -> R): UShort? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minOrNull(): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minOrNull(): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minOrNull(): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minOrNull(): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWith(comparator: Comparator<in UInt>): UInt? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWith(comparator: Comparator<in ULong>): ULong? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWith(comparator: Comparator<in UByte>): UByte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWith(comparator: Comparator<in UShort>): UShort? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEach(action: (UInt) -> Unit): UIntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEach(action: (ULong) -> Unit): ULongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEach(action: (UByte) -> Unit): UByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEach(action: (UShort) -> Unit): UShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEachIndexed(action: (index: Int, UInt) -> Unit): UIntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEachIndexed(action: (index: Int, ULong) -> Unit): ULongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEachIndexed(action: (index: Int, UByte) -> Unit): UByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEachIndexed(action: (index: Int, UShort) -> Unit): UShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduce(operation: (acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduce(operation: (acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduce(operation: (acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduce(operation: (acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexedOrNull(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexedOrNull(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexedOrNull(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexedOrNull(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceOrNull(operation: (acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceOrNull(operation: (acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceOrNull(operation: (acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceOrNull(operation: (acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRight(operation: (UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRight(operation: (ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRight(operation: (UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRight(operation: (UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexed(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexed(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexed(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexed(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexedOrNull(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexedOrNull(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexedOrNull(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexedOrNull(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightOrNull(operation: (UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightOrNull(operation: (ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightOrNull(operation: (UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightOrNull(operation: (UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFold(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFold(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFold(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFold(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduce(operation: (acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduce(operation: (acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduce(operation: (acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduce(operation: (acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scan(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scan(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scan(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scan(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumBy(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumBy(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumBy(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumBy(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumByDouble(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumByDouble(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumByDouble(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumByDouble(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Array<out R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Array<out R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Array<out R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Array<out R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Array<out R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Array<out R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Array<out R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Array<out R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Iterable<R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Iterable<R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Iterable<R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Iterable<R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Iterable<R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Iterable<R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Iterable<R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Iterable<R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.zip(other: UIntArray): List<Pair<UInt, UInt>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.zip(other: ULongArray): List<Pair<ULong, ULong>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.zip(other: UByteArray): List<Pair<UByte, UByte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.zip(other: UShortArray): List<Pair<UShort, UShort>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.zip(other: UIntArray, transform: (a: UInt, b: UInt) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.zip(other: ULongArray, transform: (a: ULong, b: ULong) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.zip(other: UByteArray, transform: (a: UByte, b: UByte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.zip(other: UShortArray, transform: (a: UShort, b: UShort) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out UInt>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out ULong>.sum(): ULong {\n    var sum: ULong = 0uL\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUByte\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out UByte>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUShort\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out UShort>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sum(): UInt {\n    return storage.sum().toUInt()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sum(): ULong {\n    return storage.sum().toULong()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sum(): UInt {\n    return sumOf { it.toUInt() }\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sum(): UInt {\n    return sumOf { it.toUInt() }\n}\n\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.contracts.*\n\n/**\n * Execute [block] of code providing a temporary instance of [Memory] view of this byte array range\n * starting at the specified [offset] and having the specified bytes [length].\n * By default, if neither [offset] nor [length] specified, the whole array is used.\n * An instance of [Memory] provided into the [block] should be never captured and used outside of lambda.\n */\npublic actual inline fun <R> ByteArray.useMemory(offset: Int, length: Int, block: (Memory) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return Memory.of(this, offset, length).let(block)\n}\n\n/**\n * Create [Memory] view for the specified [array] range starting at [offset] and the specified bytes [length].\n */\npublic fun Memory.Companion.of(array: ByteArray, offset: Int = 0, length: Int = array.size - offset): Memory {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val typedArray: Int8Array = array.asDynamic()\n    return Memory.of(typedArray, offset, length)\n}\n\n/**\n * Create [Memory] view for the specified [buffer] range starting at [offset] and the specified bytes [length].\n */\npublic fun Memory.Companion.of(buffer: ArrayBuffer, offset: Int = 0, length: Int = buffer.byteLength - offset): Memory {\n    return Memory(DataView(buffer, offset, length))\n}\n\n/**\n * Create [Memory] view for the specified [view].\n */\npublic fun Memory.Companion.of(view: DataView): Memory {\n    return Memory(view)\n}\n\n/**\n * Create [Memory] view for the specified [view] range starting at [offset] and the specified bytes [length].\n */\npublic fun Memory.Companion.of(view: ArrayBufferView, offset: Int = 0, length: Int = view.byteLength): Memory {\n    return Memory.of(view.buffer, view.byteOffset + offset, length)\n}\n\n@PublishedApi\ninternal actual object DefaultAllocator : Allocator {\n    override fun alloc(size: Int): Memory = Memory(DataView(ArrayBuffer(size)))\n    override fun alloc(size: Long): Memory = Memory(DataView(ArrayBuffer(size.toIntOrFail(\"size\"))))\n    override fun free(instance: Memory) {\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\npublic expect interface Output : Appendable, Closeable {\n    @Deprecated(\n        \"This is no longer supported. All operations are big endian by default. Use writeXXXLittleEndian \" +\n            \"to write primitives in little endian order\" +\n            \" or do X.reverseByteOrder() and then writeXXX instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var byteOrder: ByteOrder\n\n    public fun writeByte(v: Byte)\n\n    public fun flush()\n\n    override fun close()\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeShort(v: Short) {\n        writeShort(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeInt(v: Int) {\n        writeInt(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeLong(v: Long) {\n        writeLong(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFloat(v: Float) {\n        writeFloat(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeDouble(v: Double) {\n        writeDouble(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: IntArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: LongArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: IoBuffer, length: Int) {\n        writeFully(src, length)\n    }\n\n    public fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun fill(n: Long, v: Byte) {\n        fill(n, v)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.append(csq: CharSequence, start: Int = 0, end: Int = csq.length): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.append(csq: CharArray, start: Int = 0, end: Int = csq.size): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: ByteArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyBytesTemplate(offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: ShortArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(2, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: IntArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(4, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: LongArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(8, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: FloatArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(4, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: DoubleArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(8, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Output.writeFully(src: IoBuffer, length: Int = src.readRemaining) {\n    writeFully(src as Buffer, length)\n}\n\npublic fun Output.writeFully(src: Buffer, length: Int = src.readRemaining) {\n    writeFullyBytesTemplate(0, length) { buffer, _, count ->\n        buffer.writeFully(src, count)\n    }\n}\n\npublic fun Output.writeFully(src: Memory, offset: Int, length: Int) {\n    writeFully(src, offset.toLong(), length.toLong())\n}\n\npublic fun Output.writeFully(src: Memory, offset: Long, length: Long) {\n    writeFullyBytesTemplate(offset, length) { memory, destinationOffset, sourceOffset, count ->\n        src.copyTo(memory, sourceOffset, count, destinationOffset)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.fill(times: Long, value: Byte = 0) {\n    if (this is AbstractOutput) {\n        var written = 0L\n        writeWhile { buffer ->\n            val partTimes = minOf(buffer.writeRemaining.toLong(), times - written).toInt()\n            buffer.fill(partTimes, value)\n            written += partTimes\n            written < times\n        }\n    } else {\n        fillFallback(times, value)\n    }\n}\n\nprivate fun Output.fillFallback(times: Long, value: Byte) {\n    for (iterate in 0 until times) {\n        writeByte(value)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is true.\n * Depending on the output underlying implementation it could invoke [block] function with the same buffer several times\n * however it is guaranteed that it is always non-empty.\n */\n@DangerousInternalIoApi\npublic inline fun Output.writeWhile(block: (Buffer) -> Boolean) {\n    var tail: ChunkBuffer = prepareWriteHead(1, null)\n    try {\n        while (true) {\n            if (!block(tail)) break\n            tail = prepareWriteHead(1, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is positive.\n * If returned value is positive then it will be invoked again with a buffer having at least requested number of\n * bytes space (could be the same buffer as before if it complies to the restriction).\n * @param initialSize for the first buffer passed to [block] function\n */\n@DangerousInternalIoApi\npublic inline fun Output.writeWhileSize(initialSize: Int = 1, block: (Buffer) -> Int) {\n    var tail = prepareWriteHead(initialSize, null)\n\n    try {\n        var size: Int\n        while (true) {\n            size = block(tail)\n            if (size <= 0) break\n            tail = prepareWriteHead(size, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\npublic fun Output.writePacket(packet: ByteReadPacket) {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        writePacket(packet)\n        return\n    }\n\n    packet.takeWhile { from ->\n        writeFully(from)\n        true\n    }\n}\n\nprivate inline fun Output.writeFullyBytesTemplate(\n    offset: Int,\n    length: Int,\n    block: (Buffer, currentOffset: Int, count: Int) -> Unit\n) {\n    var currentOffset = offset\n    var remaining = length\n\n    writeWhile { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining)\n        block(buffer, currentOffset, size)\n        currentOffset += size\n        remaining -= size\n        remaining > 0\n    }\n}\n\nprivate inline fun Output.writeFullyBytesTemplate(\n    initialOffset: Long,\n    length: Long,\n    block: (destination: Memory, destinationOffset: Long, currentOffset: Long, count: Long) -> Unit\n) {\n    var currentOffset = initialOffset\n    var remaining = length\n\n    writeWhile { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining.toLong())\n        block(buffer.memory, buffer.writePosition.toLong(), currentOffset, size)\n        buffer.commitWritten(size.toInt())\n        currentOffset += size\n        remaining -= size\n        remaining > 0\n    }\n}\n\nprivate inline fun Output.writeFullyTemplate(\n    componentSize: Int,\n    offset: Int,\n    length: Int,\n    block: (Buffer, currentOffset: Int, count: Int) -> Unit\n) {\n    var currentOffset = offset\n    var remaining = length\n\n    writeWhileSize(componentSize) { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining)\n        block(buffer, currentOffset, size)\n        currentOffset += size\n        remaining -= size\n        remaining * componentSize\n    }\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.core.internal.require\nimport io.ktor.utils.io.pool.*\n\n/**\n * The default abstract base class implementing [Input] interface.\n * @see [AbstractInput.fill] and [AbstractInput.closeSource].\n */\n@Deprecated(\n    \"AbstractInput is deprecated and will be merged with Input in 2.0.0\",\n    ReplaceWith(\"Input\"),\n    DeprecationLevel.WARNING\n)\npublic abstract class AbstractInput(\n    head: ChunkBuffer = ChunkBuffer.Empty,\n    remaining: Long = head.remainingAll(),\n    public val pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n) : Input {\n    private val state = AbstractInputSharedState(head, remaining)\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(\n        head: IoBuffer = IoBuffer.Empty,\n        remaining: Long = head.remainingAll(),\n        pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n    ) : this(head as ChunkBuffer, remaining, pool)\n\n    /**\n     * Read the next bytes into the [destination] starting at [offset] at most [length] bytes.\n     * May block until at least one byte is available.\n     * Usually bypass all exceptions from the underlying source.\n     *\n     * @param offset in bytes where result should be written\n     * @param length should be at least one byte\n     *\n     * @return number of bytes were copied or `0` if EOF encountered\n     */\n    protected abstract fun fill(destination: Memory, offset: Int, length: Int): Int\n\n    /**\n     * Should close the underlying bytes source. Could do nothing or throw exceptions.\n     */\n    protected abstract fun closeSource()\n\n    /**\n     * Current head chunk reference\n     */\n    private final var _head: ChunkBuffer\n        get() = state.head\n        set(newHead) {\n            state.head = newHead\n            state.headMemory = newHead.memory\n            state.headPosition = newHead.readPosition\n            state.headEndExclusive = newHead.writePosition\n        }\n\n    @PublishedApi\n    @Suppress(\"CanBePrimaryConstructorProperty\")\n    internal var head: ChunkBuffer\n        get() = _head.also { it.discardUntilIndex(headPosition) }\n        @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.ERROR)\n        set(newHead) {\n            _head = newHead\n        }\n\n    @PublishedApi\n    internal final var headMemory: Memory\n        get() = state.headMemory\n        set(value) {\n            state.headMemory = value\n        }\n\n    @PublishedApi\n    internal final var headPosition: Int\n        get() = state.headPosition\n        set(value) {\n            state.headPosition = value\n        }\n\n    @PublishedApi\n    internal final var headEndExclusive: Int\n        get() = state.headEndExclusive\n        set(value) {\n            state.headEndExclusive = value\n        }\n\n    @PublishedApi\n    @Suppress(\"DEPRECATION_ERROR\")\n    internal final var headRemaining: Int\n        inline get() = headEndExclusive - headPosition\n        @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n        set(newRemaining) {\n            updateHeadRemaining(newRemaining)\n        }\n\n    private var tailRemaining: Long\n        get() = state.tailRemaining\n        set(newValue) {\n            require(newValue >= 0) { \"tailRemaining shouldn't be negative: $newValue\" }\n            state.tailRemaining = newValue\n        }\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default.\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            if (newOrder != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only BIG_ENDIAN is supported.\")\n            }\n        }\n\n    internal final fun prefetch(min: Long): Boolean {\n        if (min <= 0) return true\n        val headRemaining = headRemaining\n        if (headRemaining >= min || headRemaining + tailRemaining >= min) return true\n\n        return doPrefetch(min)\n    }\n\n    final override fun peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n        prefetch(min + offset)\n\n        var current: ChunkBuffer = head\n        var copied = 0L\n        var skip = offset\n        var writePosition = destinationOffset\n        val maxCopySize = minOf(max, destination.size - destinationOffset)\n\n        while (copied < min && copied < maxCopySize) {\n            val chunkSize = current.readRemaining\n            if (chunkSize > skip) {\n                val size = minOf(chunkSize - skip, maxCopySize - copied)\n                current.memory.copyTo(\n                    destination,\n                    current.readPosition + skip,\n                    size,\n                    writePosition\n                )\n                skip = 0\n                copied += size\n                writePosition += size\n            } else {\n                skip -= chunkSize\n            }\n\n            current = current.next ?: break\n        }\n\n        return copied\n    }\n\n    /**\n     * @see doFill for similar logic\n     * @see appendView for similar logic\n     */\n    private fun doPrefetch(min: Long): Boolean {\n        var tail = _head.findTail()\n        var available = headRemaining + tailRemaining\n\n        do {\n            val next = fill()\n            if (next == null) {\n                noMoreChunksAvailable = true\n                return false\n            }\n\n            val chunkSize = next.readRemaining\n            if (tail === ChunkBuffer.Empty) {\n                _head = next\n                tail = next\n            } else {\n                tail.next = next\n                tailRemaining += chunkSize\n            }\n\n            available += chunkSize\n        } while (available < min)\n\n        return true\n    }\n\n    /**\n     * Number of bytes available for read\n     */\n    public final val remaining: Long get() = headRemaining.toLong() + tailRemaining\n\n    /**\n     * @return `true` if there is at least one byte to read\n     */\n    public final fun canRead(): Boolean = headPosition != headEndExclusive || tailRemaining != 0L\n\n    /**\n     * @return `true` if there are at least [n] bytes to read\n     */\n    public final fun hasBytes(n: Int): Boolean = headRemaining + tailRemaining >= n\n\n    /**\n     * `true` if no bytes available for read\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public final val isEmpty: Boolean\n        get() = endOfInput\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public final val isNotEmpty: Boolean\n        get() = isNotEmpty\n\n    private var noMoreChunksAvailable = false\n\n    final override val endOfInput: Boolean\n        get() = headRemaining == 0 && tailRemaining == 0L && (noMoreChunksAvailable || doFill() == null)\n\n    /**\n     * Release packet. After this function invocation the packet becomes empty.\n     * If it has been copied via [ByteReadPacket.copy]\n     * then the copy should be released as well.\n     */\n    public final fun release() {\n        val head = head\n        val empty = ChunkBuffer.Empty\n\n        if (head !== empty) {\n            this._head = empty\n            tailRemaining = 0\n            head.releaseAll(pool)\n        }\n    }\n\n    final override fun close() {\n        release()\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n        closeSource()\n    }\n\n    internal final fun stealAll(): ChunkBuffer? {\n        val head = head\n        val empty = ChunkBuffer.Empty\n\n        if (head === empty) return null\n        this._head = empty\n        tailRemaining = 0\n        return head\n    }\n\n    internal final fun steal(): ChunkBuffer? {\n        val head = head\n        val next = head.next\n        val empty = ChunkBuffer.Empty\n        if (head === empty) return null\n\n        if (next == null) {\n            this._head = empty\n            this.tailRemaining = 0\n        } else {\n            this._head = next\n            this.tailRemaining -= next.readRemaining\n        }\n\n        head.next = null\n        return head\n    }\n\n    internal final fun append(chain: ChunkBuffer) {\n        if (chain === ChunkBuffer.Empty) return\n\n        val size = chain.remainingAll()\n        if (_head === ChunkBuffer.Empty) {\n            _head = chain\n            tailRemaining = size - headRemaining\n        } else {\n            _head.findTail().next = chain\n            tailRemaining += size\n        }\n    }\n\n    internal final fun tryWriteAppend(chain: ChunkBuffer): Boolean {\n        val tail = head.findTail()\n        val size = chain.readRemaining\n\n        if (size == 0 || tail.writeRemaining < size) return false\n        tail.writeBufferAppend(chain, size)\n\n        if (head === tail) {\n            headEndExclusive = tail.writePosition\n        } else {\n            tailRemaining += size\n        }\n\n        return true\n    }\n\n    final override fun readByte(): Byte {\n        val index = headPosition\n        val nextIndex = index + 1\n        if (nextIndex < headEndExclusive) {\n            // fast-path when we are not reading the last byte\n            headPosition = nextIndex\n            return headMemory[index]\n        }\n\n        return readByteSlow()\n    }\n\n    private fun readByteSlow(): Byte {\n        val index = headPosition\n        if (index < headEndExclusive) {\n            val value = headMemory[index]\n            headPosition = index\n            val head = _head\n            head.discardUntilIndex(index)\n            ensureNext(head)\n            return value\n        }\n\n        val head = prepareRead(1) ?: prematureEndOfStream(1)\n        val byte = head.readByte()\n        completeReadHead(head)\n        return byte\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readShort(): Short = readShort()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFloat(): Float = readFloat()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readDouble(): Double = readDouble()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readInt(): Int {\n        return readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readLong(): Long {\n        return readLong()\n    }\n\n    /**\n     * Read exactly [length] bytes to [dst] array at specified [offset]\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc != length) {\n            throw EOFException(\"Not enough data in packet to fill buffer: ${length - rc} more bytes required\")\n        }\n    }\n\n    /**\n     * Discards at most [n] bytes\n     * @return number of bytes has been discarded\n     */\n    public final fun discard(n: Int): Int {\n        require(n >= 0) { \"Negative discard is not allowed: $n\" }\n        return discardAsMuchAsPossible(n, 0)\n    }\n\n    /**\n     * Discards exactly [n] bytes or fails with [EOFException]\n     */\n    public final fun discardExact(n: Int) {\n        if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes due to end of packet\")\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal inline fun read(block: (Buffer) -> Unit) {\n        read(block = block)\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal inline fun read(n: Int, block: (Buffer) -> Unit) {\n        read(n, block)\n    }\n\n    /**\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    final override fun tryPeek(): Int {\n        val head = head\n        if (headRemaining > 0) {\n            return head.tryPeekByte()\n        }\n\n        if (tailRemaining == 0L && noMoreChunksAvailable) return -1\n\n        return prepareReadLoop(1, head)?.tryPeekByte() ?: -1\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun peekTo(buffer: IoBuffer): Int {\n        val head = prepareReadHead(1) ?: return -1\n\n        val size = minOf(buffer.writeRemaining, head.readRemaining)\n        (buffer as Buffer).writeFully(head, size)\n\n        return size\n    }\n\n    final override fun discard(n: Long): Long {\n        if (n <= 0) return 0L\n        return discardAsMuchAsPossible(n, 0)\n    }\n\n    internal fun readAvailableCharacters(destination: CharArray, off: Int, len: Int): Int {\n        if (endOfInput) return -1\n\n        val out = object : Appendable {\n            private var idx = off\n\n            override fun append(c: Char): Appendable {\n                destination[idx++] = c\n                return this\n            }\n\n            override fun append(csq: CharSequence?): Appendable {\n                if (csq is String) {\n                    csq.getCharsInternal(destination, idx)\n                    idx += csq.length\n                } else if (csq != null) {\n                    for (i in 0 until csq.length) {\n                        destination[idx++] = csq[i]\n                    }\n                }\n\n                return this\n            }\n\n            override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n                throw UnsupportedOperationException()\n            }\n        }\n\n        return readText(out, 0, len)\n    }\n\n    /**\n     * Read at least [min] and at most [max] characters and append them to [out]\n     * @return number of characters appended\n     */\n    public fun readText(out: Appendable, min: Int = 0, max: Int = Int.MAX_VALUE): Int {\n        if (max.toLong() >= remaining) {\n            val s = readTextExactBytes(bytesCount = remaining.toInt())\n            out.append(s)\n            return s.length\n        }\n        return readASCII(out, min, max)\n    }\n\n    /**\n     * Read exactly [exactCharacters] characters and append them to [out]\n     */\n    public fun readTextExact(out: Appendable, exactCharacters: Int) {\n        readText(out, exactCharacters, exactCharacters)\n    }\n\n    /**\n     * Read a string at last [min] and at most [max] characters length\n     */\n    public fun readText(min: Int = 0, max: Int = Int.MAX_VALUE): String {\n        if (min == 0 && (max == 0 || endOfInput)) return \"\"\n        val remaining = remaining\n        if (remaining > 0 && max.toLong() >= remaining) return readTextExactBytes(bytesCount = remaining.toInt())\n\n        return buildString(min.coerceAtLeast(16).coerceAtMost(max)) {\n            readASCII(this, min, max)\n        }\n    }\n\n    /**\n     * Read a string exactly [exactCharacters] length\n     */\n    public fun readTextExact(exactCharacters: Int): String {\n        return readText(exactCharacters, exactCharacters)\n    }\n\n    private fun readASCII(out: Appendable, min: Int, max: Int): Int {\n        when {\n            max == 0 && min == 0 -> return 0\n            endOfInput -> if (min == 0) return 0 else atLeastMinCharactersRequire(min)\n            max < min -> minShouldBeLess(min, max)\n        }\n\n        var copied = 0\n        var utf8 = false\n\n        takeWhile { buffer ->\n            val rc = buffer.decodeASCII {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                rc -> true\n                copied == max -> false\n                else -> {\n                    utf8 = true\n                    false\n                }\n            }\n        }\n\n        if (utf8) {\n            return copied + readUtf8(out, min - copied, max - copied)\n        }\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n        return copied\n    }\n\n    private fun atLeastMinCharactersRequire(min: Int): Nothing =\n        throw EOFException(\"at least $min characters required but no bytes available\")\n\n    private fun minShouldBeLess(min: Int, max: Int): Nothing =\n        throw IllegalArgumentException(\"min should be less or equal to max but min = $min, max = $max\")\n\n    private fun prematureEndOfStreamChars(min: Int, copied: Int): Nothing = throw MalformedUTF8InputException(\n        \"Premature end of stream: expected at least $min chars but had only $copied\"\n    )\n\n    private fun readUtf8(out: Appendable, min: Int, max: Int): Int {\n        var copied = 0\n\n        takeWhileSize { buffer ->\n            val size = buffer.decodeUTF8 {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                size == 0 -> 1\n                size > 0 -> size\n                else -> 0\n            }\n        }\n\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n\n        return copied\n    }\n\n    private tailrec fun discardAsMuchAsPossible(n: Long, skipped: Long): Long {\n        if (n == 0L) return skipped\n        val current = prepareRead(1) ?: return skipped\n        val size = minOf(current.readRemaining.toLong(), n).toInt()\n        current.discardExact(size)\n        headPosition += size\n        afterRead(current)\n\n        return discardAsMuchAsPossible(n - size, skipped + size)\n    }\n\n    private fun discardAsMuchAsPossible(n: Int, skipped: Int): Int {\n        var currentCount = n\n        var currentSkipped = skipped\n\n        while (true) {\n            if (currentCount == 0) {\n                return currentSkipped\n            }\n\n            val current = prepareRead(1) ?: return currentSkipped\n\n            val size = minOf(current.readRemaining, currentCount)\n            current.discardExact(size)\n            headPosition += size\n            afterRead(current)\n\n            currentCount -= size\n            currentSkipped += size\n        }\n    }\n\n    private tailrec fun readAsMuchAsPossible(array: ByteArray, offset: Int, length: Int, copied: Int): Int {\n        if (length == 0) return copied\n        val current = prepareRead(1) ?: return copied\n        val size = minOf(length, current.readRemaining)\n\n        current.readFully(array, offset, size)\n        headPosition = current.readPosition\n\n        return if (size != length || current.readRemaining == 0) {\n            afterRead(current)\n            readAsMuchAsPossible(array, offset + size, length - size, copied + size)\n        } else {\n            copied + size\n        }\n    }\n\n    private fun notEnoughBytesAvailable(n: Int): Nothing {\n        throw EOFException(\"Not enough data in packet ($remaining) to read $n byte(s)\")\n    }\n\n    @Deprecated(\"Not supported anymore.\", level = DeprecationLevel.ERROR)\n    public fun updateHeadRemaining(remaining: Int) {\n        // the only external usages are from readDirect\n        // so after using head chunk directly we should fix positions instead\n        val newPosition = headEndExclusive - remaining\n\n        if (newPosition < 0) {\n            throw IllegalArgumentException(\"Unable to update position to negative. newRemaining is too big.\")\n        }\n\n        headPosition = newPosition\n    }\n\n    @DangerousInternalIoApi\n    public fun prepareReadHead(minSize: Int): ChunkBuffer? = prepareReadLoop(minSize, head)\n\n    @DangerousInternalIoApi\n    public fun ensureNextHead(current: ChunkBuffer): ChunkBuffer? = ensureNext(current)\n\n    @PublishedApi\n    internal fun ensureNext(current: ChunkBuffer): ChunkBuffer? = ensureNext(\n        current,\n        ChunkBuffer.Empty\n    )\n\n    @DangerousInternalIoApi\n    public fun fixGapAfterRead(current: ChunkBuffer) {\n        val next = current.next ?: return fixGapAfterReadFallback(current)\n\n        val remaining = current.readRemaining\n        val overrunSize = minOf(remaining, Buffer.ReservedSize - current.endGap)\n        if (next.startGap < overrunSize) {\n            return fixGapAfterReadFallback(current)\n        }\n\n        next.restoreStartGap(overrunSize)\n\n        if (remaining > overrunSize) {\n            current.releaseEndGap()\n\n            this.headEndExclusive = current.writePosition\n            this.tailRemaining += overrunSize\n        } else {\n            this._head = next\n            this.tailRemaining -= next.readRemaining - overrunSize\n            current.cleanNext()\n            current.release(pool)\n        }\n    }\n\n    private fun fixGapAfterReadFallback(current: ChunkBuffer) {\n        if (noMoreChunksAvailable && current.next == null) {\n            this.headPosition = current.readPosition\n            this.headEndExclusive = current.writePosition\n            this.tailRemaining = 0\n            return\n        }\n\n        val size = current.readRemaining\n        val overrun = minOf(size, Buffer.ReservedSize - current.endGap)\n\n        if (size > overrun) {\n            fixGapAfterReadFallbackUnreserved(current, size, overrun)\n        } else {\n            val new = pool.borrow()\n            new.reserveEndGap(Buffer.ReservedSize)\n            new.next = current.cleanNext()\n\n            new.writeBufferAppend(current, size)\n            this._head = new\n        }\n\n        current.release(pool)\n    }\n\n    private fun fixGapAfterReadFallbackUnreserved(current: ChunkBuffer, size: Int, overrun: Int) {\n        // if we have a chunk with no end reservation\n        // we can split it into two to fix it\n\n        val chunk1 = pool.borrow()\n        val chunk2 = pool.borrow()\n\n        chunk1.reserveEndGap(Buffer.ReservedSize)\n        chunk2.reserveEndGap(Buffer.ReservedSize)\n        chunk1.next = chunk2\n        chunk2.next = current.cleanNext()\n\n        chunk1.writeBufferAppend(current, size - overrun)\n        chunk2.writeBufferAppend(current, overrun)\n\n        this._head = chunk1\n        this.tailRemaining = chunk2.remainingAll()\n    }\n\n    private tailrec fun ensureNext(current: ChunkBuffer, empty: ChunkBuffer): ChunkBuffer? {\n        if (current === empty) {\n            return doFill()\n        }\n\n        val next = current.cleanNext()\n        current.release(pool)\n\n        return when {\n            next == null -> {\n                this._head = empty\n                this.tailRemaining = 0L\n                ensureNext(empty, empty)\n            }\n            next.canRead() -> {\n                _head = next\n                tailRemaining -= next.readRemaining\n                next\n            }\n            else -> ensureNext(next, empty)\n        }\n    }\n\n    /**\n     * Reads the next chunk suitable for reading or `null` if no more chunks available. It is also allowed\n     * to return a chain of chunks linked through [ChunkBuffer.next]. The last chunk should have `null` next reference.\n     * Could rethrow exceptions from the underlying source.\n     */\n    protected open fun fill(): ChunkBuffer? {\n        val buffer = pool.borrow()\n        try {\n            buffer.reserveEndGap(Buffer.ReservedSize)\n            val copied = fill(buffer.memory, buffer.writePosition, buffer.writeRemaining)\n\n            if (copied == 0) {\n                noMoreChunksAvailable = true\n\n                if (!buffer.canRead()) {\n                    buffer.release(pool)\n                    return null\n                }\n            }\n\n            buffer.commitWritten(copied)\n\n            return buffer\n        } catch (t: Throwable) {\n            buffer.release(pool)\n            throw t\n        }\n    }\n\n    protected final fun markNoMoreChunksAvailable() {\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n    }\n\n    /**\n     * see [prefetch] for similar logic\n     */\n    private final fun doFill(): ChunkBuffer? {\n        if (noMoreChunksAvailable) return null\n        val chunk = fill()\n        if (chunk == null) {\n            noMoreChunksAvailable = true\n            return null\n        }\n        appendView(chunk)\n        return chunk\n    }\n\n    private final fun appendView(chunk: ChunkBuffer) {\n        val tail = _head.findTail()\n        if (tail === ChunkBuffer.Empty) {\n            _head = chunk\n            require(tailRemaining == 0L) {\n                throw IllegalStateException(\"It should be no tail remaining bytes if current tail is EmptyBuffer\")\n            }\n            tailRemaining = chunk.next?.remainingAll() ?: 0L\n        } else {\n            tail.next = chunk\n            tailRemaining += chunk.remainingAll()\n        }\n    }\n\n    @PublishedApi\n    internal fun prepareRead(minSize: Int): ChunkBuffer? {\n        val head = head\n        if (headEndExclusive - headPosition >= minSize) return head\n        return prepareReadLoop(minSize, head)\n    }\n\n    @PublishedApi\n    internal final fun prepareRead(minSize: Int, head: ChunkBuffer): ChunkBuffer? {\n        if (headEndExclusive - headPosition >= minSize) return head\n        return prepareReadLoop(minSize, head)\n    }\n\n    private tailrec fun prepareReadLoop(minSize: Int, head: ChunkBuffer): ChunkBuffer? {\n        val headSize = headRemaining\n        if (headSize >= minSize) return head\n\n        val next = head.next ?: doFill() ?: return null\n\n        if (headSize == 0) {\n            if (head !== ChunkBuffer.Empty) {\n                releaseHead(head)\n            }\n\n            return prepareReadLoop(minSize, next)\n        } else {\n            val desiredExtraBytes = minSize - headSize\n            val copied = head.writeBufferAppend(next, desiredExtraBytes)\n            headEndExclusive = head.writePosition\n            tailRemaining -= copied\n            if (!next.canRead()) {\n                head.next = null\n                head.next = next.cleanNext()\n                next.release(pool)\n            } else {\n                next.reserveStartGap(copied)\n            }\n        }\n\n        if (head.readRemaining >= minSize) return head\n        if (minSize > Buffer.ReservedSize) minSizeIsTooBig(minSize)\n\n        return prepareReadLoop(minSize, head)\n    }\n\n    private fun minSizeIsTooBig(minSize: Int): Nothing {\n        throw IllegalStateException(\"minSize of $minSize is too big (should be less than ${Buffer.ReservedSize})\")\n    }\n\n    private fun afterRead(head: ChunkBuffer) {\n        if (head.readRemaining == 0) {\n            releaseHead(head)\n        }\n    }\n\n    internal final fun releaseHead(head: ChunkBuffer): ChunkBuffer {\n        val next = head.cleanNext() ?: ChunkBuffer.Empty\n        this._head = next\n        this.tailRemaining -= next.readRemaining\n        head.release(pool)\n\n        return next\n    }\n\n    public companion object\n}\n","package io.ktor.utils.io.core\n\nimport kotlin.contracts.*\n\n@PublishedApi\ninternal inline fun AbstractInput.read(n: Int = 1, block: (Buffer) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val buffer = prepareRead(n) ?: prematureEndOfStream(n)\n    val positionBefore = buffer.readPosition\n    try {\n        block(buffer)\n    } finally {\n        val positionAfter = buffer.readPosition\n        if (positionAfter < positionBefore) {\n            throw IllegalStateException(\"Buffer's position shouldn't be rewinded\")\n        }\n        if (positionAfter == buffer.writePosition) {\n            ensureNext(buffer)\n        } else {\n            headPosition = positionAfter\n        }\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.bits.get\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.jvm.JvmName\n\n/**\n * Usually shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\npublic expect interface Input : Closeable {\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var byteOrder: ByteOrder\n\n    /**\n     * It is `true` when it is known that no more bytes will be available. When it is `false` then this means that\n     * it is not known yet or there are available bytes.\n     * Please note that `false` value doesn't guarantee that there are available bytes so `readByte()` may fail.\n     */\n    public val endOfInput: Boolean\n\n    /**\n     * Read the next upcoming byte\n     * @throws EOFException if no more bytes available.\n     */\n    public fun readByte(): Byte\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    public fun tryPeek(): Int\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source reading that may lead to blocking I/O.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [endOfInput].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    public fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long = 0,\n        min: Long = 1,\n        max: Long = Long.MAX_VALUE\n    ): Long\n\n    /**\n     * Discard at most [n] bytes\n     */\n    public fun discard(n: Long): Long\n\n    /**\n     * Close input including the underlying source. All pending bytes will be discarded.\n     * It is not recommended to invoke it with read operations in-progress concurrently.\n     */\n    override fun close()\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * The underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available.\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    public fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readShort(): Short {\n        return readShort()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readInt(): Int {\n        return readInt()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readLong(): Long {\n        return readLong()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFloat(): Float {\n        return readFloat()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readDouble(): Double {\n        return readDouble()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: IntArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: LongArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: IoBuffer, length: Int) {\n        readFully(dst, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return readAvailable(dst, length)\n    }\n}\n\n/**\n * Discard all remaining bytes.\n * @return number of bytes were discarded\n */\npublic fun Input.discard(): Long {\n    return discard(Long.MAX_VALUE)\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes in the input to be discarded.\n */\npublic fun Input.discardExact(n: Long) {\n    val discarded = discard(n)\n    if (discarded != n) {\n        throw IllegalStateException(\"Only $discarded bytes were discarded of $n requested\")\n    }\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes in the input to be discarded.\n */\npublic fun Input.discardExact(n: Int) {\n    discardExact(n.toLong())\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return `false`\n * [block] function returns `true` to request more chunks or `false` to stop loop\n *\n * It is not guaranteed that every chunk will have fixed size but it will be never empty.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@DangerousInternalIoApi\npublic inline fun Input.takeWhile(block: (Buffer) -> Boolean) {\n    var release = true\n    var current = prepareReadFirstHead(1) ?: return\n\n    try {\n        do {\n            if (!block(current)) {\n                break\n            }\n            release = false\n            val next = prepareReadNextHead(current) ?: break\n            current = next\n            release = true\n        } while (true)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return zero\n * [block] function returns number of bytes required to read next primitive and shouldn't require too many bytes at once\n * otherwise it could fail with an exception.\n * It is not guaranteed that every chunk will have fixed size but it will be always at least requested bytes length.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@DangerousInternalIoApi\npublic inline fun Input.takeWhileSize(initialSize: Int = 1, block: (Buffer) -> Int) {\n    var release = true\n    var current = prepareReadFirstHead(initialSize) ?: return\n    var size = initialSize\n\n    try {\n        do {\n            val before = current.readRemaining\n            val after: Int\n\n            if (before >= size) {\n                try {\n                    size = block(current)\n                } finally {\n                    after = current.readRemaining\n                }\n            } else {\n                after = before\n            }\n\n            release = false\n\n            val next = when {\n                after == 0 -> prepareReadNextHead(current)\n                after < size || current.endGap < Buffer.ReservedSize -> {\n                    completeReadHead(current)\n                    prepareReadFirstHead(size)\n                }\n                else -> current\n            }\n\n            if (next == null) {\n                break\n            }\n\n            current = next\n            release = true\n        } while (size > 0)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n@ExperimentalIoApi\npublic fun Input.peekCharUtf8(): Char {\n    val rc = tryPeek()\n    if (rc and 0x80 == 0) return rc.toChar()\n    if (rc == -1) throw EOFException(\"Failed to peek a char: end of input\")\n\n    return peekCharUtf8Impl(rc)\n}\n\n/**\n * For every byte from this input invokes [block] function giving it as parameter.\n */\n@ExperimentalIoApi\npublic inline fun Input.forEach(block: (Byte) -> Unit) {\n    takeWhile { buffer ->\n        buffer.forEach(block)\n        true\n    }\n}\n\nprivate fun Input.peekCharUtf8Impl(first: Int): Char {\n    var rc = '?'\n    var found = false\n\n    takeWhileSize(byteCountUtf8(first)) {\n        it.decodeUTF8 { ch ->\n            found = true\n            rc = ch\n            false\n        }\n    }\n\n    if (!found) {\n        throw MalformedUTF8InputException(\"No UTF-8 character found\")\n    }\n\n    return rc\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readAvailable(dst: IoBuffer, size: Int = dst.writeRemaining): Int = readAvailable(dst, size)\n\n@JvmName(\"readAvailable\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readAvailableOld(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readFully(dst: IoBuffer, size: Int = dst.writeRemaining): Unit = readFully(dst, size)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n","package io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\n\ninternal inline fun Buffer.decodeASCII(consumer: (Char) -> Boolean): Boolean {\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            val codepoint = memory[index].toInt() and 0xff\n            if (codepoint and 0x80 == 0x80 || !consumer(codepoint.toChar())) {\n                discardExact(index - start)\n                return false\n            }\n        }\n\n        endExclusive - start\n    }\n\n    return true\n}\n\n@DangerousInternalIoApi\npublic suspend fun decodeUTF8LineLoopSuspend(\n    out: Appendable,\n    limit: Int,\n    nextChunk: suspend (Int) -> AbstractInput?\n): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    while (!end && size != 0) {\n        val chunk = nextChunk(size) ?: break\n        chunk.takeWhileSize { buffer ->\n            var skip = 0\n            size = buffer.decodeUTF8 { ch ->\n                when (ch) {\n                    '\\r' -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n                        cr = true\n                        true\n                    }\n                    '\\n' -> {\n                        end = true\n                        skip = 1\n                        false\n                    }\n                    else -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n\n                        if (decoded == limit) {\n                            throw TooLongLineException(\"Too many characters in line: limit $limit exceeded\")\n                        }\n                        decoded++\n                        out.append(ch)\n                        true\n                    }\n                }\n            }\n\n            if (skip > 0) {\n                buffer.discardExact(skip)\n            }\n\n            size = if (end) 0 else size.coerceAtLeast(1)\n\n            size\n        }\n    }\n\n    if (size > 1) prematureEndOfStreamUtf(size)\n    if (cr) {\n        end = true\n    }\n\n    return decoded > 0 || end\n}\n\nprivate fun prematureEndOfStreamUtf(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes to decode UTF-8 char\")\n\n@DangerousInternalIoApi\ninternal fun byteCountUtf8(firstByte: Int): Int {\n    var byteCount = 0\n    var mask = 0x80\n    var value = firstByte\n\n    for (i in 1..6) {\n        if (value and mask != 0) {\n            value = value and mask.inv()\n            mask = mask shr 1\n            byteCount++\n        } else {\n            break\n        }\n    }\n\n    return byteCount\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic inline fun IoBuffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    return (this as Buffer).decodeUTF8(consumer)\n}\n\n/**\n * Decodes all the bytes to utf8 applying every character on [consumer] until or consumer return `false`.\n * If a consumer returned false then a character will be pushed back (including all surrogates will be pushed back as well)\n * and [decodeUTF8] returns -1\n * @return number of bytes required to decode incomplete utf8 character or 0 if all bytes were processed\n * or -1 if consumer rejected loop\n */\n@DangerousInternalIoApi\npublic inline fun Buffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    var byteCount = 0\n    var value = 0\n    var lastByteCount = 0\n\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            val v = memory[index].toInt() and 0xff\n            when {\n                v and 0x80 == 0 -> {\n                    if (byteCount != 0) malformedByteCount(byteCount)\n                    if (!consumer(v.toChar())) {\n                        discardExact(index - start)\n                        return -1\n                    }\n                }\n                byteCount == 0 -> {\n                    // first unicode byte\n\n                    var mask = 0x80\n                    value = v\n\n                    for (i in 1..6) { // TODO do we support 6 bytes unicode?\n                        if (value and mask != 0) {\n                            value = value and mask.inv()\n                            mask = mask shr 1\n                            byteCount++\n                        } else {\n                            break\n                        }\n                    }\n\n                    lastByteCount = byteCount\n                    byteCount--\n\n                    if (lastByteCount > endExclusive - index) {\n                        discardExact(index - start)\n                        return lastByteCount\n                    }\n                }\n                else -> {\n                    // trailing unicode byte\n                    value = (value shl 6) or (v and 0x7f)\n                    byteCount--\n\n                    if (byteCount == 0) {\n                        if (isBmpCodePoint(value)) {\n                            if (!consumer(value.toChar())) {\n                                discardExact(index - start - lastByteCount + 1)\n                                return -1\n                            }\n                        } else if (!isValidCodePoint(value)) {\n                            malformedCodePoint(value)\n                        } else {\n                            if (!consumer(highSurrogate(value).toChar()) ||\n                                !consumer(lowSurrogate(value).toChar())\n                            ) {\n                                discardExact(index - start - lastByteCount + 1)\n                                return -1\n                            }\n                        }\n\n                        value = 0\n                    }\n                }\n            }\n        }\n\n        endExclusive - start\n    }\n\n    return 0\n}\n\n@Suppress(\"RedundantModalityModifier\")\ninternal class CharArraySequence(\n    private val array: CharArray,\n    private val offset: Int,\n    final override val length: Int\n) : CharSequence {\n    final override fun get(index: Int): Char {\n        if (index >= length) {\n            indexOutOfBounds(index)\n        }\n        return array[index + offset]\n    }\n\n    final override fun subSequence(startIndex: Int, endIndex: Int): CharSequence {\n        require(startIndex >= 0) { \"startIndex shouldn't be negative: $startIndex\" }\n        require(startIndex <= length) { \"startIndex is too large: $startIndex > $length\" }\n        require(startIndex + endIndex <= length) { \"endIndex is too large: $endIndex > $length\" }\n        require(endIndex >= startIndex) { \"endIndex should be greater or equal to startIndex: $startIndex > $endIndex\" }\n\n        return CharArraySequence(array, offset + startIndex, endIndex - startIndex)\n    }\n\n    private fun indexOutOfBounds(index: Int): Nothing {\n        throw IndexOutOfBoundsException(\"String index out of bounds: $index > $length\")\n    }\n}\n\n@Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\")\ninternal inline class EncodeResult(val value: Int) {\n    constructor(characters: UShort, bytes: UShort) : this(characters.toInt() shl 16 or bytes.toInt())\n\n    inline val characters: UShort get() = value.highShort.toUShort()\n    inline val bytes: UShort get() = value.lowShort.toUShort()\n\n    inline operator fun component1(): UShort = characters\n    inline operator fun component2(): UShort = bytes\n}\n\ninternal fun Memory.encodeUTF8(text: CharSequence, from: Int, to: Int, dstOffset: Int, dstLimit: Int): EncodeResult {\n    // encode single-byte characters\n    val lastCharIndex = minOf(to, from + UShort.MAX_VALUE.toInt())\n    val resultLimit = dstLimit.coerceAtMost(UShort.MAX_VALUE.toInt())\n    var resultPosition = dstOffset\n    var index = from\n\n    do {\n        if (resultPosition >= resultLimit || index >= lastCharIndex) {\n            return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n        }\n\n        val character = text[index++].toInt() and 0xffff\n        if (character and 0xff80 == 0) {\n            storeAt(resultPosition++, character.toByte())\n        } else {\n            break\n        }\n    } while (true)\n\n    index--\n    return encodeUTF8Stage1(text, index, lastCharIndex, from, resultPosition, resultLimit, dstOffset)\n}\n\n/**\n * Encode UTF-8 multibytes characters when we for sure have enough free space\n */\nprivate fun Memory.encodeUTF8Stage1(\n    text: CharSequence,\n    index1: Int,\n    lastCharIndex: Int,\n    from: Int,\n    resultPosition1: Int,\n    resultLimit: Int,\n    dstOffset: Int\n): EncodeResult {\n    var index = index1\n    var resultPosition: Int = resultPosition1\n    val stage1Limit = resultLimit - 3\n\n    do {\n        val freeSpace = stage1Limit - resultPosition\n        if (freeSpace <= 0 || index >= lastCharIndex) {\n            break\n        }\n\n        val character = text[index++]\n        val codepoint = when {\n            character.isHighSurrogate() -> {\n                if (index == lastCharIndex || !text[index].isLowSurrogate()) {\n                    63\n                } else {\n                    codePoint(character, text[index++])\n                }\n            }\n            else -> character.toInt()\n        }\n        val size = putUtf8Char(resultPosition, codepoint)\n\n        resultPosition += size\n    } while (true)\n\n    if (resultPosition == stage1Limit) {\n        return encodeUTF8Stage2(text, index, lastCharIndex, from, resultPosition, resultLimit, dstOffset)\n    }\n\n    return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n}\n\nprivate fun Memory.encodeUTF8Stage2(\n    text: CharSequence,\n    index1: Int,\n    lastCharIndex: Int,\n    from: Int,\n    resultPosition1: Int,\n    resultLimit: Int,\n    dstOffset: Int\n): EncodeResult {\n    var index = index1\n    var resultPosition: Int = resultPosition1\n\n    do {\n        val freeSpace = resultLimit - resultPosition\n        if (freeSpace <= 0 || index >= lastCharIndex) {\n            break\n        }\n\n        val character = text[index++]\n        val codepoint = when {\n            !character.isHighSurrogate() -> character.toInt()\n            else -> {\n                if (index == lastCharIndex || !text[index].isLowSurrogate()) {\n                    63\n                } else {\n                    codePoint(character, text[index++])\n                }\n            }\n        }\n        if (charactersSize(codepoint) > freeSpace) {\n            index--\n            break\n        }\n        val size = putUtf8Char(resultPosition, codepoint)\n        resultPosition += size\n    } while (true)\n\n    return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun charactersSize(v: Int) = when {\n    v in 1..0x7f -> 1\n    v in 0x80..0x7ff -> 2\n    v in 0x800..0xffff -> 3\n    v in 0x10000..0x10ffff -> 4\n    else -> malformedCodePoint(v)\n}\n\n// TODO optimize it, now we are simply do naive encoding here\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Memory.putUtf8Char(offset: Int, v: Int): Int = when {\n    v in 0..0x7f -> {\n        storeAt(offset, v.toByte())\n        1\n    }\n    v in 0x80..0x7ff -> {\n        this[offset] = (0xc0 or ((v shr 6) and 0x1f)).toByte()\n        this[offset + 1] = (0x80 or (v and 0x3f)).toByte()\n        2\n    }\n    v in 0x800..0xffff -> {\n        this[offset] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n        this[offset + 1] = (0x80 or ((v shr 6) and 0x3f)).toByte()\n        this[offset + 2] = (0x80 or (v and 0x3f)).toByte()\n        3\n    }\n    v in 0x10000..0x10ffff -> {\n        this[offset] = (0xf0 or ((v shr 18) and 0x07)).toByte() // 3 bits\n        this[offset + 1] = (0x80 or ((v shr 12) and 0x3f)).toByte() // 6 bits\n        this[offset + 2] = (0x80 or ((v shr 6) and 0x3f)).toByte() // 6 bits\n        this[offset + 3] = (0x80 or (v and 0x3f)).toByte() // 6 bits\n        4\n    }\n    else -> malformedCodePoint(v)\n}\n\n@PublishedApi\ninternal fun malformedByteCount(byteCount: Int): Nothing =\n    throw MalformedUTF8InputException(\"Expected $byteCount more character bytes\")\n\n@PublishedApi\ninternal fun malformedCodePoint(value: Int): Nothing =\n    throw IllegalArgumentException(\"Malformed code-point $value found\")\n\nprivate const val MaxCodePoint = 0x10ffff\nprivate const val MinLowSurrogate = 0xdc00\nprivate const val MinHighSurrogate = 0xd800\nprivate const val MinSupplementary = 0x10000\nprivate const val HighSurrogateMagic = MinHighSurrogate - (MinSupplementary ushr 10)\n\n@PublishedApi\ninternal fun isBmpCodePoint(cp: Int): Boolean = cp ushr 16 == 0\n\n@PublishedApi\ninternal fun isValidCodePoint(codePoint: Int): Boolean = codePoint <= MaxCodePoint\n\n@PublishedApi\ninternal fun lowSurrogate(cp: Int): Int = (cp and 0x3ff) + MinLowSurrogate\n\n@PublishedApi\ninternal fun highSurrogate(cp: Int): Int = (cp ushr 10) + HighSurrogateMagic\n\ninternal fun codePoint(high: Char, low: Char): Int {\n//    check(high.isHighSurrogate())\n//    check(low.isLowSurrogate())\n\n    val highValue = high.toInt() - HighSurrogateMagic\n    val lowValue = low.toInt() - MinLowSurrogate\n\n    return highValue shl 10 or lowValue\n}\n\npublic class MalformedUTF8InputException(message: String) : Exception(message)\n","@file:Suppress(\"LocalVariableName\", \"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * The default [Output] implementation.\n * @see flush\n * @see closeDestination\n */\n@ExperimentalIoApi\n@Deprecated(\n    \"AbstractOutput is deprecated and will be merged with Input in 2.0.0\",\n    ReplaceWith(\"Output\"),\n    DeprecationLevel.WARNING\n)\npublic abstract class AbstractOutput\ninternal constructor(\n    private val headerSizeHint: Int,\n    protected val pool: ObjectPool<ChunkBuffer>\n) : Appendable, Output {\n    public constructor(pool: ObjectPool<ChunkBuffer>) : this(0, pool)\n\n    public constructor() : this(ChunkBuffer.Pool)\n\n    /**\n     * An implementation should write [source] to the destination exactly [length] bytes.\n     * It should never capture the [source] instance\n     * longer than this method execution since it may be disposed after return.\n     */\n    protected abstract fun flush(source: Memory, offset: Int, length: Int)\n\n    /**\n     * An implementation should only close the destination.\n     */\n    protected abstract fun closeDestination()\n\n    private val state = AbstractOutputSharedState()\n\n    private var _head: ChunkBuffer?\n        get() = state.head\n        set(value) {\n            state.head = value\n        }\n\n    private var _tail: ChunkBuffer?\n        get() = state.tail\n        set(value) {\n            state.tail = value\n        }\n\n    internal val head: ChunkBuffer\n        get() = _head ?: ChunkBuffer.Empty\n\n    @PublishedApi\n    @Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.HIDDEN)\n    internal val tail: ChunkBuffer\n        get() {\n            return prepareWriteHead(1)\n        }\n\n    @Deprecated(\"Will be removed. Override flush(buffer) properly.\", level = DeprecationLevel.ERROR)\n    protected var currentTail: ChunkBuffer\n        get() = prepareWriteHead(1)\n        set(newValue) {\n            appendChain(newValue)\n        }\n\n    internal var tailMemory: Memory\n        get() = state.tailMemory\n        set(value) {\n            state.tailMemory = value\n        }\n\n    internal var tailPosition\n        get() = state.tailPosition\n        set(value) {\n            state.tailPosition = value\n        }\n\n    internal var tailEndExclusive\n        get() = state.tailEndExclusive\n        private set(value) {\n            state.tailEndExclusive = value\n        }\n\n    private var tailInitialPosition\n        get() = state.tailInitialPosition\n        set(value) {\n            state.tailInitialPosition = value\n        }\n\n    /**\n     * Number of bytes buffered in the chain except the tail chunk\n     */\n    private var chainedSize: Int\n        get() = state.chainedSize\n        set(value) {\n            state.chainedSize = value\n        }\n\n    internal inline val tailRemaining: Int get() = tailEndExclusive - tailPosition\n\n    /**\n     * Number of bytes currently buffered (pending).\n     */\n    protected final var _size: Int\n        get() = chainedSize + (tailPosition - tailInitialPosition)\n        @Deprecated(\"There is no need to update/reset this value anymore.\")\n        set(_) {\n        }\n\n    /**\n     * Byte order (Endianness) to be used by future write functions calls on this builder instance. Doesn't affect any\n     * previously written values.\n     * @default [ByteOrder.BIG_ENDIAN]\n     */\n    @Deprecated(\n        \"This is no longer supported. All operations are big endian by default. Use readXXXLittleEndian \" +\n            \"to read primitives in little endian\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n        set(value) {\n            field = value\n            if (value != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\n                    \"Only BIG_ENDIAN is supported. Use corresponding functions to read/write\" +\n                        \"in the little endian\"\n                )\n            }\n        }\n\n    final override fun flush() {\n        flushChain()\n    }\n\n    private fun flushChain() {\n        val oldTail = stealAll() ?: return\n\n        try {\n            oldTail.forEachChunk { chunk ->\n                flush(chunk.memory, chunk.readPosition, chunk.readRemaining)\n            }\n        } finally {\n            oldTail.releaseAll(pool)\n        }\n    }\n\n    /**\n     * Detach all chunks and cleanup all internal state so builder could be reusable again\n     * @return a chain of buffer views or `null` of it is empty\n     */\n    internal fun stealAll(): ChunkBuffer? {\n        val head = this._head ?: return null\n\n        _tail?.commitWrittenUntilIndex(tailPosition)\n\n        this._head = null\n        this._tail = null\n        tailPosition = 0\n        tailEndExclusive = 0\n        tailInitialPosition = 0\n        chainedSize = 0\n        tailMemory = Memory.Empty\n\n        return head\n    }\n\n    internal fun afterBytesStolen() {\n        val head = head\n        if (head !== ChunkBuffer.Empty) {\n            check(head.next == null)\n            head.resetForWrite()\n            head.reserveStartGap(headerSizeHint)\n            head.reserveEndGap(Buffer.ReservedSize)\n            tailPosition = head.writePosition\n            tailInitialPosition = tailPosition\n            tailEndExclusive = head.limit\n        }\n    }\n\n    internal final fun appendSingleChunk(buffer: ChunkBuffer) {\n        check(buffer.next == null) { \"It should be a single buffer chunk.\" }\n        appendChainImpl(buffer, buffer, 0)\n    }\n\n    internal final fun appendChain(head: ChunkBuffer) {\n        val tail = head.findTail()\n        val chainedSizeDelta = (head.remainingAll() - tail.readRemaining).toIntOrFail(\"total size increase\")\n        appendChainImpl(head, tail, chainedSizeDelta)\n    }\n\n    private fun appendNewChunk(): ChunkBuffer {\n        val new = pool.borrow()\n        new.reserveEndGap(Buffer.ReservedSize)\n\n        appendSingleChunk(new)\n\n        return new\n    }\n\n    private final fun appendChainImpl(head: ChunkBuffer, newTail: ChunkBuffer, chainedSizeDelta: Int) {\n        val _tail = _tail\n        if (_tail == null) {\n            _head = head\n            chainedSize = 0\n        } else {\n            _tail.next = head\n            val tailPosition = tailPosition\n            _tail.commitWrittenUntilIndex(tailPosition)\n            chainedSize += tailPosition - tailInitialPosition\n        }\n\n        this._tail = newTail\n        chainedSize += chainedSizeDelta\n        tailMemory = newTail.memory\n        tailPosition = newTail.writePosition\n        tailInitialPosition = newTail.readPosition\n        tailEndExclusive = newTail.limit\n    }\n\n    final override fun writeByte(v: Byte) {\n        val index = tailPosition\n        if (index < tailEndExclusive) {\n            tailPosition = index + 1\n            tailMemory[index] = v\n            return\n        }\n\n        return writeByteFallback(v)\n    }\n\n    private fun writeByteFallback(v: Byte) {\n        appendNewChunk().writeByte(v)\n        tailPosition++\n    }\n\n    /**\n     * Should flush and close the destination\n     */\n    final override fun close() {\n        try {\n            flush()\n        } finally {\n            closeDestination() // TODO check what should be done here\n        }\n    }\n\n    /**\n     * Append single UTF-8 character\n     */\n    override fun append(c: Char): AbstractOutput {\n        val tailPosition = tailPosition\n        if (tailEndExclusive - tailPosition >= 3) {\n            val size = tailMemory.putUtf8Char(tailPosition, c.toInt())\n            this.tailPosition = tailPosition + size\n            return this\n        }\n\n        appendCharFallback(c)\n        return this\n    }\n\n    private fun appendCharFallback(c: Char) {\n        write(3) { buffer ->\n            val size = buffer.memory.putUtf8Char(buffer.writePosition, c.toInt())\n            buffer.commitWritten(size)\n            size\n        }\n    }\n\n    override fun append(csq: CharSequence?): AbstractOutput {\n        if (csq == null) {\n            append(\"null\", 0, 4)\n        } else {\n            append(csq, 0, csq.length)\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): AbstractOutput {\n        if (csq == null) {\n            return append(\"null\", start, end)\n        }\n\n        writeText(csq, start, end, Charsets.UTF_8)\n\n        return this\n    }\n\n    /**\n     * Writes another packet to the end. Please note that the instance [p] gets consumed so you don't need to release it\n     */\n    public fun writePacket(p: ByteReadPacket) {\n        val foreignStolen = p.stealAll()\n        if (foreignStolen == null) {\n            p.release()\n            return\n        }\n\n        val _tail = _tail\n        if (_tail == null) {\n            appendChain(foreignStolen)\n            return\n        }\n\n        writePacketMerging(_tail, foreignStolen, p.pool)\n    }\n\n    /**\n     * Write chunk buffer to current [Output]. Assuming that chunk buffer is from current pool.\n     */\n    internal fun writeChunkBuffer(chunkBuffer: ChunkBuffer) {\n        val _tail = _tail\n        if (_tail == null) {\n            appendChain(chunkBuffer)\n            return\n        }\n\n        writePacketMerging(_tail, chunkBuffer, pool)\n    }\n\n    private fun writePacketMerging(tail: ChunkBuffer, foreignStolen: ChunkBuffer, pool: ObjectPool<ChunkBuffer>) {\n        tail.commitWrittenUntilIndex(tailPosition)\n\n        val lastSize = tail.readRemaining\n        val nextSize = foreignStolen.readRemaining\n\n        // at first we evaluate if it is reasonable to merge chunks\n        val maxCopySize = PACKET_MAX_COPY_SIZE\n        val appendSize = if (nextSize < maxCopySize && nextSize <= (tail.endGap + tail.writeRemaining)) {\n            nextSize\n        } else -1\n\n        val prependSize =\n            if (lastSize < maxCopySize && lastSize <= foreignStolen.startGap && foreignStolen.isExclusivelyOwned()) {\n                lastSize\n            } else -1\n\n        if (appendSize == -1 && prependSize == -1) {\n            // simply enqueue if there is no reason to merge\n            appendChain(foreignStolen)\n        } else if (prependSize == -1 || appendSize <= prependSize) {\n            // do append\n            tail.writeBufferAppend(foreignStolen, tail.writeRemaining + tail.endGap)\n            afterHeadWrite()\n            foreignStolen.cleanNext()?.let { next ->\n                appendChain(next)\n            }\n\n            foreignStolen.release(pool)\n        } else if (appendSize == -1 || prependSize < appendSize) {\n            writePacketSlowPrepend(foreignStolen, tail)\n        } else {\n            throw IllegalStateException(\"prep = $prependSize, app = $appendSize\")\n        }\n    }\n\n    /**\n     * Do prepend current [tail] to the beginning of [foreignStolen].\n     */\n    private fun writePacketSlowPrepend(foreignStolen: ChunkBuffer, tail: ChunkBuffer) {\n        foreignStolen.writeBufferPrepend(tail)\n\n        val _head = _head ?: error(\"head should't be null since it is already handled in the fast-path\")\n        if (_head === tail) {\n            this._head = foreignStolen\n        } else {\n            // we need to fix next reference of the previous chunk before the tail\n            // we have to traverse from the beginning to find it\n            var pre = _head\n            while (true) {\n                val next = pre.next!!\n                if (next === tail) break\n                pre = next\n            }\n\n            pre.next = foreignStolen\n        }\n\n        tail.release(pool)\n\n        this._tail = foreignStolen.findTail()\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    public fun writePacket(p: ByteReadPacket, n: Int) {\n        var remaining = n\n\n        while (remaining > 0) {\n            val headRemaining = p.headRemaining\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                appendSingleChunk(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining)\n                }\n                break\n            }\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    public fun writePacket(p: ByteReadPacket, n: Long) {\n        var remaining = n\n\n        while (remaining > 0L) {\n            val headRemaining = p.headRemaining.toLong()\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                appendSingleChunk(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining.toInt())\n                }\n                break\n            }\n        }\n    }\n\n    override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        writeText(csq, start, end, Charsets.UTF_8)\n        return this\n    }\n\n    private inline fun appendCharsTemplate(\n        start: Int,\n        end: Int,\n        block: Buffer.(index: Int) -> Int\n    ): Int {\n        var idx = start\n        if (idx >= end) return idx\n        idx = prepareWriteHead(1).block(idx)\n        afterHeadWrite()\n\n        while (idx < end) {\n            idx = appendNewChunk().block(idx)\n            afterHeadWrite()\n        }\n\n        return idx\n    }\n\n    @Deprecated(\"Use writeText instead\", ReplaceWith(\"writeText(s)\"))\n    public fun writeStringUtf8(s: String) {\n        writeText(s)\n    }\n\n    @Deprecated(\"Use writeText instead\", ReplaceWith(\"this.writeText(cs)\"))\n    public fun writeStringUtf8(cs: CharSequence) {\n        writeText(cs)\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Buffer.putUtf8Char(v: Int) = when {\n        v in 1..0x7f -> {\n            writeByte(v.toByte())\n            1\n        }\n        v > 0x7ff -> {\n            writeExact(3, \"3 bytes character\") { memory, offset ->\n                memory[offset] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n                memory[offset + 1] = (0x80 or ((v shr 6) and 0x3f)).toByte()\n                memory[offset + 2] = (0x80 or (v and 0x3f)).toByte()\n            }\n            3\n        }\n        else -> {\n            writeExact(2, \"2 bytes character\") { memory, offset ->\n                memory[offset] = (0xc0 or ((v shr 6) and 0x1f)).toByte()\n                memory[offset + 1] = (0x80 or (v and 0x3f)).toByte()\n            }\n            2\n        }\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    public final fun release() {\n        close()\n    }\n\n    @DangerousInternalIoApi\n    public fun prepareWriteHead(n: Int): ChunkBuffer {\n        if (tailRemaining >= n) {\n            _tail?.let {\n                it.commitWrittenUntilIndex(tailPosition)\n                return it\n            }\n        }\n        return appendNewChunk()\n    }\n\n    @DangerousInternalIoApi\n    public fun afterHeadWrite() {\n        _tail?.let { tailPosition = it.writePosition }\n    }\n\n    @PublishedApi\n    internal inline fun write(size: Int, block: (Buffer) -> Int): Int {\n        val buffer = prepareWriteHead(size)\n        try {\n            val result = block(buffer)\n            check(result >= 0) { \"The returned value shouldn't be negative\" }\n\n            return result\n        } finally {\n            afterHeadWrite()\n        }\n    }\n\n    @PublishedApi\n    @Deprecated(\"There is no need to do that anymore.\", level = DeprecationLevel.HIDDEN)\n    internal fun addSize(n: Int) {\n        check(n >= 0) { \"It should be non-negative size increment: $n\" }\n        check(n <= tailRemaining) { \"Unable to mark more bytes than available: $n > $tailRemaining\" }\n\n        // For binary compatibility we need to update pointers\n        tailPosition += n\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal open fun last(buffer: IoBuffer) {\n        appendSingleChunk(buffer as ChunkBuffer)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\n        \"Use appendNewChunk instead\",\n        replaceWith = ReplaceWith(\"appendNewChunk()\"),\n        level = DeprecationLevel.HIDDEN\n    )\n    public fun appendNewBuffer(): IoBuffer = appendNewChunk() as IoBuffer\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public open fun reset() {\n    }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.contracts.*\n\n/**\n * For every byte from this buffer invokes [block] function giving it as parameter.\n */\n@ExperimentalIoApi\npublic inline fun Buffer.forEach(block: (Byte) -> Unit) {\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            block(memory[index])\n        }\n        endExclusive - start\n    }\n}\n\n/**\n * Read an unsigned byte or fail if no bytes available for reading.\n */\npublic fun Buffer.readUByte(): UByte = readByte().toUByte()\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readUByte(): UByte = (this as Buffer).readUByte()\n\n/**\n * Write an unsigned byte or fail if not enough space available for writing.\n */\npublic fun Buffer.writeUByte(value: UByte) {\n    writeByte(value.toByte())\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic fun IoBuffer.writeUByte(value: UByte) {\n    (this as Buffer).writeUByte(value)\n}\n\n/**\n * Read a short integer or fail if no bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readShort(): Short = readExact(2, \"short integer\") { memory, offset ->\n    memory.loadShortAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readShort(): Short = (this as Buffer).readShort()\n\n/**\n * Read an unsigned short integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readUShort(): UShort = readExact(2, \"short unsigned integer\") { memory, offset ->\n    memory.loadUShortAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readUShort(): UShort = (this as Buffer).readUShort()\n\n/**\n * Read an integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readInt(): Int = readExact(4, \"regular integer\") { memory, offset ->\n    memory.loadIntAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readInt(): Int = (this as Buffer).readInt()\n\n/**\n * Read an unsigned integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readUInt(): UInt = readExact(4, \"regular unsigned integer\") { memory, offset ->\n    memory.loadUIntAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readUInt(): UInt = (this as Buffer).readUInt()\n\n/**\n * Read a long integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readLong(): Long = readExact(8, \"long integer\") { memory, offset ->\n    memory.loadLongAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readLong(): Long = (this as Buffer).readLong()\n\n/**\n * Read an unsigned long integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readULong(): ULong = readExact(8, \"long unsigned integer\") { memory, offset ->\n    memory.loadULongAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readULong(): ULong = (this as Buffer).readULong()\n\n/**\n * Read a floating point number or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readFloat(): Float = readExact(4, \"floating point number\") { memory, offset ->\n    memory.loadFloatAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readFloat(): Float = (this as Buffer).readFloat()\n\n/**\n * Read a floating point number or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readDouble(): Double = readExact(8, \"long floating point number\") { memory, offset ->\n    memory.loadDoubleAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readDouble(): Double = (this as Buffer).readDouble()\n\n/**\n * Write a short integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeShort(value: Short): Unit = writeExact(2, \"short integer\") { memory, offset ->\n    memory.storeShortAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeShort(value: Short): Unit = (this as Buffer).writeShort(value)\n\n/**\n * Write an unsigned short integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeUShort(value: UShort): Unit =\n    writeExact(2, \"short unsigned integer\") { memory, offset ->\n        memory.storeUShortAt(offset, value)\n    }\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeUShort(value: UShort): Unit = (this as Buffer).writeUShort(value)\n\n/**\n * Write an integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeInt(value: Int): Unit = writeExact(4, \"regular integer\") { memory, offset ->\n    memory.storeIntAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeInt(value: Int): Unit = (this as Buffer).writeInt(value)\n\n/**\n * Write an unsigned integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeUInt(value: UInt): Unit = writeExact(4, \"regular unsigned integer\") { memory, offset ->\n    memory.storeUIntAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeUInt(value: UInt): Unit = (this as Buffer).writeUInt(value)\n\n/**\n * Write a long integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeLong(value: Long): Unit = writeExact(8, \"long integer\") { memory, offset ->\n    memory.storeLongAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeLong(value: Long): Unit = (this as Buffer).writeLong(value)\n\n/**\n * Write an unsigned long integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeULong(value: ULong): Unit = writeExact(8, \"long unsigned integer\") { memory, offset ->\n    memory.storeULongAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeULong(value: ULong): Unit = (this as Buffer).writeULong(value)\n\n/**\n * Write a floating point number or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeFloat(value: Float): Unit = writeExact(4, \"floating point number\") { memory, offset ->\n    memory.storeFloatAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeFloat(value: Float): Unit = (this as Buffer).writeFloat(value)\n\n/**\n * Write a floating point number or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeDouble(value: Double): Unit =\n    writeExact(8, \"long floating point number\") { memory, offset ->\n        memory.storeDoubleAt(offset, value)\n    }\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeDouble(value: Double): Unit = (this as Buffer).writeDouble(value)\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n */\npublic fun Buffer.readFully(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length, \"byte array\") { memory, srcOffset ->\n        memory.loadByteArray(srcOffset, destination, offset, length)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readFully(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    (this as Buffer).readFully(destination, offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n */\npublic fun Buffer.readFully(destination: UByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asByteArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] bytes.\n * If less than [length] bytes available then less bytes will be copied and the corresponding number\n * will be returned as result.\n * @return number of bytes copied to the [destination] or `-1` if the buffer is empty\n */\npublic fun Buffer.readAvailable(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\npublic inline fun IoBuffer.readAvailable(\n    destination: ByteArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    return (this as Buffer).readAvailable(destination, offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] bytes.\n * If less than [length] bytes available then less bytes will be copied and the corresponding number\n * will be returned as result.\n * @return number of bytes copied to the [destination] or `-1` if the buffer is empty\n */\npublic fun Buffer.readAvailable(\n    destination: UByteArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    return readAvailable(destination.asByteArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified bytes [length].\n */\npublic fun Buffer.writeFully(source: ByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length, \"byte array\") { memory, dstOffset ->\n        memory.storeByteArray(dstOffset, source, offset, length)\n    }\n}\n\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\npublic inline fun IoBuffer.writeFully(source: ByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    (this as Buffer).writeFully(source, offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified bytes [length].\n */\npublic fun Buffer.writeFully(source: UByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asByteArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: ShortArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 2, \"short integers array\") { memory, srcOffset ->\n        memory.loadShortArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: UShortArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asShortArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: ShortArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 2, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: UShortArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    return readAvailable(destination.asShortArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 2, \"short integers array\") { memory, dstOffset ->\n        memory.storeShortArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asShortArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: IntArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 4, \"integers array\") { memory, srcOffset ->\n        memory.loadIntArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: UIntArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asIntArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: IntArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 4, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: UIntArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asIntArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 4, \"integers array\") { memory, dstOffset ->\n        memory.storeIntArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asIntArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: LongArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 8, \"long integers array\") { memory, srcOffset ->\n        memory.loadLongArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: ULongArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asLongArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: LongArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 8, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: ULongArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    return readAvailable(destination.asLongArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 8, \"long integers array\") { memory, dstOffset ->\n        memory.storeLongArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asLongArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: FloatArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 4, \"floating point numbers array\") { memory, srcOffset ->\n        memory.loadFloatArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: FloatArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 4, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 4, \"floating point numbers array\") { memory, dstOffset ->\n        memory.storeFloatArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: DoubleArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 8, \"floating point numbers array\") { memory, srcOffset ->\n        memory.loadDoubleArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: DoubleArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 8, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 8, \"floating point numbers array\") { memory, dstOffset ->\n        memory.storeDoubleArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Read at most [length] bytes from this buffer to the [dst] buffer.\n * @return number of bytes copied\n */\npublic fun Buffer.readFully(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    require(length >= 0)\n    require(length <= dst.writeRemaining)\n\n    readExact(length, \"buffer content\") { memory, offset ->\n        memory.copyTo(dst.memory, offset, length, dst.writePosition)\n        dst.commitWritten(length)\n    }\n\n    return length\n}\n\n/**\n * Read at most [length] available bytes to the [dst] buffer or `-1` if no bytes available for read.\n * @return number of bytes copied or `-1` if empty\n */\npublic fun Buffer.readAvailable(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    if (!canRead()) return -1\n\n    val readSize = minOf(dst.writeRemaining, readRemaining, length)\n\n    readExact(readSize, \"buffer content\") { memory, offset ->\n        memory.copyTo(dst.memory, offset, readSize, dst.writePosition)\n        dst.commitWritten(readSize)\n    }\n\n    return readSize\n}\n\n/**\n * Write all readable bytes from [src] to this buffer. Fails if not enough space available to write all bytes.\n */\npublic fun Buffer.writeFully(src: Buffer) {\n    val length = src.readRemaining\n\n    writeExact(length, \"buffer readable content\") { memory, offset ->\n        src.memory.copyTo(memory, src.readPosition, length, offset)\n        src.discardExact(length)\n    }\n}\n\n/**\n * Write at most [length] readable bytes from [src] to this buffer.\n * Fails if not enough space available to write all bytes.\n */\npublic fun Buffer.writeFully(src: Buffer, length: Int) {\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(length <= src.readRemaining) {\n        \"length shouldn't be greater than the source read remaining: $length > ${src.readRemaining}\"\n    }\n    require(length <= writeRemaining) {\n        \"length shouldn't be greater than the destination write remaining space: $length > $writeRemaining\"\n    }\n\n    writeExact(length, \"buffer readable content\") { memory, offset ->\n        src.memory.copyTo(memory, src.readPosition, length, offset)\n        src.discardExact(length)\n    }\n}\n\n@PublishedApi\ninternal inline fun <R> Buffer.readExact(size: Int, name: String, block: (memory: Memory, offset: Int) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    var value: R\n\n    read { memory, start, endExclusive ->\n        io.ktor.utils.io.core.internal.require(endExclusive - start >= size) {\n            throw EOFException(\"Not enough bytes to read a $name of size $size.\")\n        }\n        value = block(memory, start)\n        size\n    }\n\n    return value\n}\n\n@PublishedApi\ninternal inline fun Buffer.writeExact(size: Int, name: String, block: (memory: Memory, offset: Int) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    write { memory, start, endExclusive ->\n        val writeRemaining = endExclusive - start\n        if (writeRemaining < size) {\n            throw InsufficientSpaceException(name, size, writeRemaining)\n        }\n        block(memory, start)\n        size\n    }\n}\n","package io.ktor.utils.io.core\n\n/**\n * Append at most [maxSize] bytes from the specified [other] buffer into this using the end gap reservation if required.\n * @return number of bytes copied\n * @throws IllegalArgumentException if not enough space including end gap\n */\ninternal fun Buffer.writeBufferAppend(other: Buffer, maxSize: Int): Int {\n    val size = minOf(other.readRemaining, maxSize)\n\n    if (writeRemaining <= size) {\n        writeBufferAppendUnreserve(size)\n    }\n\n    return write { dst, dstOffset, _ ->\n        other.read { src, srcOffset, _ ->\n            src.copyTo(dst, srcOffset, size, dstOffset)\n            size\n        }\n    }\n}\n\n/**\n * Prepend readable content of the specified [other] buffer to the beginning of this buffer using start gap reservation\n * if required.\n * @return number of bytes copied\n * @throws IllegalArgumentException if not enough space in the beginning to prepend bytes even with start gap\n */\ninternal fun Buffer.writeBufferPrepend(other: Buffer): Int {\n    val size = other.readRemaining\n    val readPosition = readPosition\n\n    if (readPosition < size) {\n        throw IllegalArgumentException(\"Not enough space in the beginning to prepend bytes\")\n    }\n\n    val newReadPosition = readPosition - size\n    other.memory.copyTo(memory, other.readPosition, size, newReadPosition)\n    other.discardExact(size)\n    releaseStartGap(newReadPosition)\n\n    return size\n}\n\nprivate fun Buffer.writeBufferAppendUnreserve(writeSize: Int) {\n    if (writeRemaining + endGap < writeSize) {\n        throw IllegalArgumentException(\"Can't append buffer: not enough free space at the end\")\n    }\n    val newWritePosition = writePosition + writeSize\n    val overrunSize = newWritePosition - limit\n\n    if (overrunSize > 0) {\n        releaseEndGap()\n    }\n}\n","@file:Suppress(\"DeprecatedCallableAddReplaceWith\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.core.internal.require\nimport io.ktor.utils.io.pool.*\n\n/**\n * Write byte [value] repeated the specified [times].\n */\npublic fun Buffer.fill(times: Int, value: Byte) {\n    require(times >= 0) { \"times shouldn't be negative: $times\" }\n    require(times <= writeRemaining) {\n        \"times shouldn't be greater than the write remaining space: $times > $writeRemaining\"\n    }\n\n    memory.fill(writePosition, times, value)\n    commitWritten(times)\n}\n\n/**\n * Write unsigned byte [value] repeated the specified [times].\n */\npublic fun Buffer.fill(times: Int, value: UByte) {\n    fill(times, value.toByte())\n}\n\n/**\n * Write byte [v] value repeated [n] times.\n */\n@Deprecated(\"Use fill with n with type Int\")\npublic fun Buffer.fill(n: Long, v: Byte) {\n    fill(n.toIntOrFail(\"n\"), v)\n}\n\n/**\n * Push back [n] bytes: only possible if there were at least [n] bytes read before this operation.\n */\n@Deprecated(\"Use rewind instead\", ReplaceWith(\"rewind(n)\"))\npublic fun Buffer.pushBack(n: Int): Unit = rewind(n)\n\n@Deprecated(\"Use duplicate instead\", ReplaceWith(\"duplicate()\"))\npublic fun Buffer.makeView(): Buffer = duplicate()\n\n@Deprecated(\"Use duplicate instead\", ReplaceWith(\"duplicate()\"))\npublic fun ChunkBuffer.makeView(): ChunkBuffer = duplicate()\n\n@Deprecated(\"Does nothing.\")\npublic fun Buffer.flush() {\n}\n\ninternal fun Buffer.appendChars(csq: CharArray, start: Int, end: Int): Int {\n    return appendChars(CharArraySequence(csq, 0, csq.size), start, end)\n}\n\ninternal fun Buffer.appendChars(csq: CharSequence, start: Int, end: Int): Int {\n    var charactersWritten: Int\n\n    write { dst, dstStart, dstEndExclusive ->\n        val result = dst.encodeUTF8(csq, start, end, dstStart, dstEndExclusive)\n        charactersWritten = result.characters.toInt()\n        result.bytes.toInt()\n    }\n\n    return start + charactersWritten\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(c: Char): Buffer {\n    write { memory, start, endExclusive ->\n        val size = memory.putUtf8Char(start, c.toInt())\n        when {\n            size > endExclusive - start -> appendFailed(1)\n            else -> size\n        }\n    }\n\n    return this\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(csq: CharSequence?): Buffer {\n    if (csq == null) {\n        return append(\"null\")\n    }\n\n    return append(csq, 0, csq.length)\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(csq: CharSequence?, start: Int, end: Int): Buffer = apply {\n    if (csq == null) {\n        return append(\"null\", start, end)\n    }\n\n    if (appendChars(csq, start, end) != end) {\n        appendFailed(end - start)\n    }\n}\n\nprivate fun appendFailed(length: Int): Nothing {\n    throw BufferLimitExceededException(\"Not enough free space available to write $length character(s).\")\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(csq: CharArray, start: Int, end: Int): Buffer {\n    return append(CharArraySequence(csq, 0, csq.size), start, end)\n}\n\n@Deprecated(\"This is no longer supported. Read from a packet instead.\")\npublic fun Buffer.readText(\n    decoder: CharsetDecoder,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int = Int.MAX_VALUE\n): Int {\n    return decoder.decodeBuffer(this, out, lastBuffer, max)\n}\n\n/**\n * releases buffer view and returns it to the [pool] if there are no more usages. Based on simple ref-counting so\n * it is very fragile.\n */\n@Suppress(\"DEPRECATION\")\npublic fun IoBuffer.release(pool: ObjectPool<IoBuffer>) {\n    // TODO ???\n    @Suppress(\"UNCHECKED_CAST\")\n    (this as ChunkBuffer).release(pool as ObjectPool<ChunkBuffer>)\n}\n\n/**\n * Peek the next unsigned byte or return `-1` if no more bytes available for reading. No bytes will be marked\n * as consumed in any case.\n * @see [Buffer.tryPeekByte]\n */\n@Deprecated(\"Use tryPeekByte instead\", replaceWith = ReplaceWith(\"tryPeekByte()\"))\npublic fun Buffer.tryPeek(): Int = tryPeekByte()\n\npublic fun Buffer.readFully(dst: Array<Byte>, offset: Int = 0, length: Int = dst.size - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        for (index in 0 until length) {\n            dst[index + offset] = memory[index + start]\n        }\n\n        length\n    }\n}\n\n@Deprecated(\n    \"This is no longer supported. All operations are big endian by default. Use readXXXLittleEndian \" +\n        \"to read primitives in little endian\",\n    level = DeprecationLevel.ERROR\n)\npublic var Buffer.byteOrder: ByteOrder\n    get() = ByteOrder.BIG_ENDIAN\n    set(newOrder) {\n        if (newOrder != ByteOrder.BIG_ENDIAN) throw UnsupportedOperationException(\"Only BIG_ENDIAN is supported\")\n    }\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.ChunkBuffer\nimport io.ktor.utils.io.pool.DefaultPool\nimport io.ktor.utils.io.pool.ObjectPool\nimport kotlin.native.concurrent.ThreadLocal\n\ninternal const val DEFAULT_BUFFER_SIZE: Int = 4096\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance of the specified [size] in bytes.\n * The provided instance shouldn't be captured and used outside of the [block] otherwise an undefined behaviour\n * may occur including crash and/or data corruption.\n */\n@ExperimentalIoApi\npublic inline fun <R> withBuffer(size: Int, block: Buffer.() -> R): R {\n    return with(Buffer(DefaultAllocator.alloc(size)), block)\n}\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance taken from the specified [pool].\n * Depending on the pool it may be safe or unsafe to capture and use the provided buffer outside of the [block].\n * Usually it is always recommended to NOT capture an instance outside.\n */\n@ExperimentalIoApi\npublic inline fun <R> withBuffer(pool: ObjectPool<Buffer>, block: Buffer.() -> R): R {\n    val instance = pool.borrow()\n    return try {\n        block(instance)\n    } finally {\n        pool.recycle(instance)\n    }\n}\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance taken from the specified [pool].\n * Depending on the pool it may be safe or unsafe to capture and use the provided buffer outside of the [block].\n * Usually it is always recommended to NOT capture an instance outside.\n * However since [ChunkBuffer] is reference counted, you can create a [Buffer.duplicate] (this is simply a view) and use\n * it outside of the [block] function but it is important to release the duplicate properly once not needed anymore\n * otherwise memory leak may occur on some platforms.\n */\ninternal inline fun <R> withChunkBuffer(pool: ObjectPool<ChunkBuffer>, block: ChunkBuffer.() -> R): R {\n    val instance = pool.borrow()\n    return try {\n        block(instance)\n    } finally {\n        instance.release(pool)\n    }\n}\n\n@ThreadLocal\n@Suppress(\"DEPRECATION\")\ninternal val DefaultChunkedBufferPool: ObjectPool<IoBuffer> = DefaultBufferPool()\n\n@Suppress(\"DEPRECATION\")\ninternal class DefaultBufferPool(\n    private val bufferSize: Int = DEFAULT_BUFFER_SIZE,\n    capacity: Int = 1000,\n    private val allocator: Allocator = DefaultAllocator\n) : DefaultPool<IoBuffer>(capacity) {\n\n    override fun produceInstance(): IoBuffer {\n        return IoBuffer(allocator.alloc(bufferSize), null, this)\n    }\n\n    override fun disposeInstance(instance: IoBuffer) {\n        allocator.free(instance.memory)\n        super.disposeInstance(instance)\n        instance.unlink()\n    }\n\n    override fun validateInstance(instance: IoBuffer) {\n        super.validateInstance(instance)\n\n        if (instance === IoBuffer.Empty) {\n            error(\"IoBuffer.Empty couldn't be recycled\")\n        }\n\n        check(instance !== IoBuffer.Empty) { \"Empty instance couldn't be recycled\" }\n        check(instance !== Buffer.Empty) { \"Empty instance couldn't be recycled\" }\n        check(instance !== ChunkBuffer.Empty) { \"Empty instance couldn't be recycled\" }\n\n        check(instance.referenceCount == 0) { \"Unable to clear buffer: it is still in use.\" }\n        check(instance.next == null) { \"Recycled instance shouldn't be a part of a chain.\" }\n        check(instance.origin == null) { \"Recycled instance shouldn't be a view or another buffer.\" }\n    }\n\n    override fun clearInstance(instance: IoBuffer): IoBuffer {\n        return super.clearInstance(instance).apply {\n            unpark()\n            reset()\n        }\n    }\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.core.internal.require\nimport io.ktor.utils.io.pool.*\nimport kotlin.Boolean\nimport kotlin.Char\nimport kotlin.CharSequence\nimport kotlin.Deprecated\nimport kotlin.DeprecationLevel\nimport kotlin.Int\nimport kotlin.PublishedApi\nimport kotlin.String\nimport kotlin.Suppress\nimport kotlin.jvm.*\n\n/**\n * A builder that provides ability to build byte packets with no knowledge of it's size.\n * Unlike Java's ByteArrayOutputStream it doesn't copy the whole content every time it's internal buffer overflows\n * but chunks buffers instead. Packet building via [build] function is O(1) operation and only does instantiate\n * a new [ByteReadPacket]. Once a byte packet has been built via [build] function call, the builder could be\n * reused again. You also can discard all written bytes via [reset] or [release]. Please note that an instance of\n * builder need to be terminated either via [build] function invocation or via [release] call otherwise it will\n * cause byte buffer leak so that may have performance impact.\n *\n * Byte packet builder is also an [Appendable] so it does append UTF-8 characters to a packet\n *\n * ```\n * buildPacket {\n *     listOf(1,2,3).joinTo(this, separator = \",\")\n * }\n * ```\n */\npublic class BytePacketBuilder(\n    private var headerSizeHint: Int = 0,\n    pool: ObjectPool<ChunkBuffer>\n) : @Suppress(\"DEPRECATION_ERROR\")\nBytePacketBuilderPlatformBase(pool) {\n\n    init {\n        require(headerSizeHint >= 0) { \"shouldn't be negative: headerSizeHint = $headerSizeHint\" }\n    }\n\n    /**\n     * Number of bytes written to the builder after the creation or the last reset.\n     */\n    public val size: Int\n        get() = _size\n\n    /**\n     * If no bytes were written or the builder has been reset.\n     */\n    public val isEmpty: Boolean\n        get() = _size == 0\n\n    /**\n     * If at least one byte was written after the creation or the last reset.\n     */\n    public val isNotEmpty: Boolean\n        get() = _size > 0\n\n    @PublishedApi\n    internal val _pool: ObjectPool<ChunkBuffer>\n        get() = pool\n\n    /**\n     * Does nothing for memory-backed output\n     */\n    final override fun closeDestination() {\n    }\n\n    /**\n     * Does nothing for memory-backed output\n     */\n    final override fun flush(source: Memory, offset: Int, length: Int) {\n    }\n\n    override fun append(c: Char): BytePacketBuilder {\n        return super.append(c) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?): BytePacketBuilder {\n        return super.append(csq) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): BytePacketBuilder {\n        return super.append(csq, start, end) as BytePacketBuilder\n    }\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    public fun appendOld(c: Char): BytePacketBuilderBase = append(c)\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    public fun appendOld(csq: CharSequence?): BytePacketBuilderBase = append(csq)\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    public fun appendOld(csq: CharSequence?, start: Int, end: Int): BytePacketBuilderBase = append(csq, start, end)\n\n    /**\n     * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n     * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n     * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n     * otherwise an unexpected behaviour may occur.\n     */\n    @Suppress(\"unused\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun <R> preview(block: (tmp: ByteReadPacket) -> R): R {\n        return preview(block)\n    }\n\n    /**\n     * Builds byte packet instance and resets builder's state to be able to build another one packet if needed\n     */\n    public fun build(): ByteReadPacket {\n        val size = size\n        val head = stealAll()\n\n        return when (head) {\n            null -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head, size.toLong(), pool)\n        }\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun reset() {\n        release()\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"unused\")\n    internal fun preview(): ByteReadPacket {\n        return preview()\n    }\n\n    override fun toString(): String {\n        return \"BytePacketBuilder($size bytes written)\"\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.contracts.*\n\n/**\n * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n * otherwise an unexpected behaviour may occur.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic inline fun <R> BytePacketBuilder.preview(block: (tmp: ByteReadPacket) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val packet = preview()\n    return try {\n        block(packet)\n    } finally {\n        packet.release()\n    }\n}\n\n@PublishedApi\ninternal fun BytePacketBuilder.preview(): ByteReadPacket {\n    val head = head\n    return when {\n        head === ChunkBuffer.Empty -> ByteReadPacket.Empty\n        else -> ByteReadPacket(head.copyAll(), _pool)\n    }\n}\n","@file:Suppress(\"RedundantModalityModifier\", \"FunctionName\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * Read-only immutable byte packet. Could be consumed only once however it does support [copy] that doesn't copy every byte\n * but creates a new view instead. Once packet created it should be either completely read (consumed) or released\n * via [release].\n */\npublic class ByteReadPacket internal constructor(\n    head: ChunkBuffer,\n    remaining: Long,\n    pool: ObjectPool<ChunkBuffer>\n) :\n    @Suppress(\"DEPRECATION_ERROR\")\n    ByteReadPacketPlatformBase(head, remaining, pool),\n    Input {\n    public constructor(head: ChunkBuffer, pool: ObjectPool<ChunkBuffer>) : this(head, head.remainingAll(), pool)\n\n    @Suppress(\"DEPRECATION\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(head: IoBuffer, pool: ObjectPool<ChunkBuffer>) : this(head, head.remainingAll(), pool)\n\n    init {\n        markNoMoreChunksAvailable()\n    }\n\n    /**\n     * Returns a copy of the packet. The original packet and the copy could be used concurrently. Both need to be\n     * either completely consumed or released via [release]\n     */\n    public final fun copy(): ByteReadPacket = ByteReadPacket(head.copyAll(), remaining, pool)\n\n    final override fun fill(): ChunkBuffer? = null\n\n    final override fun fill(destination: Memory, offset: Int, length: Int): Int {\n        return 0\n    }\n\n    final override fun closeSource() {\n    }\n\n    override fun toString(): String {\n        return \"ByteReadPacket($remaining bytes remaining)\"\n    }\n\n    public companion object {\n        public val Empty: ByteReadPacket = ByteReadPacket(ChunkBuffer.Empty, 0L, ChunkBuffer.EmptyPool)\n\n        @DangerousInternalIoApi\n        public val ReservedSize: Int\n            get() = Buffer.ReservedSize\n    }\n}\n\n@Suppress(\"DEPRECATION\")\n@DangerousInternalIoApi\n@Deprecated(\n    \"Will be removed in future releases.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"AbstractInput\", \"io.ktor.utils.io.core.AbstractInput\")\n)\npublic abstract class ByteReadPacketPlatformBase protected constructor(\n    head: ChunkBuffer,\n    remaining: Long,\n    pool: ObjectPool<ChunkBuffer>\n) : ByteReadPacketBase(head, remaining, pool) {\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(\n        head: IoBuffer,\n        remaining: Long,\n        pool: ObjectPool<ChunkBuffer>\n    ) : this(head as ChunkBuffer, remaining, pool)\n}\n\npublic expect fun ByteReadPacket(\n    array: ByteArray,\n    offset: Int = 0,\n    length: Int = array.size,\n    block: (ByteArray) -> Unit\n): ByteReadPacket\n\n@Suppress(\"NOTHING_TO_INLINE\")\npublic inline fun ByteReadPacket(array: ByteArray, offset: Int = 0, length: Int = array.size): ByteReadPacket {\n    return ByteReadPacket(array, offset, length) {}\n}\n","package io.ktor.utils.io.core\n\npublic expect interface Closeable {\n    public fun close()\n}\n\npublic inline fun <C : Closeable, R> C.use(block: (C) -> R): R {\n    var closed = false\n\n    return try {\n        block(this)\n    } catch (first: Throwable) {\n        try {\n            closed = true\n            close()\n        } catch (second: Throwable) {\n            first.addSuppressedInternal(second)\n        }\n\n        throw first\n    } finally {\n        if (!closed) {\n            close()\n        }\n    }\n}\n\n@PublishedApi\ninternal expect fun Throwable.addSuppressedInternal(other: Throwable)\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * Copy all bytes to the [output].\n * Depending on actual input and output implementation it could be zero-copy or copy byte per byte.\n * All regular types such as [ByteReadPacket], [BytePacketBuilder], [AbstractInput] and [AbstractOutput]\n * are always optimized so no bytes will be copied.\n */\npublic fun Input.copyTo(output: Output): Long {\n    if (this !is AbstractInput || output !is AbstractOutput) {\n        // slow-path\n        return copyToFallback(output)\n    }\n\n    var copied = 0L\n    do {\n        val head = stealAll()\n        if (head == null) {\n            if (prepareRead(1) == null) break\n            continue\n        }\n\n        copied += head.remainingAll()\n        output.appendChain(head)\n    } while (true)\n\n    return copied\n}\n\nprivate fun Input.copyToFallback(output: Output): Long {\n    val buffer = ChunkBuffer.Pool.borrow()\n    var copied = 0L\n\n    try {\n        do {\n            buffer.resetForWrite()\n            val rc = readAvailable(buffer)\n            if (rc == -1) break\n            copied += rc\n            output.writeFully(buffer)\n        } while (true)\n\n        return copied\n    } finally {\n        buffer.release(ChunkBuffer.Pool)\n    }\n}\n","// ktlint-disable filename\npackage io.ktor.utils.io.core\n\n/**\n * API marked with this annotation is experimental and could be changed\n */\n@Suppress(\"DEPRECATION\")\n@RequiresOptIn(level = RequiresOptIn.Level.WARNING)\n@Experimental(Experimental.Level.WARNING)\npublic annotation class ExperimentalIoApi\n","@file:Suppress(\"Duplicates\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\npublic fun Input.readShort(byteOrder: ByteOrder): Short =\n    readPrimitiveTemplate(byteOrder, { readShort() }, { reverseByteOrder() })\n\npublic fun Input.readInt(byteOrder: ByteOrder): Int =\n    readPrimitiveTemplate(byteOrder, { readInt() }, { reverseByteOrder() })\n\npublic fun Input.readLong(byteOrder: ByteOrder): Long =\n    readPrimitiveTemplate(byteOrder, { readLong() }, { reverseByteOrder() })\n\npublic fun Input.readFloat(byteOrder: ByteOrder): Float =\n    readPrimitiveTemplate(byteOrder, { readFloat() }, { reverseByteOrder() })\n\npublic fun Input.readDouble(byteOrder: ByteOrder): Double =\n    readPrimitiveTemplate(byteOrder, { readDouble() }, { reverseByteOrder() })\n\npublic fun Input.readShortLittleEndian(): Short = readPrimitiveTemplate({ readShort() }, { reverseByteOrder() })\n\npublic fun Input.readIntLittleEndian(): Int = readPrimitiveTemplate({ readInt() }, { reverseByteOrder() })\n\npublic fun Input.readLongLittleEndian(): Long = readPrimitiveTemplate({ readLong() }, { reverseByteOrder() })\n\npublic fun Input.readFloatLittleEndian(): Float = readPrimitiveTemplate({ readFloat() }, { reverseByteOrder() })\n\npublic fun Input.readDoubleLittleEndian(): Double = readPrimitiveTemplate({ readDouble() }, { reverseByteOrder() })\n\npublic fun Buffer.readShortLittleEndian(): Short = readPrimitiveTemplate({ readShort() }, { reverseByteOrder() })\n\npublic fun Buffer.readIntLittleEndian(): Int = readPrimitiveTemplate({ readInt() }, { reverseByteOrder() })\n\npublic fun Buffer.readLongLittleEndian(): Long = readPrimitiveTemplate({ readLong() }, { reverseByteOrder() })\n\npublic fun Buffer.readFloatLittleEndian(): Float = readPrimitiveTemplate({ readFloat() }, { reverseByteOrder() })\n\npublic fun Buffer.readDoubleLittleEndian(): Double = readPrimitiveTemplate({ readDouble() }, { reverseByteOrder() })\n\npublic fun Input.readFullyLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asShortArray(), offset, length)\n}\n\npublic fun Input.readFullyLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Input.readFullyLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asIntArray(), offset, length)\n}\n\npublic fun Input.readFullyLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Input.readFullyLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asLongArray(), offset, length)\n}\n\npublic fun Input.readFullyLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Input.readFullyLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Input.readFullyLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Input.readAvailableLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asShortArray(), offset, length)\n}\n\npublic fun Input.readAvailableLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\npublic fun Input.readAvailableLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asIntArray(), offset, length)\n}\n\npublic fun Input.readAvailableLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\npublic fun Input.readAvailableLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asLongArray(), offset, length)\n}\n\npublic fun Input.readAvailableLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\npublic fun Input.readAvailableLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\npublic fun Input.readAvailableLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\npublic fun Buffer.readFullyLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asShortArray(), offset, length)\n}\n\npublic fun Buffer.readFullyLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Buffer.readFullyLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asIntArray(), offset, length)\n}\n\npublic fun Buffer.readFullyLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Buffer.readFullyLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyLittleEndian(dst.asLongArray(), offset, length)\n}\n\npublic fun Buffer.readFullyLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Buffer.readFullyLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Buffer.readFullyLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst, offset, length)\n    val lastIndex = offset + length - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n}\n\npublic fun Buffer.readAvailableLittleEndian(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asShortArray(), offset, length)\n}\n\npublic fun Buffer.readAvailableLittleEndian(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    val lastIndex = offset + result - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n    return result\n}\n\npublic fun Buffer.readAvailableLittleEndian(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asIntArray(), offset, length)\n}\n\npublic fun Buffer.readAvailableLittleEndian(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    val lastIndex = offset + result - 1\n    for (index in offset..lastIndex) {\n        dst[index] = dst[index].reverseByteOrder()\n    }\n    return result\n}\n\npublic fun Buffer.readAvailableLittleEndian(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailableLittleEndian(dst.asLongArray(), offset, length)\n}\n\npublic fun Buffer.readAvailableLittleEndian(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\npublic fun Buffer.readAvailableLittleEndian(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\npublic fun Buffer.readAvailableLittleEndian(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    val result = readAvailable(dst, offset, length)\n    if (result > 0) {\n        val lastIndex = offset + result - 1\n        for (index in offset..lastIndex) {\n            dst[index] = dst[index].reverseByteOrder()\n        }\n    }\n    return result\n}\n\nprivate inline fun <T : Any> readPrimitiveTemplate(read: () -> T, reverse: T.() -> T): T {\n    return read().reverse()\n}\n\nprivate inline fun <T : Any> readPrimitiveTemplate(\n    byteOrder: ByteOrder,\n    read: () -> T,\n    reverse: T.() -> T\n): T {\n    return when (byteOrder) {\n        ByteOrder.BIG_ENDIAN -> read()\n        else -> read().reverse()\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.errors.checkPeekTo\n\n/**\n * Copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes then\n * it simply return number of available bytes with no exception so the returned value need\n * to be checked.\n * It is safe to specify `max > destination.writeRemaining` but\n * `min` shouldn't be bigger than the [destination] free space.\n * This function could trigger the underlying source reading that may lead to blocking I/O.\n * It is safe to specify too big [offset] so in this case this function will always return `0`.\n * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n * When `0` is returned with `offset = 0` then it makes sense to check [Input.endOfInput].\n *\n * @param destination to write bytes\n * @param offset to skip input\n * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n * @return number of bytes copied to the [destination] possibly `0`\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.peekTo(destination: IoBuffer, offset: Int = 0, min: Int = 1, max: Int = Int.MAX_VALUE): Int {\n    return peekTo(destination as Buffer, offset, min, max)\n}\n\n/**\n * Copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes then\n * it simply return number of available bytes with no exception so the returned value need\n * to be checked.\n * It is safe to specify `max > destination.writeRemaining` but\n * `min` shouldn't be bigger than the [destination] free space.\n * This function could trigger the underlying source reading that may lead to blocking I/O.\n * It is safe to specify too big [offset] so in this case this function will always return `0`.\n * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n * When `0` is returned with `offset = 0` then it makes sense to check [Input.endOfInput].\n *\n * @param destination to write bytes\n * @param offset to skip input\n * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n * @return number of bytes copied to the [destination] possibly `0`\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"Use peekTo(Memory) instead.\")\npublic fun Input.peekTo(destination: Buffer, offset: Int = 0, min: Int = 1, max: Int = Int.MAX_VALUE): Int {\n    checkPeekTo(destination, offset, min, max)\n\n    val copied = peekTo(\n        destination.memory,\n        destination.writePosition.toLong(),\n        offset.toLong(),\n        min.toLong(),\n        max.coerceAtMost(destination.writeRemaining).toLong()\n    ).toInt()\n\n    destination.commitWritten(copied)\n    return copied\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readShort(): Short {\n    return readPrimitive(2, { memory, index -> memory.loadShortAt(index) }, { readShortFallback() })\n}\n\nprivate fun Input.readShortFallback(): Short {\n    return readPrimitiveFallback(2) { it.readShort() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readInt(): Int {\n    return readPrimitive(4, { memory, index -> memory.loadIntAt(index) }, { readIntFallback() })\n}\n\nprivate fun Input.readIntFallback(): Int {\n    return readPrimitiveFallback(4) { it.readInt() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readLong(): Long {\n    return readPrimitive(8, { memory, index -> memory.loadLongAt(index) }, { readLongFallback() })\n}\n\nprivate fun Input.readLongFallback(): Long {\n    return readPrimitiveFallback(8) { it.readLong() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFloat(): Float {\n    return readPrimitive(4, { memory, index -> memory.loadFloatAt(index) }, { readFloatFallback() })\n}\n\npublic fun Input.readFloatFallback(): Float {\n    return readPrimitiveFallback(4) { it.readFloat() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readDouble(): Double {\n    return readPrimitive(8, { memory, index -> memory.loadDoubleAt(index) }, { readDoubleFallback() })\n}\n\npublic fun Input.readDoubleFallback(): Double {\n    return readPrimitiveFallback(8) { it.readDouble() }\n}\n\nprivate inline fun <R> Input.readPrimitive(size: Int, main: (Memory, Int) -> R, fallback: () -> R): R {\n    if (this is AbstractInput && headRemaining > size) {\n        val index = headPosition\n        headPosition = index + size\n        return main(headMemory, index)\n    }\n\n    return fallback()\n}\n\nprivate inline fun <R> Input.readPrimitiveFallback(size: Int, read: (Buffer) -> R): R {\n    val head = prepareReadFirstHead(size) ?: prematureEndOfStream(size)\n    val value = read(head)\n    completeReadHead(head)\n    return value\n}\n","@file:Suppress(\"MoveLambdaOutsideParentheses\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\npublic fun Output.writeShort(value: Short, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeShort(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeInt(value: Int, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeInt(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeLong(value: Long, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeLong(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeFloat(value: Float, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeFloat(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeDouble(value: Double, byteOrder: ByteOrder) {\n    writePrimitiveTemplate(value, byteOrder, { writeDouble(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeShortLittleEndian(value: Short) {\n    writePrimitiveTemplate(value, { writeShort(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeIntLittleEndian(value: Int) {\n    writePrimitiveTemplate(value, { writeInt(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeLongLittleEndian(value: Long) {\n    writePrimitiveTemplate(value, { writeLong(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeFloatLittleEndian(value: Float) {\n    writePrimitiveTemplate(value, { writeFloat(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeDoubleLittleEndian(value: Double) {\n    writePrimitiveTemplate(value, { writeDouble(it) }, { reverseByteOrder() })\n}\n\npublic fun Output.writeFullyLittleEndian(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asShortArray(), offset, length)\n}\n\npublic fun Buffer.writeShortLittleEndian(value: Short) {\n    writePrimitiveTemplate(value, { writeShort(it) }, { reverseByteOrder() })\n}\n\npublic fun Buffer.writeIntLittleEndian(value: Int) {\n    writePrimitiveTemplate(value, { writeInt(it) }, { reverseByteOrder() })\n}\n\npublic fun Buffer.writeLongLittleEndian(value: Long) {\n    writePrimitiveTemplate(value, { writeLong(it) }, { reverseByteOrder() })\n}\n\npublic fun Buffer.writeFloatLittleEndian(value: Float) {\n    writePrimitiveTemplate(value, { writeFloat(it) }, { reverseByteOrder() })\n}\n\npublic fun Buffer.writeDoubleLittleEndian(value: Double) {\n    writePrimitiveTemplate(value, { writeDouble(it) }, { reverseByteOrder() })\n}\n\npublic fun Buffer.writeFullyLittleEndian(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asShortArray(), offset, length)\n}\n\npublic fun Output.writeFullyLittleEndian(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        2,\n        { writeShort(source[it].reverseByteOrder()) }\n    )\n}\n\npublic fun Output.writeFullyLittleEndian(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asIntArray(), offset, length)\n}\n\npublic fun Output.writeFullyLittleEndian(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeInt(source[it].reverseByteOrder()) }\n    )\n}\n\npublic fun Output.writeFullyLittleEndian(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asLongArray(), offset, length)\n}\n\npublic fun Output.writeFullyLittleEndian(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeLong(source[it].reverseByteOrder()) }\n    )\n}\n\npublic fun Output.writeFullyLittleEndian(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeFloat(source[it].reverseByteOrder()) }\n    )\n}\n\npublic fun Output.writeFullyLittleEndian(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeDouble(source[it].reverseByteOrder()) }\n    )\n}\n\npublic fun Buffer.writeFullyLittleEndian(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        2,\n        { writeShort(source[it].reverseByteOrder()) }\n    )\n}\n\npublic fun Buffer.writeFullyLittleEndian(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asIntArray(), offset, length)\n}\n\npublic fun Buffer.writeFullyLittleEndian(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeInt(source[it].reverseByteOrder()) }\n    )\n}\n\npublic fun Buffer.writeFullyLittleEndian(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFullyLittleEndian(source.asLongArray(), offset, length)\n}\n\npublic fun Buffer.writeFullyLittleEndian(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeLong(source[it].reverseByteOrder()) }\n    )\n}\n\npublic fun Buffer.writeFullyLittleEndian(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        4,\n        { writeFloat(source[it].reverseByteOrder()) }\n    )\n}\n\npublic fun Buffer.writeFullyLittleEndian(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeArrayTemplate(\n        offset,\n        length,\n        8,\n        { writeDouble(source[it].reverseByteOrder()) }\n    )\n}\n\nprivate inline fun <T : Any> writePrimitiveTemplate(value: T, write: (T) -> Unit, reverse: T.() -> T) {\n    write(value.reverse())\n}\n\nprivate inline fun <T : Any> writePrimitiveTemplate(\n    value: T,\n    byteOrder: ByteOrder,\n    write: (T) -> Unit,\n    reverse: T.() -> T\n) {\n    write(\n        when (byteOrder) {\n            ByteOrder.BIG_ENDIAN -> value\n            else -> value.reverse()\n        }\n    )\n}\n\nprivate inline fun Output.writeArrayTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    writeComponent: Buffer.(Int) -> Unit\n) {\n    val untilIndex = offset + length\n    var start = offset\n    writeWhileSize(componentSize) { buffer ->\n        val size = minOf(buffer.writeRemaining / componentSize, untilIndex - start)\n        val lastIndex = start + size - 1\n        for (index in start..lastIndex) {\n            writeComponent(buffer, index)\n        }\n        start += size\n        when {\n            start < untilIndex -> componentSize\n            else -> 0\n        }\n    }\n}\n\nprivate inline fun Buffer.writeArrayTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    writeComponent: Buffer.(Int) -> Unit\n) {\n    val untilIndex = offset + length\n    var start = offset\n    val buffer = this\n\n    val size = minOf(buffer.writeRemaining / componentSize, untilIndex - start)\n    val lastIndex = start + size - 1\n    for (index in start..lastIndex) {\n        writeComponent(buffer, index)\n    }\n    start += size\n}\n","@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\npublic fun Output.writeShort(value: Short) {\n    if (!writePrimitiveTemplate(2) { memory, index -> memory.storeShortAt(index, value) }) {\n        writeShortFallback(value)\n    }\n}\n\nprivate fun Output.writeShortFallback(value: Short) {\n    if (!writePrimitiveFallbackTemplate(2) { it.writeShort(value) }) {\n        writeByte(value.highByte)\n        writeByte(value.lowByte)\n    }\n}\n\npublic fun Output.writeInt(value: Int) {\n    if (!writePrimitiveTemplate(4) { memory, index -> memory.storeIntAt(index, value) }) {\n        writeIntFallback(value)\n    }\n}\n\nprivate fun Output.writeIntFallback(value: Int) {\n    if (!writePrimitiveFallbackTemplate(4) { it.writeInt(value) }) {\n        writeIntByteByByte(value)\n    }\n}\n\nprivate fun Output.writeIntByteByByte(value: Int) {\n    value.highShort.let {\n        writeByte(it.highByte)\n        writeByte(it.lowByte)\n    }\n    value.lowShort.let {\n        writeByte(it.highByte)\n        writeByte(it.lowByte)\n    }\n}\n\npublic fun Output.writeLong(value: Long) {\n    if (!writePrimitiveTemplate(8) { memory, index -> memory.storeLongAt(index, value) }) {\n        writeLongFallback(value)\n    }\n}\n\nprivate fun Output.writeLongFallback(value: Long) {\n    if (!writePrimitiveFallbackTemplate(8) { it.writeLong(value) }) {\n        writeIntByteByByte(value.highInt)\n        writeIntByteByByte(value.lowInt)\n    }\n}\n\npublic fun Output.writeFloat(value: Float) {\n    if (!writePrimitiveTemplate(4) { memory, index -> memory.storeFloatAt(index, value) }) {\n        writeIntFallback(value.toRawBits())\n    }\n}\n\npublic fun Output.writeDouble(value: Double) {\n    if (!writePrimitiveTemplate(8) { memory, index -> memory.storeDoubleAt(index, value) }) {\n        writeLongFallback(value.toRawBits())\n    }\n}\n\nprivate inline fun Output.writePrimitiveTemplate(\n    componentSize: Int,\n    block: (Memory, index: Int) -> Unit\n): Boolean {\n    if (this is AbstractOutput) {\n        val index = tailPosition\n        if (tailEndExclusive - index > componentSize) {\n            tailPosition = index + componentSize\n            block(tailMemory, index)\n            return true\n        }\n    }\n\n    return false\n}\n\nprivate inline fun Output.writePrimitiveFallbackTemplate(\n    componentSize: Int,\n    writeOperation: (Buffer) -> Unit\n): Boolean {\n    if (this is AbstractOutput) {\n        val tail = prepareWriteHead(componentSize)\n        writeOperation(tail)\n        afterHeadWrite()\n        return true\n    }\n\n    return false\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\n/**\n * Discards bytes until [delimiter] occurred\n * @return number of bytes discarded\n */\npublic fun Input.discardUntilDelimiter(delimiter: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimiterImpl(delimiter)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Discards bytes until of of the specified delimiters [delimiter1] or [delimiter2] occurred\n * @return number of bytes discarded\n */\npublic fun Input.discardUntilDelimiters(delimiter1: Byte, delimiter2: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimitersImpl(delimiter1, delimiter2)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiter(delimiter: Byte, dst: ByteArray, offset: Int = 0, length: Int = dst.size): Int {\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        dstRemaining > 0 && !chunk.canRead()\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiters(\n    delimiter1: Byte,\n    delimiter2: Byte,\n    dst: ByteArray,\n    offset: Int = 0,\n    length: Int = dst.size\n): Int {\n    if (delimiter1 == delimiter2) return readUntilDelimiter(delimiter1, dst, offset, length)\n\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        !chunk.canRead() && dstRemaining > 0\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] output until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiter(delimiter: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\n/**\n * Copies to [dst] output until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiters(delimiter1: Byte, delimiter2: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\ninternal expect fun Buffer.discardUntilDelimiterImpl(delimiter: Byte): Int\n\ninternal fun discardUntilDelimiterImplMemory(buffer: Buffer, delimiter: Byte): Int {\n    val start = buffer.readPosition\n    var i = start\n    val limit = buffer.writePosition\n    val memory = buffer.memory\n\n    while (i < limit) {\n        if (memory[i] == delimiter) break\n        i++\n    }\n\n    buffer.discardUntilIndex(i)\n    return i - start\n}\n\ninternal expect fun Buffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int\n\ninternal fun discardUntilDelimitersImplMemory(buffer: Buffer, delimiter1: Byte, delimiter2: Byte): Int {\n    val start = buffer.readPosition\n    var i = start\n    val limit = buffer.writePosition\n    val memory = buffer.memory\n\n    while (i < limit) {\n        val v = memory[i]\n        if (v == delimiter1 || v == delimiter2) break\n        i++\n    }\n\n    buffer.discardUntilIndex(i)\n    return i - start\n}\n\ninternal expect fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int\n\ninternal expect fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte,\n    delimiter2: Byte,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int\n\ninternal expect fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: Output\n): Int\n\ninternal expect fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte,\n    delimiter2: Byte,\n    dst: Output\n): Int\n\ninternal inline fun Buffer.copyUntil(predicate: (Byte) -> Boolean, dst: ByteArray, offset: Int, length: Int): Int {\n    val readPosition = readPosition\n    var end = minOf(writePosition, readPosition + length)\n    val memory = memory\n    for (index in readPosition until end) {\n        if (predicate(memory.loadAt(index))) {\n            end = index\n            break\n        }\n    }\n\n    val copySize = end - readPosition\n    memory.loadByteArray(readPosition, dst, offset, copySize)\n    return copySize\n}\n\ninternal inline fun Buffer.copyUntil(predicate: (Byte) -> Boolean, dst: Output): Int {\n    var index = readPosition\n    val end = writePosition\n    val memory = memory\n    do {\n        if (index == end || predicate(memory.loadAt(index))) {\n            break\n        }\n        index++\n    } while (true)\n\n    val size = index - readPosition\n    dst.writeFully(this, size)\n    return size\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\n@ExperimentalUnsignedTypes\npublic inline fun Input.readUByte(): UByte = readByte().toUByte()\n\n@ExperimentalUnsignedTypes\npublic inline fun Input.readUShort(): UShort = readShort().toUShort()\n\n@ExperimentalUnsignedTypes\npublic inline fun Input.readUInt(): UInt = readInt().toUInt()\n\n@ExperimentalUnsignedTypes\npublic inline fun Input.readULong(): ULong = readLong().toULong()\n\n@ExperimentalUnsignedTypes\npublic inline fun Input.readFully(dst: UByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asByteArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Input.readFully(dst: UShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asShortArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Input.readFully(dst: UIntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asIntArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Input.readFully(dst: ULongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFully(dst.asLongArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Output.writeUByte(v: UByte) {\n    writeByte(v.toByte())\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Output.writeUShort(v: UShort) {\n    writeShort(v.toShort())\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Output.writeUInt(v: UInt) {\n    writeInt(v.toInt())\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Output.writeULong(v: ULong) {\n    writeLong(v.toLong())\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Output.writeFully(array: UByteArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asByteArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Output.writeFully(array: UShortArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asShortArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Output.writeFully(array: UIntArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asIntArray(), offset, length)\n}\n\n@ExperimentalUnsignedTypes\npublic inline fun Output.writeFully(array: ULongArray, offset: Int = 0, length: Int = array.size - offset) {\n    writeFully(array.asLongArray(), offset, length)\n}\n","package io.ktor.utils.io.core\n\npublic inline fun <I : Input, R> I.use(block: (I) -> R): R {\n    return try {\n        block(this)\n    } finally {\n        close()\n    }\n}\n\npublic inline fun <O : Output, R> O.use(block: (O) -> R): R {\n    return try {\n        block(this)\n    } finally {\n        close()\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.concurrent\n\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.properties.*\nimport kotlin.reflect.*\n\n/**\n * Allows to create mutate property with frozen value.\n * Please note that any assigned value will be frozen.\n *\n * Usage:\n * ```kotlin\n * var myCounter by shared(0)\n * ```\n */\n@Suppress(\"NOTHING_TO_INLINE\")\n@DangerousInternalIoApi\npublic actual inline fun <T> shared(value: T): ReadWriteProperty<Any, T> = object : ReadWriteProperty<Any, T> {\n    private var value: T = value\n\n    override fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return this.value\n    }\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n}\n\n/**\n * Allow to create thread local reference without freezing.\n * Please note that reference is thread-local only in kotlin-native. Otherwise it will be simple [value] reference.\n *\n * This reference is allowed to use only from creation thread. Otherwise it will return null.\n */\n@DangerousInternalIoApi\npublic actual fun <T : Any> threadLocal(value: T): ReadOnlyProperty<Any, T?> =\n    ReadOnlyProperty<Any, T?> { thisRef, property -> value }\n","package io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.bits.DefaultAllocator\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.pool.*\nimport kotlinx.atomicfu.*\n\npublic open class ChunkBuffer(\n    memory: Memory,\n    origin: ChunkBuffer?,\n    internal val parentPool: ObjectPool<ChunkBuffer>?\n) : Buffer(memory) {\n    init {\n        require(origin !== this) { \"A chunk couldn't be a view of itself.\" }\n    }\n\n    private val nextRef: AtomicRef<ChunkBuffer?> = atomic(null)\n    private val refCount = atomic(1)\n\n    /**\n     * Reference to an origin buffer view this was copied from\n     */\n    public var origin: ChunkBuffer? by shared(origin)\n        private set\n\n    /**\n     * Reference to next buffer view. Useful to chain multiple views.\n     * @see appendNext\n     * @see cleanNext\n     */\n    public var next: ChunkBuffer? get() = nextRef.value\n        set(newValue) {\n            if (newValue == null) {\n                cleanNext()\n            } else {\n                appendNext(newValue)\n            }\n        }\n\n    public val referenceCount: Int get() = refCount.value\n\n    private fun appendNext(chunk: ChunkBuffer) {\n        if (!nextRef.compareAndSet(null, chunk)) {\n            throw IllegalStateException(\"This chunk has already a next chunk.\")\n        }\n    }\n\n    public fun cleanNext(): ChunkBuffer? {\n        return nextRef.getAndSet(null)\n    }\n\n    override fun duplicate(): ChunkBuffer = (origin ?: this).let { newOrigin ->\n        newOrigin.acquire()\n        ChunkBuffer(memory, newOrigin, parentPool).also { copy ->\n            duplicateTo(copy)\n        }\n    }\n\n    public open fun release(pool: ObjectPool<ChunkBuffer>) {\n        if (release()) {\n            val origin = origin\n            if (origin != null) {\n                unlink()\n                origin.release(pool)\n            } else {\n                val poolToUse = parentPool ?: pool\n                poolToUse.recycle(this)\n            }\n        }\n    }\n\n    internal fun unlink() {\n        if (!refCount.compareAndSet(0, -1)) {\n            throw IllegalStateException(\"Unable to unlink: buffer is in use.\")\n        }\n\n        cleanNext()\n        origin = null\n    }\n\n    /**\n     * Increase ref-count. May fail if already released.\n     */\n    internal fun acquire() {\n        refCount.update { old ->\n            if (old <= 0) throw IllegalStateException(\"Unable to acquire chunk: it is already released.\")\n            old + 1\n        }\n    }\n\n    /**\n     * Invoked by a pool before return the instance to a user.\n     */\n    internal fun unpark() {\n        refCount.update { old ->\n            if (old < 0) {\n                throw IllegalStateException(\"This instance is already disposed and couldn't be borrowed.\")\n            }\n            if (old > 0) {\n                throw IllegalStateException(\"This instance is already in use but somehow appeared in the pool.\")\n            }\n\n            1\n        }\n    }\n\n    /**\n     * Release ref-count.\n     * @return `true` if the last usage was released\n     */\n    internal fun release(): Boolean {\n        return refCount.updateAndGet { old ->\n            if (old <= 0) throw IllegalStateException(\"Unable to release: it is already released.\")\n            old - 1\n        } == 0\n    }\n\n    final override fun reset() {\n        require(origin == null) { \"Unable to reset buffer with origin\" }\n\n        super.reset()\n        @Suppress(\"DEPRECATION\")\n        attachment = null\n        nextRef.value = null\n    }\n\n    public companion object {\n        public val Pool: ObjectPool<ChunkBuffer> = object : ObjectPool<ChunkBuffer> {\n            override val capacity: Int\n                get() = DefaultChunkedBufferPool.capacity\n\n            override fun borrow(): ChunkBuffer {\n                return DefaultChunkedBufferPool.borrow()\n            }\n\n            @Suppress(\"DEPRECATION\")\n            override fun recycle(instance: ChunkBuffer) {\n                if (instance !is IoBuffer) {\n                    throw IllegalArgumentException(\"Only IoBuffer instances can be recycled.\")\n                }\n\n                DefaultChunkedBufferPool.recycle(instance)\n            }\n\n            override fun dispose() {\n                DefaultChunkedBufferPool.dispose()\n            }\n        }\n\n        @Suppress(\"DEPRECATION\")\n        public val Empty: ChunkBuffer get() = IoBuffer.Empty\n\n        /**\n         * A pool that always returns [ChunkBuffer.Empty]\n         */\n        public val EmptyPool: ObjectPool<ChunkBuffer> = object : ObjectPool<ChunkBuffer> {\n            override val capacity: Int get() = 1\n\n            override fun borrow() = Empty\n\n            override fun recycle(instance: ChunkBuffer) {\n                require(instance === ChunkBuffer.Empty) { \"Only ChunkBuffer.Empty instance could be recycled.\" }\n            }\n\n            override fun dispose() {\n            }\n        }\n\n        @Suppress(\"DEPRECATION\")\n        internal val NoPool: ObjectPool<ChunkBuffer> = object : NoPoolImpl<ChunkBuffer>() {\n            override fun borrow(): ChunkBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null, this as ObjectPool<IoBuffer>)\n            }\n\n            override fun recycle(instance: ChunkBuffer) {\n                if (instance !is IoBuffer) {\n                    throw IllegalArgumentException(\"Only IoBuffer instances can be recycled.\")\n                }\n\n                DefaultAllocator.free(instance.memory)\n            }\n        }\n\n        internal val NoPoolManuallyManaged: ObjectPool<ChunkBuffer> = object : NoPoolImpl<ChunkBuffer>() {\n            override fun borrow(): ChunkBuffer {\n                throw UnsupportedOperationException(\"This pool doesn't support borrow\")\n            }\n\n            override fun recycle(instance: ChunkBuffer) {\n                // do nothing: manually managed objects should be disposed manually\n            }\n        }\n    }\n}\n\n/**\n * @return `true` if and only if the are no buffer views that share the same actual buffer. This actually does\n * refcount and only work guaranteed if other views created/not created via [Buffer.duplicate] function.\n * One can instantiate multiple buffers with the same buffer and this function will return `true` in spite of\n * the fact that the buffer is actually shared.\n */\ninternal fun ChunkBuffer.isExclusivelyOwned(): Boolean = referenceCount == 1\n",null,"@file:Suppress(\"KDocMissingDocumentation\")\n\npackage io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.core.*\nimport kotlin.jvm.*\nimport kotlin.native.concurrent.*\n\n/**\n * API marked with this annotation is internal and extremely fragile and not intended to be used by library users.\n * Such API could be changed without notice including rename, removal and behaviour change.\n * Also using API marked with this annotation could cause data loss or any other damage.\n */\n@Suppress(\"DEPRECATION\")\n@RequiresOptIn(level = RequiresOptIn.Level.ERROR)\n@Experimental(level = Experimental.Level.ERROR)\npublic annotation class DangerousInternalIoApi\n\n@DangerousInternalIoApi\npublic fun ByteReadPacket.`$unsafeAppend$`(builder: BytePacketBuilder) {\n    val builderHead = builder.stealAll() ?: return\n    val builderSize = builder.size\n\n    if (builderSize <= PACKET_MAX_COPY_SIZE && builderHead.next == null && tryWriteAppend(builderHead)) {\n        builder.afterBytesStolen()\n        return\n    }\n\n    append(builderHead)\n}\n\ninternal fun ByteReadPacket.unsafeAppend(builder: BytePacketBuilder): Int {\n    val builderSize = builder.size\n    val builderHead = builder.stealAll() ?: return 0\n\n    if (builderSize <= PACKET_MAX_COPY_SIZE && builderHead.next == null && tryWriteAppend(builderHead)) {\n        builder.afterBytesStolen()\n        return builderSize\n    }\n\n    append(builderHead)\n    return builderSize\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@JvmName(\"prepareReadFirstHead\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.prepareReadFirstHeadOld(minSize: Int): IoBuffer? {\n    return prepareReadFirstHead(minSize) as IoBuffer?\n}\n\n@DangerousInternalIoApi\npublic fun Input.prepareReadFirstHead(minSize: Int): ChunkBuffer? {\n    if (this is AbstractInput) {\n        return prepareReadHead(minSize)\n    }\n    if (this is ChunkBuffer) {\n        return if (canRead()) this else null\n    }\n\n    return prepareReadHeadFallback(minSize)\n}\n\nprivate fun Input.prepareReadHeadFallback(minSize: Int): ChunkBuffer? {\n    if (endOfInput) return null\n\n    val buffer = ChunkBuffer.Pool.borrow()\n    val copied = peekTo(\n        buffer.memory,\n        buffer.writePosition.toLong(),\n        0L,\n        minSize.toLong(),\n        buffer.writeRemaining.toLong()\n    ).toInt()\n    buffer.commitWritten(copied)\n\n    if (copied < minSize) {\n        prematureEndOfStream(minSize)\n    }\n\n    return buffer\n}\n\n@Suppress(\"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.completeReadHead(current: IoBuffer) {\n    completeReadHead(current)\n}\n\n@DangerousInternalIoApi\npublic fun Input.completeReadHead(current: ChunkBuffer) {\n    if (current === this) {\n        return\n    }\n    if (this is AbstractInput) {\n        if (!current.canRead()) {\n            ensureNext(current)\n        } else if (current.endGap < Buffer.ReservedSize) {\n            fixGapAfterRead(current)\n        } else {\n            headPosition = current.readPosition\n        }\n        return\n    }\n\n    completeReadHeadFallback(current)\n}\n\nprivate fun Input.completeReadHeadFallback(current: ChunkBuffer) {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.release(ChunkBuffer.Pool)\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@JvmName(\"prepareReadNextHead\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.prepareReadNextHeadOld(current: IoBuffer): IoBuffer? {\n    return prepareReadNextHead(current) as IoBuffer?\n}\n\n@DangerousInternalIoApi\npublic fun Input.prepareReadNextHead(current: ChunkBuffer): ChunkBuffer? {\n    if (current === this) {\n        return if (canRead()) this else null\n    }\n    if (this is AbstractInput) {\n        return ensureNextHead(current)\n    }\n\n    return prepareNextReadHeadFallback(current)\n}\n\nprivate fun Input.prepareNextReadHeadFallback(current: ChunkBuffer): ChunkBuffer? {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.resetForWrite()\n\n    if (endOfInput || peekTo(current) <= 0) {\n        current.release(ChunkBuffer.Pool)\n        return null\n    }\n\n    return current\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Output.prepareWriteHead(capacity: Int, current: IoBuffer?): IoBuffer {\n    return prepareWriteHead(capacity, current) as IoBuffer\n}\n\n@DangerousInternalIoApi\npublic fun Output.prepareWriteHead(capacity: Int, current: ChunkBuffer?): ChunkBuffer {\n    if (this is AbstractOutput) {\n        if (current != null) {\n            afterHeadWrite()\n        }\n        return prepareWriteHead(capacity)\n    }\n\n    return prepareWriteHeadFallback(current)\n}\n\nprivate fun Output.prepareWriteHeadFallback(current: ChunkBuffer?): ChunkBuffer {\n    if (current != null) {\n        writeFully(current)\n        current.resetForWrite()\n        return current\n    }\n\n    return ChunkBuffer.Pool.borrow()\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Output.afterHeadWrite(current: IoBuffer) {\n    return afterHeadWrite(current)\n}\n\n@DangerousInternalIoApi\npublic fun Output.afterHeadWrite(current: ChunkBuffer) {\n    if (this is AbstractOutput) {\n        return afterHeadWrite()\n    }\n\n    afterWriteHeadFallback(current)\n}\n\n@JvmField\n@SharedImmutable\ninternal val EmptyByteArray = ByteArray(0)\n\nprivate fun Output.afterWriteHeadFallback(current: ChunkBuffer) {\n    writeFully(current)\n    current.release(ChunkBuffer.Pool)\n}\n","package io.ktor.utils.io.errors\n\nimport io.ktor.utils.io.core.*\n\npublic expect open class IOException(message: String, cause: Throwable?) : Exception {\n    public constructor(message: String)\n}\n\npublic expect open class EOFException(message: String) : IOException\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\"Not implemented.\", level = DeprecationLevel.ERROR)\npublic fun <R> TODO_ERROR(value: R): Nothing = TODO(\"Not implemented. Value is $value\")\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\"Not implemented.\", level = DeprecationLevel.ERROR)\npublic fun TODO_ERROR(): Nothing = TODO(\"Not implemented.\")\n\ninternal fun checkPeekTo(destination: Buffer, offset: Int, min: Int, max: Int) {\n    io.ktor.utils.io.core.internal.require(offset >= 0) { \"offset shouldn't be negative: $offset.\" }\n    io.ktor.utils.io.core.internal.require(min >= 0) { \"min shouldn't be negative: $min.\" }\n    io.ktor.utils.io.core.internal.require(max >= min) { \"max should't be less than min: max = $max, min = $min.\" }\n    io.ktor.utils.io.core.internal.require(min <= destination.writeRemaining) {\n        \"Not enough free space in the destination buffer \" +\n            \"to write the specified minimum number of bytes: min = $min, free = ${destination.writeRemaining}.\"\n    }\n}\n\n@PublishedApi\ninternal fun incompatibleVersionError(): Nothing = throw Error(\n    \"This API is no longer supported. \" +\n        \"Please downgrade kotlinx-io or recompile your project/dependencies with new kotlinx-io.\"\n)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.internal\n\nimport io.ktor.utils.io.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\n\n/**\n * Exclusive slot for waiting.\n * Only one waiter allowed.\n *\n * TODO: replace [Job] -> [Continuation] when all coroutines problems are fixed.\n */\ninternal class AwaitingSlot {\n    private val suspension: AtomicRef<CompletableJob?> = atomic(null)\n\n    init {\n        makeShared()\n    }\n\n    /**\n     * Wait for other [sleep] or resume.\n     */\n    public suspend fun sleep() {\n        if (trySuspend()) {\n            return\n        }\n\n        resume()\n    }\n\n    /**\n     * Resume waiter.\n     */\n    public fun resume() {\n        suspension.getAndSet(null)?.complete()\n    }\n\n    /**\n     * Cancel waiter.\n     */\n    public fun cancel(cause: Throwable?) {\n        val continuation = suspension.getAndSet(null) ?: return\n\n        if (cause != null) {\n            continuation.completeExceptionally(cause)\n        } else {\n            continuation.complete()\n        }\n    }\n\n    private suspend fun trySuspend(): Boolean {\n        var suspended = false\n\n        val job = Job()\n        if (suspension.compareAndSet(null, job)) {\n            suspended = true\n            job.join()\n        }\n\n        return suspended\n    }\n}\n","package io.ktor.utils.io.internal\n\nimport io.ktor.utils.io.ByteChannelSequentialBase\nimport io.ktor.utils.io.close\nimport io.ktor.utils.io.core.internal.ChunkBuffer\n\ninternal suspend fun ByteChannelSequentialBase.joinToImpl(dst: ByteChannelSequentialBase, closeOnEnd: Boolean) {\n    copyToSequentialImpl(dst, Long.MAX_VALUE)\n    if (closeOnEnd) dst.close()\n}\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\ninternal suspend fun ByteChannelSequentialBase.copyToSequentialImpl(dst: ByteChannelSequentialBase, limit: Long): Long {\n    require(this !== dst)\n    if (closedCause != null) {\n        dst.close(closedCause)\n        return 0L\n    }\n\n    var remainingLimit = limit\n\n    while (remainingLimit > 0) {\n        if (!awaitInternalAtLeast1()) {\n            break\n        }\n        val transferred = transferTo(dst, remainingLimit)\n\n        val copied = if (transferred == 0L) {\n            val tail = copyToTail(dst, remainingLimit)\n            if (tail == 0L) {\n                break\n            }\n\n            tail\n        } else {\n            if (dst.availableForWrite == 0) {\n                dst.awaitAtLeastNBytesAvailableForWrite(1)\n            }\n\n            transferred\n        }\n\n        remainingLimit -= copied\n    }\n\n    return limit - remainingLimit\n}\n\nprivate suspend fun ByteChannelSequentialBase.copyToTail(dst: ByteChannelSequentialBase, limit: Long): Long {\n    val lastPiece = ChunkBuffer.Pool.borrow()\n    try {\n        lastPiece.resetForWrite(limit.coerceAtMost(lastPiece.capacity.toLong()).toInt())\n        val rc = readAvailable(lastPiece)\n        if (rc == -1) {\n            lastPiece.release(ChunkBuffer.Pool)\n            return 0\n        }\n\n        dst.writeFully(lastPiece)\n        return rc.toLong()\n    } finally {\n        lastPiece.release(ChunkBuffer.Pool)\n    }\n}\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.pool\n\nimport kotlin.native.concurrent.*\n\n@ThreadLocal\npublic val ByteArrayPool: ObjectPool<ByteArray> = object : DefaultPool<ByteArray>(128) {\n    override fun produceInstance() = ByteArray(4096)\n}\n","package io.ktor.utils.io.pool\n\nimport io.ktor.utils.io.core.*\nimport kotlinx.atomicfu.*\nimport kotlin.jvm.*\n\npublic interface ObjectPool<T : Any> : Closeable {\n    /**\n     * Pool capacity\n     */\n    public val capacity: Int\n\n    /**\n     * borrow an instance. Pool can recycle an old instance or create a new one\n     */\n    public fun borrow(): T\n\n    /**\n     * Recycle an instance. Should be recycled what was borrowed before otherwise could fail\n     */\n    public fun recycle(instance: T)\n\n    /**\n     * Dispose the whole pool. None of borrowed objects could be used after the pool gets disposed\n     * otherwise it can result in undefined behaviour\n     */\n    public fun dispose()\n\n    /**\n     * Does pool dispose\n     */\n    override fun close() {\n        dispose()\n    }\n}\n\n/**\n * A pool implementation of zero capacity that always creates new instances\n */\npublic abstract class NoPoolImpl<T : Any> : ObjectPool<T> {\n    override val capacity: Int\n        get() = 0\n\n    override fun recycle(instance: T) {\n    }\n\n    override fun dispose() {\n    }\n}\n\n/**\n * A pool that produces at most one instance\n */\npublic abstract class SingleInstancePool<T : Any> : ObjectPool<T> {\n    private val borrowed = atomic(0)\n    private val disposed = atomic(false)\n\n    @Volatile\n    private var instance: T? = null\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected abstract fun disposeInstance(instance: T)\n\n    final override val capacity: Int get() = 1\n\n    final override fun borrow(): T {\n        borrowed.update {\n            if (it != 0) throw IllegalStateException(\"Instance is already consumed\")\n            1\n        }\n\n        val instance = produceInstance()\n        this.instance = instance\n\n        return instance\n    }\n\n    final override fun recycle(instance: T) {\n        if (this.instance !== instance) {\n            if (this.instance == null && borrowed.value != 0) {\n                throw IllegalStateException(\"Already recycled or an irrelevant instance tried to be recycled\")\n            }\n\n            throw IllegalStateException(\"Unable to recycle irrelevant instance\")\n        }\n\n        this.instance = null\n\n        if (!disposed.compareAndSet(false, true)) {\n            throw IllegalStateException(\"An instance is already disposed\")\n        }\n\n        disposeInstance(instance)\n    }\n\n    final override fun dispose() {\n        if (disposed.compareAndSet(false, true)) {\n            val instance = this.instance ?: return\n            this.instance = null\n\n            disposeInstance(instance)\n        }\n    }\n}\n\n/**\n * Default object pool implementation.\n */\npublic expect abstract class DefaultPool<T : Any>(capacity: Int) : ObjectPool<T> {\n    /**\n     * Pool capacity.\n     */\n    final override val capacity: Int\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release it's resources\n     */\n    protected open fun disposeInstance(instance: T)\n\n    /**\n     * Clear [instance]'s state before reuse: reset pointers, counters and so on\n     */\n    protected open fun clearInstance(instance: T): T\n\n    /**\n     * Validate [instance] of [T]. Could verify that the object has been borrowed from this pool\n     */\n    protected open fun validateInstance(instance: T)\n\n    final override fun borrow(): T\n\n    final override fun recycle(instance: T)\n\n    final override fun dispose()\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\n@Deprecated(\"Use useInstance instead\", ReplaceWith(\"useInstance(block)\"))\npublic inline fun <T : Any, R> ObjectPool<T>.useBorrowed(block: (T) -> R): R {\n    return useInstance(block)\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\npublic inline fun <T : Any, R> ObjectPool<T>.useInstance(block: (T) -> R): R {\n    val instance = borrow()\n    try {\n        return block(instance)\n    } finally {\n        recycle(instance)\n    }\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.internal.*\nimport kotlinx.coroutines.*\nimport org.khronos.webgl.*\n\n/**\n * Creates buffered channel for asynchronous reading and writing of sequences of bytes.\n */\npublic actual fun ByteChannel(autoFlush: Boolean): ByteChannel {\n    return ByteChannelJS(IoBuffer.Empty, autoFlush)\n}\n\n/**\n * Creates channel for reading from the specified byte array.\n */\npublic actual fun ByteReadChannel(content: ByteArray, offset: Int, length: Int): ByteReadChannel {\n    if (content.isEmpty()) return ByteReadChannel.Empty\n    val head = IoBuffer.Pool.borrow()\n    var tail = head\n\n    var start = offset\n    val end = start + length\n    while (true) {\n        tail.reserveEndGap(8)\n        val size = minOf(end - start, tail.writeRemaining)\n        (tail as Buffer).writeFully(content, start, size)\n        start += size\n\n        if (start == end) break\n        val current = tail\n        tail = IoBuffer.Pool.borrow()\n        current.next = tail\n    }\n\n    return ByteChannelJS(head, false).apply { close() }\n}\n\n/**\n * Creates channel for reading from the specified [ArrayBufferView]\n */\npublic fun ByteReadChannel(content: ArrayBufferView): ByteReadChannel {\n    if (content.byteLength == 0) return ByteReadChannel.Empty\n    val head = IoBuffer.Pool.borrow()\n    var tail = head\n\n    var start = 0\n    var remaining = content.byteLength - content.byteOffset\n    while (true) {\n        tail.reserveEndGap(8)\n        val size = minOf(remaining, tail.writeRemaining)\n        tail.writeFully(content, start, size)\n        start += size\n        remaining -= size\n\n        if (remaining == 0) break\n        tail = IoBuffer.Pool.borrow()\n    }\n\n    return ByteChannelJS(head, false).apply { close() }\n}\n\npublic actual suspend fun ByteReadChannel.joinTo(dst: ByteWriteChannel, closeOnEnd: Boolean) {\n    (this as ByteChannelSequentialBase).joinToImpl((dst as ByteChannelSequentialBase), closeOnEnd)\n}\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic actual suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel, limit: Long): Long {\n    return (this as ByteChannelSequentialBase).copyToSequentialImpl((dst as ByteChannelSequentialBase), limit)\n}\n\ninternal class ByteChannelJS(initial: IoBuffer, autoFlush: Boolean) : ByteChannelSequentialBase(initial, autoFlush) {\n    private var attachedJob: Job? = null\n\n    @OptIn(InternalCoroutinesApi::class)\n    override fun attachJob(job: Job) {\n        attachedJob?.cancel()\n        attachedJob = job\n        job.invokeOnCompletion(onCancelling = true) { cause ->\n            attachedJob = null\n            if (cause != null) {\n                cancel(cause)\n            }\n        }\n    }\n\n    override suspend fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return if (readable.isEmpty) {\n            readAvailableSuspend(dst, offset, length)\n        } else {\n            closedCause?.let { throw it }\n            readable.readAvailable(dst, offset, length)\n        }\n    }\n\n    private suspend fun readAvailableSuspend(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        if (!await(1)) return -1\n        return readAvailable(dst, offset, length)\n    }\n\n    override suspend fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        if (availableForRead >= length) {\n            closedCause?.let { throw it }\n            readable.readFully(dst, offset, length)\n            return\n        }\n\n        return readFullySuspend(dst, offset, length)\n    }\n\n    private suspend fun readFullySuspend(dst: ArrayBuffer, offset: Int, length: Int) {\n        var start = offset\n        val end = offset + length\n        var remaining = length\n\n        while (start < end) {\n            val rc = readAvailable(dst, start, remaining)\n            if (rc == -1) throw EOFException(\"Premature end of stream: required $remaining more bytes\")\n            start += rc\n            remaining -= rc\n        }\n    }\n\n    override fun toString(): String = \"ByteChannel[$attachedJob, ${hashCode()}]\"\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\n@Suppress(\"DEPRECATION\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the array was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.max(): Byte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.max(): Short? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.max(): Int? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.max(): Long? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.min(): Byte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.min(): Short? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.min(): Int? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.min(): Long? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","// ktlint-disable filename\n/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.jvm.*\n\ninternal actual class ByteChannelSequentialBaseSharedState actual constructor() {\n    actual var closed: Boolean = false\n\n    actual var readByteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n\n    actual var writeByteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n\n    actual var totalBytesRead: Long = 0L\n\n    actual var totalBytesWritten: Long = 0L\n\n    actual var closedCause: Throwable? = null\n\n    actual var lastReadAvailable: Int = 0\n\n    actual var lastReadView: ChunkBuffer = ChunkBuffer.Empty\n}\n","// ktlint-disable filename\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\n/**\n * Channel for asynchronous reading of sequences of bytes.\n * This is a **single-reader channel**.\n *\n * Operations on this channel cannot be invoked concurrently.\n */\npublic actual interface ByteReadChannel {\n    /**\n     * Returns number of bytes that can be read without suspension. Read operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for read.\n     */\n    public actual val availableForRead: Int\n\n    /**\n     * Returns `true` if the channel is closed and no remaining bytes are available for read.\n     * It implies that [availableForRead] is zero.\n     */\n    public actual val isClosedForRead: Boolean\n\n    public actual val isClosedForWrite: Boolean\n\n    /**\n     * An closure cause exception or `null` if closed successfully or not yet closed\n     */\n    public actual val closedCause: Throwable?\n\n    /**\n     * Byte order that is used for multi-byte read operations\n     * (such as [readShort], [readInt], [readLong], [readFloat], and [readDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    public actual var readByteOrder: ByteOrder\n\n    /**\n     * Number of bytes read from the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of long running read operation.\n     */\n    public actual val totalBytesRead: Long\n\n    /**\n     * Reads all available bytes to [dst] buffer and returns immediately or suspends if no bytes available\n     * @return number of bytes were read or `-1` if the channel has been closed\n     */\n    public actual suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n\n    public actual suspend fun readAvailable(dst: IoBuffer): Int\n\n    public suspend fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int\n\n    /**\n     * Reads all [length] bytes to [dst] buffer or fails if channel has been closed.\n     * Suspends if not enough bytes available.\n     */\n    public actual suspend fun readFully(dst: ByteArray, offset: Int, length: Int)\n\n    public actual suspend fun readFully(dst: IoBuffer, n: Int)\n\n    public suspend fun readFully(dst: ArrayBuffer, offset: Int, length: Int)\n\n    /**\n     * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n     * and not enough bytes available. Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    public actual suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n     * Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    public actual suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads a long number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public actual suspend fun readLong(): Long\n\n    /**\n     * Reads an int number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public actual suspend fun readInt(): Int\n\n    /**\n     * Reads a short number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public actual suspend fun readShort(): Short\n\n    /**\n     * Reads a byte (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public actual suspend fun readByte(): Byte\n\n    /**\n     * Reads a boolean value (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public actual suspend fun readBoolean(): Boolean\n\n    /**\n     * Reads double number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public actual suspend fun readDouble(): Double\n\n    /**\n     * Reads float number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public actual suspend fun readFloat(): Float\n\n    /**\n     * Starts non-suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * event if there are no bytes available for read yet.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    public actual fun readSession(consumer: ReadSession.() -> Unit)\n\n    /**\n     * Starts a suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * even if there are no bytes available for read yet. [consumer] lambda could suspend as much as needed.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    public actual suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit)\n\n    /**\n     * Reads a line of UTF-8 characters to the specified [out] buffer up to [limit] characters.\n     * Supports both CR-LF and LF line endings.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return `true` if line has been read (possibly empty) or `false` if channel has been closed\n     * and no characters were read.\n     */\n    public actual suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean\n\n    /**\n     * Reads a line of UTF-8 characters up to [limit] characters.\n     * Supports both CR-LF and LF line endings.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return a line string with no line endings or `null` of channel has been closed\n     * and no characters were read.\n     */\n    public actual suspend fun readUTF8Line(limit: Int): String?\n\n    /**\n     * Close channel with optional [cause] cancellation. Unlike [ByteWriteChannel.close] that could close channel\n     * normally, cancel does always close with error so any operations on this channel will always fail\n     * and all suspensions will be resumed with exception.\n     *\n     * Please note that if the channel has been provided by [reader] or [writer] then the corresponding owning\n     * coroutine will be cancelled as well\n     *\n     * @see ByteWriteChannel.close\n     */\n    public actual fun cancel(cause: Throwable?): Boolean\n\n    /**\n     * Discard up to [max] bytes\n     *\n     * @return number of bytes were discarded\n     */\n    public actual suspend fun discard(max: Long): Long\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source suspending reading.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [endOfInput].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    public actual suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long\n\n    public actual companion object {\n        public actual val Empty: ByteReadChannel by lazy {\n            ByteChannelJS(IoBuffer.Empty, false).apply {\n                close(null)\n            }\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","// ktlint-disable filename\npackage io.ktor.utils.io\n\nimport kotlin.coroutines.*\n\ninternal actual class Condition actual constructor(val predicate: () -> Boolean) {\n    private var cont: Continuation<Unit>? = null\n\n    actual fun check(): Boolean {\n        return predicate()\n    }\n\n    actual fun signal() {\n        val cont = cont\n        if (cont != null && predicate()) {\n            this.cont = null\n            cont.resume(Unit)\n        }\n    }\n\n    actual suspend fun await(block: () -> Unit) {\n        if (predicate()) return\n\n        return suspendCoroutine { c ->\n            cont = c\n            block()\n        }\n    }\n    actual suspend fun await() {\n        if (predicate()) return\n\n        return suspendCoroutine { c ->\n            cont = c\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmInline\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@SinceKotlin(\"1.3\")\n@JvmInline\npublic value class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io\n\n/**\n * Print exception stacktrace.\n */\npublic actual fun Throwable.printStack() {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    println(asDynamic().stack)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.core.internal.*\n\n@DangerousInternalIoApi\npublic actual fun Any.preventFreeze() {\n}\n\n@DangerousInternalIoApi\npublic actual fun Any.makeShared() {\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Short.reverseByteOrder(): Short = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Int.reverseByteOrder(): Int = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Long.reverseByteOrder(): Long = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Float.reverseByteOrder(): Float = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Double.reverseByteOrder(): Double = swap(this)\n\nprivate inline fun swap(s: Short): Short = (((s.toInt() and 0xff) shl 8) or ((s.toInt() and 0xffff) ushr 8)).toShort()\n\nprivate inline fun swap(s: Int): Int =\n    (swap((s and 0xffff).toShort()).toInt() shl 16) or (swap((s ushr 16).toShort()).toInt() and 0xffff)\n\nprivate inline fun swap(s: Long): Long =\n    (swap((s and 0xffffffff).toInt()).toLong() shl 32) or (swap((s ushr 32).toInt()).toLong() and 0xffffffff)\n\nprivate inline fun swap(s: Float): Float = Float.fromBits(swap(s.toRawBits()))\n\nprivate inline fun swap(s: Double): Double = Double.fromBits(swap(s.toRawBits()))\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\n\nprivate val isLittleEndianPlatform = ByteOrder.nativeOrder() === ByteOrder.LITTLE_ENDIAN\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadShortArray(\n    offset: Int,\n    destination: ShortArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int16Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        // TODO investigate this implementation vs DataView.getInt16(...)\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadShortArray(\n    offset: Long,\n    destination: ShortArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadShortArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadIntArray(\n    offset: Int,\n    destination: IntArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadIntArray(\n    offset: Long,\n    destination: IntArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadIntArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadLongArray(\n    offset: Int,\n    destination: LongArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count * 2)\n\n    if (isLittleEndianPlatform) {\n        for (index in 0 until count * 2 step 2) {\n            destination[index / 2 + destinationOffset] =\n                (typed[index + 1].reverseByteOrder().toLong() and 0xffffffffL) or\n                (typed[index].reverseByteOrder().toLong() shl 32)\n        }\n    } else {\n        for (index in 0 until count * 2 step 2) {\n            destination[index / 2 + destinationOffset] = (typed[index].toLong() and 0xffffffffL) or\n                (typed[index + 1].toLong() shl 32)\n        }\n    }\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadLongArray(\n    offset: Long,\n    destination: LongArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadLongArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadFloatArray(\n    offset: Int,\n    destination: FloatArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Float32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadFloatArray(\n    offset: Long,\n    destination: FloatArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadFloatArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadDoubleArray(\n    offset: Int,\n    destination: DoubleArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Float64Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadDoubleArray(\n    offset: Long,\n    destination: DoubleArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadDoubleArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies shorts integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeShortArray(\n    offset: Int,\n    source: ShortArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int16Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        // TODO investigate this implementation vs DataView.getInt16(...)\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies shorts integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeShortArray(\n    offset: Long,\n    source: ShortArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeShortArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeIntArray(\n    offset: Int,\n    source: IntArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeIntArray(\n    offset: Long,\n    source: IntArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeIntArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeLongArray(\n    offset: Int,\n    source: LongArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count * 2)\n\n    if (isLittleEndianPlatform) {\n        for (index in 0 until count * 2 step 2) {\n            val sourceIndex = index / 2 + sourceOffset\n            val sourceValue = source[sourceIndex]\n            typed[index] = (sourceValue ushr 32).toInt().reverseByteOrder()\n            typed[index + 1] = (sourceValue and 0xffffffffL).toInt().reverseByteOrder()\n        }\n    } else {\n        for (index in 0 until count * 2 step 2) {\n            val sourceIndex = index / 2 + sourceOffset\n            val sourceValue = source[sourceIndex]\n            typed[index] = (sourceValue ushr 32).toInt()\n            typed[index + 1] = (sourceValue and 0xffffffffL).toInt()\n        }\n    }\n}\n\n/**\n * Copies regular integers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeLongArray(\n    offset: Long,\n    source: LongArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeLongArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeFloatArray(\n    offset: Int,\n    source: FloatArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Float32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeFloatArray(\n    offset: Long,\n    source: FloatArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeFloatArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeDoubleArray(\n    offset: Int,\n    source: DoubleArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Float64Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeDoubleArray(\n    offset: Long,\n    source: DoubleArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeDoubleArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.khronos.webgl\n\nimport kotlin.js.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.encryptedmedia.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.mediasource.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\nimport org.w3c.xhr.*\n\npublic external interface WebGLContextAttributes {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var depth: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var stencil: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var antialias: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultipliedAlpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preserveDrawingBuffer: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preferLowPowerToHighPerformance: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var failIfMajorPerformanceCaveat: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextAttributes(alpha: Boolean? = true, depth: Boolean? = true, stencil: Boolean? = false, antialias: Boolean? = true, premultipliedAlpha: Boolean? = true, preserveDrawingBuffer: Boolean? = false, preferLowPowerToHighPerformance: Boolean? = false, failIfMajorPerformanceCaveat: Boolean? = false): WebGLContextAttributes {\n    val o = js(\"({})\")\n    o[\"alpha\"] = alpha\n    o[\"depth\"] = depth\n    o[\"stencil\"] = stencil\n    o[\"antialias\"] = antialias\n    o[\"premultipliedAlpha\"] = premultipliedAlpha\n    o[\"preserveDrawingBuffer\"] = preserveDrawingBuffer\n    o[\"preferLowPowerToHighPerformance\"] = preferLowPowerToHighPerformance\n    o[\"failIfMajorPerformanceCaveat\"] = failIfMajorPerformanceCaveat\n    return o\n}\n\npublic external abstract class WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLBuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLBuffer) to Kotlin\n */\npublic external abstract class WebGLBuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLFramebuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLFramebuffer) to Kotlin\n */\npublic external abstract class WebGLFramebuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLProgram](https://developer.mozilla.org/en/docs/Web/API/WebGLProgram) to Kotlin\n */\npublic external abstract class WebGLProgram : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLRenderbuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderbuffer) to Kotlin\n */\npublic external abstract class WebGLRenderbuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLShader](https://developer.mozilla.org/en/docs/Web/API/WebGLShader) to Kotlin\n */\npublic external abstract class WebGLShader : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLTexture](https://developer.mozilla.org/en/docs/Web/API/WebGLTexture) to Kotlin\n */\npublic external abstract class WebGLTexture : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLUniformLocation](https://developer.mozilla.org/en/docs/Web/API/WebGLUniformLocation) to Kotlin\n */\npublic external abstract class WebGLUniformLocation\n\n/**\n * Exposes the JavaScript [WebGLActiveInfo](https://developer.mozilla.org/en/docs/Web/API/WebGLActiveInfo) to Kotlin\n */\npublic external abstract class WebGLActiveInfo {\n    open val size: Int\n    open val type: Int\n    open val name: String\n}\n\n/**\n * Exposes the JavaScript [WebGLShaderPrecisionFormat](https://developer.mozilla.org/en/docs/Web/API/WebGLShaderPrecisionFormat) to Kotlin\n */\npublic external abstract class WebGLShaderPrecisionFormat {\n    open val rangeMin: Int\n    open val rangeMax: Int\n    open val precision: Int\n}\n\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface WebGLRenderingContextBase {\n    val canvas: HTMLCanvasElement\n    val drawingBufferWidth: Int\n    val drawingBufferHeight: Int\n    fun getContextAttributes(): WebGLContextAttributes?\n    fun isContextLost(): Boolean\n    fun getSupportedExtensions(): Array<String>?\n    fun getExtension(name: String): dynamic\n    fun activeTexture(texture: Int)\n    fun attachShader(program: WebGLProgram?, shader: WebGLShader?)\n    fun bindAttribLocation(program: WebGLProgram?, index: Int, name: String)\n    fun bindBuffer(target: Int, buffer: WebGLBuffer?)\n    fun bindFramebuffer(target: Int, framebuffer: WebGLFramebuffer?)\n    fun bindRenderbuffer(target: Int, renderbuffer: WebGLRenderbuffer?)\n    fun bindTexture(target: Int, texture: WebGLTexture?)\n    fun blendColor(red: Float, green: Float, blue: Float, alpha: Float)\n    fun blendEquation(mode: Int)\n    fun blendEquationSeparate(modeRGB: Int, modeAlpha: Int)\n    fun blendFunc(sfactor: Int, dfactor: Int)\n    fun blendFuncSeparate(srcRGB: Int, dstRGB: Int, srcAlpha: Int, dstAlpha: Int)\n    fun bufferData(target: Int, size: Int, usage: Int)\n    fun bufferData(target: Int, data: BufferDataSource?, usage: Int)\n    fun bufferSubData(target: Int, offset: Int, data: BufferDataSource?)\n    fun checkFramebufferStatus(target: Int): Int\n    fun clear(mask: Int)\n    fun clearColor(red: Float, green: Float, blue: Float, alpha: Float)\n    fun clearDepth(depth: Float)\n    fun clearStencil(s: Int)\n    fun colorMask(red: Boolean, green: Boolean, blue: Boolean, alpha: Boolean)\n    fun compileShader(shader: WebGLShader?)\n    fun compressedTexImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, data: ArrayBufferView)\n    fun compressedTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, data: ArrayBufferView)\n    fun copyTexImage2D(target: Int, level: Int, internalformat: Int, x: Int, y: Int, width: Int, height: Int, border: Int)\n    fun copyTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, x: Int, y: Int, width: Int, height: Int)\n    fun createBuffer(): WebGLBuffer?\n    fun createFramebuffer(): WebGLFramebuffer?\n    fun createProgram(): WebGLProgram?\n    fun createRenderbuffer(): WebGLRenderbuffer?\n    fun createShader(type: Int): WebGLShader?\n    fun createTexture(): WebGLTexture?\n    fun cullFace(mode: Int)\n    fun deleteBuffer(buffer: WebGLBuffer?)\n    fun deleteFramebuffer(framebuffer: WebGLFramebuffer?)\n    fun deleteProgram(program: WebGLProgram?)\n    fun deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?)\n    fun deleteShader(shader: WebGLShader?)\n    fun deleteTexture(texture: WebGLTexture?)\n    fun depthFunc(func: Int)\n    fun depthMask(flag: Boolean)\n    fun depthRange(zNear: Float, zFar: Float)\n    fun detachShader(program: WebGLProgram?, shader: WebGLShader?)\n    fun disable(cap: Int)\n    fun disableVertexAttribArray(index: Int)\n    fun drawArrays(mode: Int, first: Int, count: Int)\n    fun drawElements(mode: Int, count: Int, type: Int, offset: Int)\n    fun enable(cap: Int)\n    fun enableVertexAttribArray(index: Int)\n    fun finish()\n    fun flush()\n    fun framebufferRenderbuffer(target: Int, attachment: Int, renderbuffertarget: Int, renderbuffer: WebGLRenderbuffer?)\n    fun framebufferTexture2D(target: Int, attachment: Int, textarget: Int, texture: WebGLTexture?, level: Int)\n    fun frontFace(mode: Int)\n    fun generateMipmap(target: Int)\n    fun getActiveAttrib(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getActiveUniform(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getAttachedShaders(program: WebGLProgram?): Array<WebGLShader>?\n    fun getAttribLocation(program: WebGLProgram?, name: String): Int\n    fun getBufferParameter(target: Int, pname: Int): Any?\n    fun getParameter(pname: Int): Any?\n    fun getError(): Int\n    fun getFramebufferAttachmentParameter(target: Int, attachment: Int, pname: Int): Any?\n    fun getProgramParameter(program: WebGLProgram?, pname: Int): Any?\n    fun getProgramInfoLog(program: WebGLProgram?): String?\n    fun getRenderbufferParameter(target: Int, pname: Int): Any?\n    fun getShaderParameter(shader: WebGLShader?, pname: Int): Any?\n    fun getShaderPrecisionFormat(shadertype: Int, precisiontype: Int): WebGLShaderPrecisionFormat?\n    fun getShaderInfoLog(shader: WebGLShader?): String?\n    fun getShaderSource(shader: WebGLShader?): String?\n    fun getTexParameter(target: Int, pname: Int): Any?\n    fun getUniform(program: WebGLProgram?, location: WebGLUniformLocation?): Any?\n    fun getUniformLocation(program: WebGLProgram?, name: String): WebGLUniformLocation?\n    fun getVertexAttrib(index: Int, pname: Int): Any?\n    fun getVertexAttribOffset(index: Int, pname: Int): Int\n    fun hint(target: Int, mode: Int)\n    fun isBuffer(buffer: WebGLBuffer?): Boolean\n    fun isEnabled(cap: Int): Boolean\n    fun isFramebuffer(framebuffer: WebGLFramebuffer?): Boolean\n    fun isProgram(program: WebGLProgram?): Boolean\n    fun isRenderbuffer(renderbuffer: WebGLRenderbuffer?): Boolean\n    fun isShader(shader: WebGLShader?): Boolean\n    fun isTexture(texture: WebGLTexture?): Boolean\n    fun lineWidth(width: Float)\n    fun linkProgram(program: WebGLProgram?)\n    fun pixelStorei(pname: Int, param: Int)\n    fun polygonOffset(factor: Float, units: Float)\n    fun readPixels(x: Int, y: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun renderbufferStorage(target: Int, internalformat: Int, width: Int, height: Int)\n    fun sampleCoverage(value: Float, invert: Boolean)\n    fun scissor(x: Int, y: Int, width: Int, height: Int)\n    fun shaderSource(shader: WebGLShader?, source: String)\n    fun stencilFunc(func: Int, ref: Int, mask: Int)\n    fun stencilFuncSeparate(face: Int, func: Int, ref: Int, mask: Int)\n    fun stencilMask(mask: Int)\n    fun stencilMaskSeparate(face: Int, mask: Int)\n    fun stencilOp(fail: Int, zfail: Int, zpass: Int)\n    fun stencilOpSeparate(face: Int, fail: Int, zfail: Int, zpass: Int)\n    fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun texImage2D(target: Int, level: Int, internalformat: Int, format: Int, type: Int, source: TexImageSource?)\n    fun texParameterf(target: Int, pname: Int, param: Float)\n    fun texParameteri(target: Int, pname: Int, param: Int)\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, format: Int, type: Int, source: TexImageSource?)\n    fun uniform1f(location: WebGLUniformLocation?, x: Float)\n    fun uniform1fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform1fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform1i(location: WebGLUniformLocation?, x: Int)\n    fun uniform1iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform1iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform2f(location: WebGLUniformLocation?, x: Float, y: Float)\n    fun uniform2fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform2fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform2i(location: WebGLUniformLocation?, x: Int, y: Int)\n    fun uniform2iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform2iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform3f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float)\n    fun uniform3fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform3fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform3i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int)\n    fun uniform3iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform3iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform4f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float, w: Float)\n    fun uniform4fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform4fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform4i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int, w: Int)\n    fun uniform4iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform4iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun useProgram(program: WebGLProgram?)\n    fun validateProgram(program: WebGLProgram?)\n    fun vertexAttrib1f(index: Int, x: Float)\n    fun vertexAttrib1fv(index: Int, values: dynamic)\n    fun vertexAttrib2f(index: Int, x: Float, y: Float)\n    fun vertexAttrib2fv(index: Int, values: dynamic)\n    fun vertexAttrib3f(index: Int, x: Float, y: Float, z: Float)\n    fun vertexAttrib3fv(index: Int, values: dynamic)\n    fun vertexAttrib4f(index: Int, x: Float, y: Float, z: Float, w: Float)\n    fun vertexAttrib4fv(index: Int, values: dynamic)\n    fun vertexAttribPointer(index: Int, size: Int, type: Int, normalized: Boolean, stride: Int, offset: Int)\n    fun viewport(x: Int, y: Int, width: Int, height: Int)\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderingContext](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext) to Kotlin\n */\npublic external abstract class WebGLRenderingContext : WebGLRenderingContextBase, RenderingContext {\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLContextEvent](https://developer.mozilla.org/en/docs/Web/API/WebGLContextEvent) to Kotlin\n */\npublic external open class WebGLContextEvent(type: String, eventInit: WebGLContextEventInit = definedExternally) : Event {\n    open val statusMessage: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface WebGLContextEventInit : EventInit {\n    var statusMessage: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextEventInit(statusMessage: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): WebGLContextEventInit {\n    val o = js(\"({})\")\n    o[\"statusMessage\"] = statusMessage\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [ArrayBuffer](https://developer.mozilla.org/en/docs/Web/API/ArrayBuffer) to Kotlin\n */\npublic external open class ArrayBuffer(length: Int) : BufferDataSource {\n    open val byteLength: Int\n    fun slice(begin: Int, end: Int = definedExternally): ArrayBuffer\n\n    companion object {\n        fun isView(value: Any?): Boolean\n    }\n}\n\n/**\n * Exposes the JavaScript [ArrayBufferView](https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView) to Kotlin\n */\npublic external interface ArrayBufferView : BufferDataSource {\n    val buffer: ArrayBuffer\n    val byteOffset: Int\n    val byteLength: Int\n}\n\n/**\n * Exposes the JavaScript [Int8Array](https://developer.mozilla.org/en/docs/Web/API/Int8Array) to Kotlin\n */\npublic external open class Int8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int8Array, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int8Array.get(index: Int): Byte = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int8Array.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint8Array](https://developer.mozilla.org/en/docs/Web/API/Uint8Array) to Kotlin\n */\npublic external open class Uint8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8Array, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8Array.get(index: Int): Byte = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8Array.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint8ClampedArray](https://developer.mozilla.org/en/docs/Web/API/Uint8ClampedArray) to Kotlin\n */\npublic external open class Uint8ClampedArray : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8ClampedArray)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8ClampedArray, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint8ClampedArray\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8ClampedArray.get(index: Int): Byte = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8ClampedArray.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Int16Array](https://developer.mozilla.org/en/docs/Web/API/Int16Array) to Kotlin\n */\npublic external open class Int16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int16Array, offset: Int = definedExternally)\n    fun set(array: Array<Short>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int16Array.get(index: Int): Short = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int16Array.set(index: Int, value: Short) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint16Array](https://developer.mozilla.org/en/docs/Web/API/Uint16Array) to Kotlin\n */\npublic external open class Uint16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint16Array, offset: Int = definedExternally)\n    fun set(array: Array<Short>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint16Array.get(index: Int): Short = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint16Array.set(index: Int, value: Short) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Int32Array](https://developer.mozilla.org/en/docs/Web/API/Int32Array) to Kotlin\n */\npublic external open class Int32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int32Array, offset: Int = definedExternally)\n    fun set(array: Array<Int>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int32Array.get(index: Int): Int = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Int32Array.set(index: Int, value: Int) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint32Array](https://developer.mozilla.org/en/docs/Web/API/Uint32Array) to Kotlin\n */\npublic external open class Uint32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint32Array, offset: Int = definedExternally)\n    fun set(array: Array<Int>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint32Array.get(index: Int): Int = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint32Array.set(index: Int, value: Int) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Float32Array](https://developer.mozilla.org/en/docs/Web/API/Float32Array) to Kotlin\n */\npublic external open class Float32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float32Array)\n    constructor(array: Array<Float>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float32Array, offset: Int = definedExternally)\n    fun set(array: Array<Float>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Float32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float32Array.get(index: Int): Float = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float32Array.set(index: Int, value: Float) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Float64Array](https://developer.mozilla.org/en/docs/Web/API/Float64Array) to Kotlin\n */\npublic external open class Float64Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float64Array)\n    constructor(array: Array<Double>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float64Array, offset: Int = definedExternally)\n    fun set(array: Array<Double>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Float64Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float64Array.get(index: Int): Double = asDynamic()[index]\n\n@kotlin.internal.InlineOnly\npublic inline operator fun Float64Array.set(index: Int, value: Double) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [DataView](https://developer.mozilla.org/en/docs/Web/API/DataView) to Kotlin\n */\npublic external open class DataView(buffer: ArrayBuffer, byteOffset: Int = definedExternally, byteLength: Int = definedExternally) : ArrayBufferView {\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun getInt8(byteOffset: Int): Byte\n    fun getUint8(byteOffset: Int): Byte\n    fun getInt16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getUint16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getInt32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getUint32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getFloat32(byteOffset: Int, littleEndian: Boolean = definedExternally): Float\n    fun getFloat64(byteOffset: Int, littleEndian: Boolean = definedExternally): Double\n    fun setInt8(byteOffset: Int, value: Byte)\n    fun setUint8(byteOffset: Int, value: Byte)\n    fun setInt16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally)\n    fun setUint16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally)\n    fun setInt32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally)\n    fun setUint32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally)\n    fun setFloat32(byteOffset: Int, value: Float, littleEndian: Boolean = definedExternally)\n    fun setFloat64(byteOffset: Int, value: Double, littleEndian: Boolean = definedExternally)\n}\n\npublic external interface BufferDataSource\n\npublic external interface TexImageSource","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.js.*\nimport org.khronos.webgl.*\n\npublic actual abstract class Charset(internal val _name: String) {\n    public actual abstract fun newEncoder(): CharsetEncoder\n    public actual abstract fun newDecoder(): CharsetDecoder\n\n    public actual companion object {\n        public actual fun forName(name: String): Charset {\n            if (name == \"UTF-8\" || name == \"utf-8\" || name == \"UTF8\" || name == \"utf8\") return Charsets.UTF_8\n            if (name == \"ISO-8859-1\" || name == \"iso-8859-1\" || name.replace('_', '-').let {\n                it == \"iso-8859-1\" || it.toLowerCase() == \"iso-8859-1\"\n            } || name == \"latin1\"\n            ) {\n                return Charsets.ISO_8859_1\n            }\n            throw IllegalArgumentException(\"Charset $name is not supported\")\n        }\n    }\n}\n\npublic actual val Charset.name: String get() = _name\n\n// -----------------------\n\npublic actual abstract class CharsetEncoder(internal val _charset: Charset)\nprivate data class CharsetEncoderImpl(private val charset: Charset) : CharsetEncoder(charset)\npublic actual val CharsetEncoder.charset: Charset get() = _charset\n\npublic actual fun CharsetEncoder.encodeToByteArray(input: CharSequence, fromIndex: Int, toIndex: Int): ByteArray =\n    encodeToByteArrayImpl1(input, fromIndex, toIndex)\n\ninternal actual fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    require(fromIndex <= toIndex)\n    if (charset == Charsets.ISO_8859_1) {\n        return encodeISO88591(input, fromIndex, toIndex, dst)\n    }\n\n    require(charset === Charsets.UTF_8) { \"Only UTF-8 encoding is supported in JS\" }\n\n    val encoder = TextEncoder() // Only UTF-8 is supported so we know that at most 6 bytes per character is used\n    var start = fromIndex\n    var dstRemaining = dst.writeRemaining\n\n    while (start < toIndex && dstRemaining > 0) {\n        val numChars = minOf(toIndex - start, dstRemaining / 6).coerceAtLeast(1)\n        val dropLastChar = input[start + numChars - 1].isHighSurrogate()\n        val endIndexExclusive = when {\n            dropLastChar && numChars == 1 -> start + 2\n            dropLastChar -> start + numChars - 1\n            else -> start + numChars\n        }\n\n        val array1 = encoder.encode(input.substring(start, endIndexExclusive))\n        if (array1.length > dstRemaining) break\n        dst.writeFully(array1)\n        start = endIndexExclusive\n        dstRemaining -= array1.length\n    }\n\n    return start - fromIndex\n}\n\npublic actual fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output) {\n    require(charset === Charsets.UTF_8)\n    // we only support UTF-8 so as far as input is UTF-8 encoded string then we simply copy bytes\n    dst.writePacket(input)\n}\n\ninternal actual fun CharsetEncoder.encodeComplete(dst: Buffer): Boolean = true\n\n// ----------------------------------------------------------------------\n\npublic actual abstract class CharsetDecoder(internal val _charset: Charset)\n\nprivate data class CharsetDecoderImpl(private val charset: Charset) : CharsetDecoder(charset)\n\npublic actual val CharsetDecoder.charset: Charset get() = _charset\n\ninternal actual fun CharsetDecoder.decodeBuffer(\n    input: Buffer,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int\n): Int {\n    if (max == 0) return 0\n\n    val decoder = Decoder(charset.name)\n    val copied: Int\n\n    input.readDirectInt8Array { view ->\n        val result = view.decodeBufferImpl(decoder, max)\n        out.append(result.charactersDecoded)\n        copied = result.bytesConsumed\n\n        result.bytesConsumed\n    }\n\n    return copied\n}\n\npublic actual fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int {\n    val decoder = Decoder(charset.name, true)\n    var charactersCopied = 0\n\n    // use decode stream while we have remaining characters count > buffer size in bytes\n    // it is much faster than using decodeBufferImpl\n    input.takeWhileSize { buffer ->\n        val rem = max - charactersCopied\n        val bufferSize = buffer.readRemaining\n        if (rem < bufferSize) return@takeWhileSize 0\n\n        buffer.readDirectInt8Array { view ->\n            val decodedText = decodeWrap {\n                decoder.decodeStream(view, stream = true)\n            }\n            dst.append(decodedText)\n            charactersCopied += decodedText.length\n            view.byteLength\n        }\n\n        when {\n            charactersCopied == max -> {\n                val tail = try {\n                    decoder.decode()\n                } catch (_: dynamic) {\n                    \"\"\n                }\n\n                if (tail.isNotEmpty()) {\n                    // if we have a trailing byte then we can't handle this chunk via fast-path\n                    // because we don't know how many bytes in the end we need to preserve\n                    buffer.rewind(bufferSize)\n                }\n                0\n            }\n            charactersCopied < max -> MAX_CHARACTERS_SIZE_IN_BYTES\n            else -> 0\n        }\n    }\n\n    if (charactersCopied < max) {\n        var size = 1\n        input.takeWhileSize(1) { buffer ->\n            val rc = buffer.readDirectInt8Array { view ->\n                val result = view.decodeBufferImpl(decoder, max - charactersCopied)\n                dst.append(result.charactersDecoded)\n                charactersCopied += result.charactersDecoded.length\n                result.bytesConsumed\n            }\n            when {\n                rc > 0 -> size = 1\n                size == MAX_CHARACTERS_SIZE_IN_BYTES -> size = 0\n                else -> size++\n            }\n\n            size\n        }\n    }\n\n    return charactersCopied\n}\n\npublic actual fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String {\n    if (inputLength == 0) return \"\"\n    if (input is AbstractInput && input.headRemaining >= inputLength) {\n        val decoder = Decoder(charset._name, true)\n\n        val head = input.head\n        val view = input.headMemory.view\n\n        val text = decodeWrap {\n            val subView: ArrayBufferView = when {\n                head.readPosition == 0 && inputLength == view.byteLength -> view\n                else -> DataView(view.buffer, view.byteOffset + head.readPosition, inputLength)\n            }\n\n            decoder.decode(subView)\n        }\n\n        input.discardExact(inputLength)\n        return text\n    }\n\n    return decodeExactBytesSlow(input, inputLength)\n}\n\n// -----------------------------------------------------------\n\npublic actual object Charsets {\n    public actual val UTF_8: Charset = CharsetImpl(\"UTF-8\")\n    public actual val ISO_8859_1: Charset = CharsetImpl(\"ISO-8859-1\")\n}\n\nprivate data class CharsetImpl(val name: String) : Charset(name) {\n    override fun newEncoder(): CharsetEncoder = CharsetEncoderImpl(this)\n    override fun newDecoder(): CharsetDecoder = CharsetDecoderImpl(this)\n}\n\npublic actual open class MalformedInputException actual constructor(message: String) : Throwable(message)\n\nprivate fun CharsetDecoder.decodeExactBytesSlow(input: Input, inputLength: Int): String {\n    val decoder = Decoder(charset.name, true)\n    var inputRemaining = inputLength\n    val sb = StringBuilder(inputLength)\n\n    decodeWrap {\n        input.takeWhileSize(6) { buffer ->\n            val chunkSize = buffer.readRemaining\n            val size = minOf(chunkSize, inputRemaining)\n            val text = when {\n                buffer.readPosition == 0 && buffer.memory.view.byteLength == size -> decoder.decodeStream(\n                    buffer.memory.view,\n                    true\n                )\n                else -> decoder.decodeStream(\n                    Int8Array(\n                        buffer.memory.view.buffer,\n                        buffer.memory.view.byteOffset + buffer.readPosition,\n                        size\n                    ),\n                    true\n                )\n            }\n            sb.append(text)\n\n            buffer.discardExact(size)\n            inputRemaining -= size\n\n            if (inputRemaining > 0) 6 else 0\n        }\n\n        if (inputRemaining > 0) {\n            input.takeWhile { buffer ->\n                val chunkSize = buffer.readRemaining\n                val size = minOf(chunkSize, inputRemaining)\n                val text = when {\n                    buffer.readPosition == 0 && buffer.memory.view.byteLength == size -> {\n                        decoder.decode(buffer.memory.view)\n                    }\n                    else -> decoder.decodeStream(\n                        Int8Array(\n                            buffer.memory.view.buffer,\n                            buffer.memory.view.byteOffset + buffer.readPosition,\n                            size\n                        ),\n                        true\n                    )\n                }\n                sb.append(text)\n                buffer.discardExact(size)\n                inputRemaining -= size\n                true\n            }\n        }\n\n        sb.append(decoder.decode())\n    }\n\n    if (inputRemaining > 0) {\n        throw EOFException(\n            \"Not enough bytes available: had only ${inputLength - inputRemaining} instead of $inputLength\"\n        )\n    }\n    return sb.toString()\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@OptIn(ExperimentalStdlibApi::class)\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.uppercase()\n                s2 = s2.uppercase()\n                if (s1 != s2) {\n                    s1 = s1.lowercase()\n                    s2 = s2.lowercase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","@file:Suppress(\"ReplaceRangeToWithUntil\", \"RedundantModalityModifier\", \"DEPRECATION\", \"DEPRECATION_ERROR\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport org.khronos.webgl.*\nimport kotlin.contracts.*\n\n@Suppress(\"DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES\")\n@Deprecated(\"Use Buffer instead.\", replaceWith = ReplaceWith(\"Buffer\", \"io.ktor.utils.io.core.Buffer\"))\npublic actual class IoBuffer internal actual constructor(\n    memory: Memory,\n    origin: ChunkBuffer?,\n    parentPool: ObjectPool<IoBuffer>?\n) : Input, Output, ChunkBuffer(memory, origin, parentPool as? ObjectPool<ChunkBuffer>) {\n    private val content: ArrayBuffer get() = memory.view.buffer\n\n    public actual constructor(\n        memory: Memory,\n        origin: ChunkBuffer?\n    ) : this(memory, origin, null)\n\n    override val endOfInput: Boolean get() = writePosition == readPosition\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n            \"do readXXX/writeXXX with X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    actual final override var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            if (newOrder != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only big endian is supported\")\n            }\n        }\n\n    final override fun peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n        return (this as Buffer).peekTo(destination, destinationOffset, offset, min, max)\n    }\n\n    final override fun tryPeek(): Int {\n        return tryPeekByte()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        if (readRemaining < length) {\n            throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        }\n\n        if (length > dst.byteLength) {\n            throw IllegalArgumentException(\n                \"Destination buffer overflow: length = $length, buffer capacity ${dst.byteLength}\"\n            )\n        }\n        require(offset >= 0) { \"offset should be positive\" }\n        require(offset + length <= dst.byteLength) { throw IndexOutOfBoundsException(\"\") }\n\n        (this as Buffer).readFully(dst.buffer, dst.byteOffset + offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(length, readRemaining)\n        (this as Buffer).readFully(dst, offset, size)\n        return size\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: IoBuffer, length: Int) {\n        (this as Buffer).readFully(dst, length)\n    }\n\n    final override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq ?: \"null\", start, end)\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    final override fun append(csq: CharSequence?): Appendable {\n        return if (csq == null) append(\"null\") else append(csq, 0, csq.length)\n    }\n\n    final override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq, start, end)\n\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    override fun append(c: Char): Appendable {\n        (this as Buffer).append(c)\n        return this\n    }\n\n    @Deprecated(\n        \"Use writeFully instead\",\n        ReplaceWith(\"writeFully(array, offset, length)\"),\n        level = DeprecationLevel.ERROR\n    )\n    public fun write(array: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(array, offset, length)\n    }\n\n    @Deprecated(\n        \"Use writeFully instead\",\n        ReplaceWith(\"writeFully(array, offset, length)\"),\n        level = DeprecationLevel.ERROR\n    )\n    public fun write(src: Int8Array, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readShort(): Short {\n        return (this as Buffer).readShort()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readInt(): Int {\n        return (this as Buffer).readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFloat(): Float {\n        return (this as Buffer).readFloat()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readDouble(): Double {\n        return (this as Buffer).readDouble()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: IntArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: LongArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun peekTo(buffer: IoBuffer): Int {\n        return (this as Input).peekTo(buffer)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readLong(): Long {\n        return (this as Buffer).readLong()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeShort(v: Short) {\n        (this as Buffer).writeShort(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeInt(v: Int) {\n        (this as Buffer).writeInt(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFloat(v: Float) {\n        (this as Buffer).writeFloat(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeDouble(v: Double) {\n        (this as Buffer).writeDouble(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: IntArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: LongArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: IoBuffer, length: Int) {\n        (this as Buffer).writeFully(src, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun fill(n: Long, v: Byte) {\n        (this as Buffer).fill(n, v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun writeLong(v: Long) {\n        (this as Buffer).writeLong(v)\n    }\n\n    @Deprecated(\"Use writeFully instead\", ReplaceWith(\"writeFully(src, length)\"), level = DeprecationLevel.ERROR)\n    public fun writeBuffer(src: IoBuffer, length: Int): Int {\n        (this as Buffer).writeFully(src, length)\n        return length\n    }\n\n    actual final override fun flush() {\n    }\n\n    @PublishedApi\n    internal fun readableView(): DataView {\n        val readPosition = readPosition\n        val writePosition = writePosition\n\n        return when {\n            readPosition == writePosition -> EmptyDataView\n            readPosition == 0 && writePosition == content.byteLength -> memory.view\n            else -> DataView(content, readPosition, writePosition - readPosition)\n        }\n    }\n\n    @PublishedApi\n    internal fun writableView(): DataView {\n        val writePosition = writePosition\n        val limit = limit\n\n        return when {\n            writePosition == limit -> EmptyDataView\n            writePosition == 0 && limit == content.byteLength -> memory.view\n            else -> DataView(content, writePosition, limit - writePosition)\n        }\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of readable bytes.\n     * The [block] function should return number of consumed bytes.\n     * @return number of bytes consumed\n     */\n    @ExperimentalIoApi\n    public inline fun readDirect(block: (DataView) -> Int): Int {\n        val view = readableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        discard(rc)\n        return rc\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of the free space.\n     * The [block] function should return number of written bytes.\n     * @return number of bytes written\n     */\n    @ExperimentalIoApi\n    public inline fun writeDirect(block: (DataView) -> Int): Int {\n        val view = writableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        check(rc <= writeRemaining) { \"The returned value from block function is too big: $rc > $writeRemaining\" }\n        commitWritten(rc)\n        return rc\n    }\n\n    public actual fun release(pool: ObjectPool<IoBuffer>) {\n        releaseImpl(pool)\n    }\n\n    actual override fun close() {\n        throw UnsupportedOperationException(\"close for buffer view is not supported\")\n    }\n\n    override fun toString(): String =\n        \"Buffer[readable = $readRemaining, writable = $writeRemaining, startGap = $startGap, endGap = $endGap]\"\n\n    public actual companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [IoBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        public actual val ReservedSize: Int\n            get() = Buffer.ReservedSize\n\n        private val EmptyBuffer = ArrayBuffer(0)\n        private val EmptyDataView = DataView(EmptyBuffer)\n\n        public actual val Empty: IoBuffer = IoBuffer(Memory.Empty, null, EmptyBufferPoolImpl)\n\n        /**\n         * The default buffer pool\n         */\n        public actual val Pool: ObjectPool<IoBuffer> = object : DefaultPool<IoBuffer>(BUFFER_VIEW_POOL_SIZE) {\n            override fun produceInstance(): IoBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null, this)\n            }\n\n            override fun clearInstance(instance: IoBuffer): IoBuffer {\n                return super.clearInstance(instance).apply {\n                    unpark()\n                    reset()\n                }\n            }\n\n            override fun validateInstance(instance: IoBuffer) {\n                super.validateInstance(instance)\n\n                require(instance.referenceCount == 0) {\n                    \"unable to recycle buffer: buffer view is in use (refCount = ${instance.referenceCount})\"\n                }\n                require(instance.origin == null) {\n                    \"Unable to recycle buffer view: view copy shouldn't be recycled\"\n                }\n            }\n\n            override fun disposeInstance(instance: IoBuffer) {\n                DefaultAllocator.free(instance.memory)\n                instance.unlink()\n            }\n        }\n\n        public actual val NoPool: ObjectPool<IoBuffer> = object : NoPoolImpl<IoBuffer>() {\n            override fun borrow(): IoBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null, this)\n            }\n\n            override fun recycle(instance: IoBuffer) {\n                DefaultAllocator.free(instance.memory)\n            }\n        }\n\n        public actual val EmptyPool: ObjectPool<IoBuffer> = EmptyBufferPoolImpl\n    }\n}\n\npublic fun Buffer.readFully(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        memory.copyTo(dst, start, length, offset)\n        length\n    }\n}\n\npublic fun Buffer.readFully(dst: ArrayBufferView, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        memory.copyTo(dst, start, length, offset)\n        length\n    }\n}\n\npublic fun Buffer.readAvailable(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (!canRead()) return -1\n    val readSize = minOf(length, readRemaining)\n    readFully(dst, offset, readSize)\n    return readSize\n}\n\npublic fun Buffer.readAvailable(dst: ArrayBufferView, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (!canRead()) return -1\n    val readSize = minOf(length, readRemaining)\n    readFully(dst, offset, readSize)\n    return readSize\n}\n\npublic fun Buffer.writeFully(src: ArrayBuffer, offset: Int = 0, length: Int = src.byteLength) {\n    write { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw InsufficientSpaceException(\"Not enough free space to write $length bytes\")\n        }\n\n        src.copyTo(memory, offset, length, start)\n        length\n    }\n}\n\npublic fun Buffer.writeFully(src: ArrayBufferView, offset: Int = 0, length: Int = src.byteLength - offset) {\n    write { memory, dstOffset, endExclusive ->\n        if (endExclusive - dstOffset < length) {\n            throw InsufficientSpaceException(\"Not enough free space to write $length bytes\")\n        }\n\n        src.copyTo(memory, offset, length, dstOffset)\n        length\n    }\n}\n\npublic inline fun Buffer.writeDirect(block: (DataView) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return write { memory, start, endExclusive ->\n        block(memory.slice(start, endExclusive - start).view)\n    }\n}\n\npublic inline fun Buffer.readDirect(block: (DataView) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return read { memory, start, endExclusive ->\n        block(memory.slice(start, endExclusive - start).view)\n    }\n}\n\npublic inline fun Buffer.writeDirectInt8Array(block: (Int8Array) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return write { memory, start, endExclusive ->\n        block(Int8Array(memory.view.buffer, memory.view.byteOffset + start, endExclusive - start))\n    }\n}\n\npublic inline fun Buffer.readDirectInt8Array(block: (Int8Array) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return read { memory, start, endExclusive ->\n        block(Int8Array(memory.view.buffer, memory.view.byteOffset + start, endExclusive - start))\n    }\n}\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\n@Deprecated(\n    \"Use readText with charset instead\",\n    ReplaceWith(\n        \"readText(Charset.forName(encoding), max)\",\n        \"io.ktor.utils.io.core.readText\",\n        \"io.ktor.utils.io.charsets.Charset\"\n    )\n)\npublic fun ByteReadPacket.readText(encoding: String, max: Int = Int.MAX_VALUE): String =\n    readText(Charset.forName(encoding), max)\n\n@Deprecated(\n    \"Use readText with charset instead\",\n    ReplaceWith(\n        \"readText(out, Charset.forName(encoding), max)\",\n        \"io.ktor.utils.io.core.readText\",\n        \"io.ktor.utils.io.charsets.Charset\"\n    )\n)\npublic fun ByteReadPacket.readText(encoding: String = \"UTF-8\", out: Appendable, max: Int = Int.MAX_VALUE): Int {\n    return readText(out, Charset.forName(encoding), max)\n}\n\ninternal inline fun <R> decodeWrap(block: () -> R): R {\n    try {\n        return block()\n    } catch (t: Throwable) {\n        throw MalformedInputException(\"Failed to decode bytes: ${t.message ?: \"no cause provided\"}\")\n    }\n}\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.js\n\nimport org.khronos.webgl.*\n\ninternal fun Decoder(encoding: String, fatal: Boolean = true): Decoder = try {\n    TextDecoder(encoding, textDecoderOptions(fatal)).toKtor()\n} catch (cause: Throwable) {\n    TextDecoderFallback(encoding, fatal)\n}\n\ninternal interface Decoder {\n    fun decode(): String\n    fun decode(buffer: ArrayBufferView): String\n    fun decode(buffer: ArrayBufferView, options: dynamic): String\n}\n\ninternal inline fun Decoder.decodeStream(buffer: ArrayBufferView, stream: Boolean): String {\n    decodeWrap {\n        return decode(buffer, decodeOptions(stream))\n    }\n}\n\ninternal fun decodeOptions(stream: Boolean): dynamic = Any().apply {\n    with(this.asDynamic()) {\n        this.stream = stream\n    }\n}\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.js.*\nimport org.khronos.webgl.*\n\n// I don't know any characters that have longer characters\ninternal const val MAX_CHARACTERS_SIZE_IN_BYTES: Int = 8\nprivate const val MAX_CHARACTERS_COUNT = Int.MAX_VALUE / MAX_CHARACTERS_SIZE_IN_BYTES\n\ninternal data class DecodeBufferResult(val charactersDecoded: String, val bytesConsumed: Int)\n\ninternal fun Int8Array.decodeBufferImpl(nativeDecoder: Decoder, maxCharacters: Int): DecodeBufferResult {\n    if (maxCharacters == 0) {\n        return DecodeBufferResult(\"\", 0)\n    }\n\n    // fast-path: try to assume that we have 1 byte per character content\n    try {\n        val sizeInBytes = maxCharacters.coerceAtMost(byteLength)\n        val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n        if (text.length <= maxCharacters) {\n            return DecodeBufferResult(text, sizeInBytes)\n        }\n    } catch (_: dynamic) {\n    }\n\n    return decodeBufferImplSlow(nativeDecoder, maxCharacters)\n}\n\nprivate fun Int8Array.decodeBufferImplSlow(nativeDecoder: Decoder, maxCharacters: Int): DecodeBufferResult {\n    val maxBytes = when {\n        maxCharacters >= MAX_CHARACTERS_COUNT -> Int.MAX_VALUE\n        else -> maxCharacters * MAX_CHARACTERS_SIZE_IN_BYTES\n    }.coerceAtMost(byteLength)\n\n    var sizeInBytes = maxBytes\n    while (sizeInBytes > MAX_CHARACTERS_SIZE_IN_BYTES) {\n        try {\n            val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n            if (text.length <= maxCharacters) {\n                return DecodeBufferResult(text, sizeInBytes)\n            }\n        } catch (_: dynamic) {\n        }\n\n        sizeInBytes /= 2\n    }\n\n    sizeInBytes = MAX_CHARACTERS_SIZE_IN_BYTES\n    while (sizeInBytes > 0) {\n        try {\n            val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n            if (text.length <= maxCharacters) {\n                return DecodeBufferResult(text, sizeInBytes)\n            }\n        } catch (_: dynamic) {\n        }\n\n        sizeInBytes--\n    }\n\n    // all attempts were failed so most likely we have a broken character but we can't find it for some reason\n    // so the following decode most likely will fail\n    decodeWrap {\n        nativeDecoder.decode(this)\n    }\n\n    // if it didn't for some reason we have no idea what to do\n    throw MalformedInputException(\"Unable to decode buffer\")\n}\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\ninternal fun encodeISO88591(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    if (fromIndex >= toIndex) return 0\n\n    dst.writeDirect { view ->\n        val i8 = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n        var writeIndex = 0\n        for (index in fromIndex until toIndex) {\n            val character = input[index].toInt()\n            if (character > 0xff) {\n                failedToMapError(character)\n            }\n            i8[writeIndex++] = character.toByte()\n        }\n        writeIndex\n    }\n    return toIndex - fromIndex\n}\n\nprivate fun failedToMapError(ch: Int): Nothing {\n    throw MalformedInputException(\"The character with unicode point $ch couldn't be mapped to ISO-8859-1 character\")\n}\n","// ktlint-disable filename\n/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\ninternal actual class AbstractInputSharedState actual constructor(\n    actual var head: ChunkBuffer,\n    remaining: Long\n) {\n    actual var headMemory: Memory = head.memory\n\n    actual var headPosition: Int = head.readPosition\n\n    actual var headEndExclusive: Int = head.writePosition\n\n    actual var tailRemaining: Long = remaining - (headEndExclusive - headPosition)\n}\n","// ktlint-disable filename\n/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\ninternal actual class AbstractOutputSharedState {\n    actual var head: ChunkBuffer? = null\n\n    actual var tail: ChunkBuffer? = null\n\n    actual var tailMemory: Memory = Memory.Empty\n\n    actual var tailPosition: Int = 0\n\n    actual var tailEndExclusive: Int = 0\n\n    actual var tailInitialPosition: Int = 0\n\n    actual var chainedSize: Int = 0\n}\n","// ktlint-disable filename\n/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.core\n\ninternal actual class BufferSharedState actual constructor(actual var limit: Int) {\n    actual var readPosition: Int = 0\n\n    actual var writePosition: Int = 0\n\n    actual var startGap: Int = 0\n\n    actual var attachment: Any? = null\n}\n","// ktlint-disable filename\npackage io.ktor.utils.io.core\n\nimport org.khronos.webgl.*\n\npublic actual enum class ByteOrder {\n    BIG_ENDIAN, LITTLE_ENDIAN;\n\n    public actual companion object {\n        private val native: ByteOrder\n\n        init {\n            val buffer = ArrayBuffer(4)\n            val arr = Int32Array(buffer)\n            val view = DataView(buffer)\n\n            arr[0] = 0x11223344\n\n            native = if (view.getInt32(0, true) == 0x11223344) LITTLE_ENDIAN else BIG_ENDIAN\n        }\n\n        public actual fun nativeOrder(): ByteOrder = native\n    }\n}\n","@file:Suppress(\"FunctionName\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport org.khronos.webgl.*\n\npublic actual fun ByteReadPacket(\n    array: ByteArray,\n    offset: Int,\n    length: Int,\n    block: (ByteArray) -> Unit\n): ByteReadPacket {\n    val content = array.asDynamic() as Int8Array\n    val sub = when {\n        offset == 0 && length == array.size -> content.buffer\n        else -> content.buffer.slice(offset, offset + length)\n    }\n\n    val pool = object : SingleInstancePool<ChunkBuffer>() {\n        override fun produceInstance(): ChunkBuffer {\n            @Suppress(\"DEPRECATION\")\n            return IoBuffer(Memory.of(sub), null, this as ObjectPool<IoBuffer>)\n        }\n\n        override fun disposeInstance(instance: ChunkBuffer) {\n            @Suppress(\"DEPRECATION\")\n            check(instance is IoBuffer) { \"Only IoBuffer could be recycled\" }\n            block(array)\n        }\n    }\n\n    return ByteReadPacket(pool.borrow().apply { resetForRead() }, pool)\n}\n","package io.ktor.utils.io.core\n\npublic actual interface Closeable {\n    public actual fun close()\n}\n\n@PublishedApi\ninternal actual fun Throwable.addSuppressedInternal(other: Throwable) {\n}\n","@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\n\npublic fun Input.readFully(dst: Int8Array, offset: Int = 0, length: Int = dst.length - offset) {\n    if (this is AbstractInput) {\n        return readFully(dst, offset, length)\n    }\n\n    val rc = readAvailable(dst, offset, length)\n    if (rc != length) {\n        prematureEndOfStream(length)\n    }\n}\n\npublic fun Input.readFully(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    if (this is AbstractInput) {\n        return readFully(dst, offset, length)\n    }\n\n    val rc = readAvailable(dst, offset, length)\n    if (rc != length) {\n        prematureEndOfStream(length)\n    }\n}\n\npublic fun Input.readFully(dst: ArrayBufferView, byteOffset: Int = 0, byteLength: Int = dst.byteLength - byteOffset) {\n    if (this is AbstractInput) {\n        return readFully(dst, byteOffset, byteLength)\n    }\n\n    val rc = readAvailable(dst, byteOffset, byteLength)\n    if (rc != byteLength) {\n        prematureEndOfStream(byteLength)\n    }\n}\n\npublic fun Input.readAvailable(dst: Int8Array, offset: Int = 0, length: Int = dst.length - offset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\")\n    return readAvailable(dst as ArrayBufferView, offset, length)\n}\n\n@Suppress(\"Duplicates\")\npublic fun Input.readAvailable(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, offset, length)\n    }\n\n    var bytesCopied = 0\n    takeWhile { buffer ->\n        val partSize = minOf(buffer.readRemaining, length - bytesCopied)\n        buffer.memory.copyTo(dst, buffer.readPosition, partSize, bytesCopied)\n        bytesCopied += partSize\n        bytesCopied < length\n    }\n\n    return bytesCopied\n}\n\n@Suppress(\"Duplicates\")\npublic fun Input.readAvailable(\n    dst: ArrayBufferView,\n    byteOffset: Int = 0,\n    byteLength: Int = dst.byteLength - byteOffset\n): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, byteOffset, byteLength)\n    }\n\n    var bytesCopied = 0\n    takeWhile { buffer ->\n        val partSize = minOf(buffer.readRemaining, byteLength - bytesCopied)\n        buffer.memory.copyTo(dst, buffer.readPosition, partSize, bytesCopied)\n        bytesCopied += partSize\n        bytesCopied < byteLength\n    }\n\n    return bytesCopied\n}\n\ninternal fun AbstractInput.readFully(dst: Int8Array, offset: Int, length: Int) {\n    @Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\")\n    return readFully(dst as ArrayBufferView, offset, length)\n}\n\ninternal fun AbstractInput.readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n    if (remaining < length) {\n        throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n    }\n\n    var copied = 0\n    takeWhile { buffer: Buffer ->\n        val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n        if (rc > 0) copied += rc\n        copied < length\n    }\n}\n\ninternal fun AbstractInput.readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n    require(length <= dst.byteLength) {\n        throw IndexOutOfBoundsException(\"length $length is greater than view size ${dst.byteLength}\")\n    }\n\n    return readFully(dst.buffer, dst.byteOffset + offset, length)\n}\n\ninternal fun AbstractInput.readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n\ninternal fun AbstractInput.readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n\ninternal fun AbstractInput.readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n","// ktlint-disable filename\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport org.khronos.webgl.*\n\n/**\n * Shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\n@Suppress(\"NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS\")\npublic actual interface Input : Closeable {\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read and readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newValue) {\n            if (newValue != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only BIG_ENDIAN is supported\")\n            }\n        }\n\n    /**\n     * It is `true` when it is known that no more bytes will be available. When it is `false` then this means that\n     * it is not known yet or there are available bytes.\n     * Please note that `false` value doesn't guarantee that there are available bytes so `readByte()` may fail.\n     */\n    public actual val endOfInput: Boolean\n\n    /**\n     * Copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes then\n     * it fails with an exception.\n     * It is safe to specify `max > destination.writeRemaining` but\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source reading that may lead to blocking I/O.\n     * It is safe to specify too big [offset] but only if `min = 0`, fails otherwise.\n     * This function usually copy more bytes than [min] (unless `max = min`).\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     * @throws Throwable when not enough bytes available to provide\n     */\n    public actual fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long\n\n    /**\n     * Read the next upcoming byte\n     * @throws EOFException if no more bytes available.\n     */\n    public actual fun readByte(): Byte\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readShort(): Short {\n        return readShort()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readInt(): Int {\n        return readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readLong(): Long {\n        return readLong()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFloat(): Float {\n        return readFloat()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readDouble(): Double {\n        return readDouble()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: IntArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: LongArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"DEPRECATION\")\n    public actual fun readFully(dst: IoBuffer, length: Int) {\n        return readFully(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"DEPRECATION\")\n    public actual fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return readAvailable(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    public actual fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * If the underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"DEPRECATION\", \"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    public actual fun discard(n: Long): Long\n\n    actual override fun close()\n}\n","// ktlint-disable filename\npackage io.ktor.utils.io.core\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\n@Suppress(\"NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS\")\npublic actual interface Output : Appendable, Closeable {\n    @Deprecated(\"Write with writeXXXLittleEndian or do X.reverseByteOrder() and then writeXXX instead.\")\n    public actual var byteOrder: ByteOrder\n\n    public actual fun writeByte(v: Byte)\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeShort(v: Short) {\n        writeShort(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeInt(v: Int) {\n        writeInt(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeLong(v: Long) {\n        writeLong(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFloat(v: Float) {\n        writeFloat(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeDouble(v: Double) {\n        writeDouble(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: IntArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: LongArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: IoBuffer, length: Int) {\n        writeFully(src, length)\n    }\n\n    public actual fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public actual fun fill(n: Long, v: Byte) {\n        fill(n, v)\n    }\n\n    public actual fun flush()\n\n    actual override fun close()\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\n\npublic actual val PACKET_MAX_COPY_SIZE: Int = 200\ninternal const val BUFFER_VIEW_POOL_SIZE = 100\ninternal const val BUFFER_VIEW_SIZE = 4096\n\npublic actual fun BytePacketBuilder(headerSizeHint: Int): BytePacketBuilder =\n    BytePacketBuilder(headerSizeHint, ChunkBuffer.Pool)\n\npublic actual typealias EOFException = io.ktor.utils.io.errors.EOFException\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport org.khronos.webgl.*\n\nprivate fun Memory.asInt8Array(): Int8Array {\n    return Int8Array(view.buffer, view.byteOffset, view.byteLength)\n}\n\ninternal actual fun Buffer.discardUntilDelimiterImpl(delimiter: Byte): Int {\n    val content = memory.asInt8Array()\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        if (content[idx] == delimiter) break\n        idx++\n    }\n\n    val start = readPosition\n    discardUntilIndex(idx)\n    return idx - start\n}\n\ninternal actual fun Buffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int {\n    val content = memory.asInt8Array()\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        val v = content[idx]\n        if (v == delimiter1 || v == delimiter2) break\n        idx++\n    }\n\n    val start = readPosition\n    discardUntilIndex(idx)\n    return idx - start\n}\n\ninternal actual fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n\n    return readUntilImpl({ it == delimiter }, dst, offset, length)\n}\n\ninternal actual fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte,\n    delimiter2: Byte,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst, offset, length)\n}\n\ninternal actual fun Buffer.readUntilDelimiterImpl(delimiter: Byte, dst: Output): Int {\n    return readUntilImpl({ it == delimiter }, dst)\n}\n\ninternal actual fun Buffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte, dst: Output): Int {\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst)\n}\n\nprivate inline fun Buffer.readUntilImpl(\n    predicate: (Byte) -> Boolean,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int {\n    val array = memory.asInt8Array()\n    val start = readPosition\n    var i = start\n    val end = i + minOf(length, readRemaining)\n\n    while (i < end) {\n        if (predicate(array[i])) break\n        i++\n    }\n\n    val copied = i - start\n    val dstArray = dst.asDynamic() as Int8Array\n    dstArray.set(array.subarray(start, end), offset)\n    discardUntilIndex(i)\n\n    return copied\n}\n\nprivate inline fun Buffer.readUntilImpl(\n    predicate: (Byte) -> Boolean,\n    dst: Output\n): Int {\n    val array = memory.asInt8Array()\n    var i = readPosition\n    var copiedTotal = 0\n\n    dst.writeWhile { chunk ->\n        chunk.writeFully(chunk, 0)\n        val start = i\n        val end = minOf(i + chunk.writeRemaining, writePosition)\n\n        while (i < end) {\n            if (predicate(array[i])) break\n            i++\n        }\n\n        val size = i - start\n\n        chunk.memory.asInt8Array().set(array.subarray(start, i), chunk.writePosition)\n        chunk.commitWritten(size)\n        copiedTotal += size\n\n        chunk.writeRemaining == 0 && i < end\n    }\n\n    discardUntilIndex(i)\n    return copiedTotal\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.require\n\n/**\n * Create an instance of [String] from the specified [bytes] range starting at [offset] and bytes [length]\n * interpreting characters in the specified [charset].\n */\n@Suppress(\"FunctionName\")\npublic actual fun String(bytes: ByteArray, offset: Int, length: Int, charset: Charset): String {\n    if (offset < 0 || length < 0 || offset + length > bytes.size) {\n        checkIndices(offset, length, bytes)\n    }\n\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val i8: Int8Array = bytes.asDynamic() // we know that K/JS generates Int8Array for ByteBuffer\n    val bufferOffset = i8.byteOffset + offset\n    val buffer = i8.buffer.slice(bufferOffset, bufferOffset + length)\n\n    @Suppress(\"DEPRECATION\")\n    val view = IoBuffer(Memory.of(buffer), null, IoBuffer.NoPool)\n    view.resetForRead()\n    val packet = ByteReadPacket(view, ChunkBuffer.NoPoolManuallyManaged)\n\n    return charset.newDecoder().decode(packet, Int.MAX_VALUE)\n}\n\npublic fun checkIndices(offset: Int, length: Int, bytes: ByteArray): Nothing {\n    require(offset >= 0) { throw IndexOutOfBoundsException(\"offset ($offset) shouldn't be negative\") }\n    require(length >= 0) { throw IndexOutOfBoundsException(\"length ($length) shouldn't be negative\") }\n    require(offset + length <= bytes.size) {\n        throw IndexOutOfBoundsException(\"offset ($offset) + length ($length) > bytes.size (${bytes.size})\")\n    }\n\n    throw IndexOutOfBoundsException()\n}\n\ninternal actual fun String.getCharsInternal(dst: CharArray, dstOffset: Int) {\n    val length = length\n    require(dstOffset + length <= dst.size)\n\n    var dstIndex = dstOffset\n    for (srcIndex in 0 until length) {\n        dst[dstIndex++] = this[srcIndex]\n    }\n}\n","package io.ktor.utils.io.errors\n\npublic actual open class IOException actual constructor(message: String, cause: Throwable?) :\n    Exception(message, cause) {\n    public actual constructor(message: String) : this(message, null)\n}\n\npublic actual open class EOFException actual constructor(message: String) : IOException(message)\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.js\n\nimport org.khronos.webgl.*\n\ninternal external class TextDecoder(encoding: String, options: dynamic = definedExternally) {\n    val encoding: String\n\n    fun decode(): String\n    fun decode(buffer: ArrayBuffer): String\n    fun decode(buffer: ArrayBuffer, options: dynamic): String\n    fun decode(buffer: ArrayBufferView): String\n    fun decode(buffer: ArrayBufferView, options: dynamic): String\n}\n\ninternal fun TextDecoder.toKtor(): Decoder = object : Decoder {\n    override fun decode(): String = this@toKtor.decode()\n    override fun decode(buffer: ArrayBufferView): String = this@toKtor.decode(buffer)\n    override fun decode(buffer: ArrayBufferView, options: dynamic): String = this@toKtor.decode(buffer, options)\n}\n\ninternal fun textDecoderOptions(fatal: Boolean = false): Any = Any().apply {\n    with(this.asDynamic()) {\n        this.fatal = fatal\n    }\n}\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.js\n\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\nprivate val ENCODING_ALIASES = setOf(\n    \"ansi_x3.4-1968\",\n    \"ascii\",\n    \"cp1252\",\n    \"cp819\",\n    \"csisolatin1\",\n    \"ibm819\",\n    \"iso-8859-1\",\n    \"iso-ir-100\",\n    \"iso8859-1\",\n    \"iso88591\",\n    \"iso_8859-1\",\n    \"iso_8859-1:1987\",\n    \"l1\",\n    \"latin1\",\n    \"us-ascii\",\n    \"windows-1252\",\n    \"x-cp1252\"\n)\n\nprivate val REPLACEMENT = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Windows-1252 decoder.\n *\n * According to https://encoding.spec.whatwg.org/, ISO-8859-1 should be treated as windows-1252 for http.\n */\ninternal class TextDecoderFallback(\n    encoding: String,\n    val fatal: Boolean\n) : Decoder {\n\n    init {\n        val requestedEncoding = encoding.trim().toLowerCase()\n        check(ENCODING_ALIASES.contains(requestedEncoding)) { \"$encoding is not supported.\" }\n    }\n\n    override fun decode(): String = \"\"\n\n    override fun decode(buffer: ArrayBufferView): String = buildPacket {\n        val bytes = buffer as Int8Array\n        for (index in 0 until bytes.length) {\n            val byte = bytes[index]\n            val point: Int = byte.toCodePoint()\n\n            if (point < 0) {\n                check(!fatal) { \"Invalid character: $point\" }\n                writeFully(REPLACEMENT)\n                continue\n            }\n\n            if (point > 0xFF) {\n                writeByte((point shr 8).toByte())\n            }\n\n            writeByte((point and 0xFF).toByte())\n        }\n    }.readBytes().decodeToString()\n\n    override fun decode(buffer: ArrayBufferView, options: dynamic): String {\n        return decode(buffer)\n    }\n}\n\nprivate fun Byte.toCodePoint(): Int {\n    val value = toInt() and 0xFF\n    if (value.isASCII()) {\n        return value\n    }\n\n    return WIN1252_TABLE[value - 0x80]\n}\n\nprivate fun Int.isASCII(): Boolean = this in 0..0x7F\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\n/**\n * Read exactly [n] bytes to a new array buffer instance\n */\npublic fun ByteReadPacket.readArrayBuffer(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to make a new ArrayBuffer: packet is too big\")\n): ArrayBuffer {\n    val buffer = ArrayBuffer(n)\n    readFully(buffer, 0, n)\n    return buffer\n}\n\n/**\n * Write exactly [length] bytes from the specified [src] array buffer\n */\npublic fun BytePacketBuilder.writeFully(src: ArrayBuffer, offset: Int = 0, length: Int = src.byteLength - offset) {\n    writeFully(Int8Array(src), offset, length)\n}\n\n/**\n * Write exactly [length] bytes from the specified [src] typed array\n */\npublic fun BytePacketBuilder.writeFully(src: Int8Array, offset: Int = 0, length: Int = src.length - offset) {\n    var written = 0\n    var rem = length\n\n    while (rem > 0) {\n        write(1) { bb: Buffer ->\n            val size = minOf(bb.writeRemaining, rem)\n            bb.writeFully(src, written + offset, size)\n            written += size\n            rem -= size\n            size\n        }\n    }\n}\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport org.w3c.dom.*\n\npublic fun WebSocket.sendPacket(packet: ByteReadPacket) {\n    send(packet.readArrayBuffer())\n}\n\npublic inline fun WebSocket.sendPacket(block: BytePacketBuilder.() -> Unit) {\n    sendPacket(buildPacket(block = block))\n}\n\npublic inline fun MessageEvent.packet(): ByteReadPacket {\n    @Suppress(\"NON_PUBLIC_CALL_FROM_PUBLIC_INLINE\", \"UnsafeCastFromDynamic\", \"DEPRECATION\")\n    return ByteReadPacket(IoBuffer(Memory.of(data.asDynamic() as DataView), null, IoBuffer.NoPool), ChunkBuffer.NoPool)\n}\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport org.w3c.xhr.*\n\npublic inline fun XMLHttpRequest.sendPacket(block: BytePacketBuilder.() -> Unit) {\n    sendPacket(buildPacket(block = block))\n}\n\npublic fun XMLHttpRequest.sendPacket(packet: ByteReadPacket) {\n    send(packet.readArrayBuffer())\n}\n\n@Suppress(\"UnsafeCastFromDynamic\", \"DEPRECATION\")\npublic fun XMLHttpRequest.responsePacket(): ByteReadPacket = when (responseType) {\n    XMLHttpRequestResponseType.ARRAYBUFFER -> ByteReadPacket(\n        IoBuffer(\n            Memory.of(response.asDynamic() as DataView),\n            null,\n            IoBuffer.NoPool\n        ),\n        ChunkBuffer.NoPoolManuallyManaged\n    )\n    XMLHttpRequestResponseType.EMPTY -> ByteReadPacket.Empty\n    else -> throw IllegalStateException(\"Incompatible type $responseType: only ARRAYBUFFER and EMPTY are supported\")\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.w3c.xhr\n\nimport kotlin.js.*\nimport org.khronos.webgl.*\nimport org.w3c.css.masking.*\nimport org.w3c.dom.*\nimport org.w3c.dom.clipboard.*\nimport org.w3c.dom.css.*\nimport org.w3c.dom.encryptedmedia.*\nimport org.w3c.dom.events.*\nimport org.w3c.dom.mediacapture.*\nimport org.w3c.dom.mediasource.*\nimport org.w3c.dom.parsing.*\nimport org.w3c.dom.pointerevents.*\nimport org.w3c.dom.svg.*\nimport org.w3c.dom.url.*\nimport org.w3c.fetch.*\nimport org.w3c.files.*\nimport org.w3c.notifications.*\nimport org.w3c.performance.*\nimport org.w3c.workers.*\n\n/**\n * Exposes the JavaScript [XMLHttpRequestEventTarget](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequestEventTarget) to Kotlin\n */\npublic external abstract class XMLHttpRequestEventTarget : EventTarget {\n    open var onloadstart: ((ProgressEvent) -> dynamic)?\n    open var onprogress: ((ProgressEvent) -> dynamic)?\n    open var onabort: ((Event) -> dynamic)?\n    open var onerror: ((Event) -> dynamic)?\n    open var onload: ((Event) -> dynamic)?\n    open var ontimeout: ((Event) -> dynamic)?\n    open var onloadend: ((Event) -> dynamic)?\n}\n\npublic external abstract class XMLHttpRequestUpload : XMLHttpRequestEventTarget\n\n/**\n * Exposes the JavaScript [XMLHttpRequest](https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest) to Kotlin\n */\npublic external open class XMLHttpRequest : XMLHttpRequestEventTarget {\n    var onreadystatechange: ((Event) -> dynamic)?\n    open val readyState: Short\n    var timeout: Int\n    var withCredentials: Boolean\n    open val upload: XMLHttpRequestUpload\n    open val responseURL: String\n    open val status: Short\n    open val statusText: String\n    var responseType: XMLHttpRequestResponseType\n    open val response: Any?\n    open val responseText: String\n    open val responseXML: Document?\n    fun open(method: String, url: String)\n    fun open(method: String, url: String, async: Boolean, username: String? = definedExternally, password: String? = definedExternally)\n    fun setRequestHeader(name: String, value: String)\n    fun send(body: dynamic = definedExternally)\n    fun abort()\n    fun getResponseHeader(name: String): String?\n    fun getAllResponseHeaders(): String\n    fun overrideMimeType(mime: String)\n\n    companion object {\n        val UNSENT: Short\n        val OPENED: Short\n        val HEADERS_RECEIVED: Short\n        val LOADING: Short\n        val DONE: Short\n    }\n}\n\n/**\n * Exposes the JavaScript [FormData](https://developer.mozilla.org/en/docs/Web/API/FormData) to Kotlin\n */\npublic external open class FormData(form: HTMLFormElement = definedExternally) {\n    fun append(name: String, value: String)\n    fun append(name: String, value: Blob, filename: String = definedExternally)\n    fun delete(name: String)\n    fun get(name: String): dynamic\n    fun getAll(name: String): Array<dynamic>\n    fun has(name: String): Boolean\n    fun set(name: String, value: String)\n    fun set(name: String, value: Blob, filename: String = definedExternally)\n}\n\n/**\n * Exposes the JavaScript [ProgressEvent](https://developer.mozilla.org/en/docs/Web/API/ProgressEvent) to Kotlin\n */\npublic external open class ProgressEvent(type: String, eventInitDict: ProgressEventInit = definedExternally) : Event {\n    open val lengthComputable: Boolean\n    open val loaded: Number\n    open val total: Number\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface ProgressEventInit : EventInit {\n    var lengthComputable: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var loaded: Number? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n    var total: Number? /* = 0 */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@kotlin.internal.InlineOnly\npublic inline fun ProgressEventInit(lengthComputable: Boolean? = false, loaded: Number? = 0, total: Number? = 0, bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): ProgressEventInit {\n    val o = js(\"({})\")\n    o[\"lengthComputable\"] = lengthComputable\n    o[\"loaded\"] = loaded\n    o[\"total\"] = total\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/* please, don't implement this interface! */\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface XMLHttpRequestResponseType {\n    companion object\n}\n\npublic inline val XMLHttpRequestResponseType.Companion.EMPTY: XMLHttpRequestResponseType get() = \"\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.ARRAYBUFFER: XMLHttpRequestResponseType get() = \"arraybuffer\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.BLOB: XMLHttpRequestResponseType get() = \"blob\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.DOCUMENT: XMLHttpRequestResponseType get() = \"document\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.JSON: XMLHttpRequestResponseType get() = \"json\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()\n\npublic inline val XMLHttpRequestResponseType.Companion.TEXT: XMLHttpRequestResponseType get() = \"text\".asDynamic().unsafeCast<XMLHttpRequestResponseType>()","package io.ktor.utils.io.pool\n\npublic actual abstract class DefaultPool<T : Any>\nactual constructor(actual final override val capacity: Int) : ObjectPool<T> {\n\n    private val instances = arrayOfNulls<Any?>(capacity)\n    private var size = 0\n\n    protected actual abstract fun produceInstance(): T\n    protected actual open fun disposeInstance(instance: T) {}\n\n    protected actual open fun clearInstance(instance: T): T = instance\n    protected actual open fun validateInstance(instance: T) {}\n\n    actual final override fun borrow(): T {\n        if (size == 0) return produceInstance()\n        val idx = --size\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val instance = instances[idx] as T\n        instances[idx] = null\n\n        return clearInstance(instance)\n    }\n\n    actual final override fun recycle(instance: T) {\n        validateInstance(instance)\n        if (size == capacity) {\n            disposeInstance(instance)\n        } else {\n            instances[size++] = instance\n        }\n    }\n\n    actual final override fun dispose() {\n        for (i in 0 until size) {\n            @Suppress(\"UNCHECKED_CAST\")\n            val instance = instances[i] as T\n            instances[i] = null\n            disposeInstance(instance)\n        }\n        size = 0\n    }\n}\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.js\n\n/**\n * Mapping for non-ascii characters for Windows-1252 encoding.\n *\n * https://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP1252.TXT\n */\ninternal val WIN1252_TABLE = intArrayOf(\n    0x20AC,\n    -1,\n    0x201A,\n    0x0192,\n    0x201E,\n    0x2026,\n    0x2020,\n    0x2021,\n    0x02C6,\n    0x2030,\n    0x0160,\n    0x2039,\n    0x0152,\n    -1,\n    0x017D,\n    -1,\n    -1,\n    0x2018,\n    0x2019,\n    0x201C,\n    0x201D,\n    0x2022,\n    0x2013,\n    0x2014,\n    0x02DC,\n    0x2122,\n    0x0161,\n    0x203A,\n    0x0153,\n    -1,\n    0x017E,\n    0x0178,\n    0x00A0,\n    0x00A1,\n    0x00A2,\n    0x00A3,\n    0x00A4,\n    0x00A5,\n    0x00A6,\n    0x00A7,\n    0x00A8,\n    0x00A9,\n    0x00AA,\n    0x00AB,\n    0x00AC,\n    0x00AD,\n    0x00AE,\n    0x00AF,\n    0x00B0,\n    0x00B1,\n    0x00B2,\n    0x00B3,\n    0x00B4,\n    0x00B5,\n    0x00B6,\n    0x00B7,\n    0x00B8,\n    0x00B9,\n    0x00BA,\n    0x00BB,\n    0x00BC,\n    0x00BD,\n    0x00BE,\n    0x00BF,\n    0x00C0,\n    0x00C1,\n    0x00C2,\n    0x00C3,\n    0x00C4,\n    0x00C5,\n    0x00C6,\n    0x00C7,\n    0x00C8,\n    0x00C9,\n    0x00CA,\n    0x00CB,\n    0x00CC,\n    0x00CD,\n    0x00CE,\n    0x00CF,\n    0x00D0,\n    0x00D1,\n    0x00D2,\n    0x00D3,\n    0x00D4,\n    0x00D5,\n    0x00D6,\n    0x00D7,\n    0x00D8,\n    0x00D9,\n    0x00DA,\n    0x00DB,\n    0x00DC,\n    0x00DD,\n    0x00DE,\n    0x00DF,\n    0x00E0,\n    0x00E1,\n    0x00E2,\n    0x00E3,\n    0x00E4,\n    0x00E5,\n    0x00E6,\n    0x00E7,\n    0x00E8,\n    0x00E9,\n    0x00EA,\n    0x00EB,\n    0x00EC,\n    0x00ED,\n    0x00EE,\n    0x00EF,\n    0x00F0,\n    0x00F1,\n    0x00F2,\n    0x00F3,\n    0x00F4,\n    0x00F5,\n    0x00F6,\n    0x00F7,\n    0x00F8,\n    0x00F9,\n    0x00FA,\n    0x00FB,\n    0x00FC,\n    0x00FD,\n    0x00FE,\n    0x00FF\n)\n"],"names":[],"mappings":"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AAO,CAAQ,OAAR,kBAAQ,iBAAQ,uBAAR,CAAR,mBAAiC,kBAAQ,iBAAQ,CAAR,C;;;;;;;;;;;;;;EACpD,C;EAJA,kF;mBAAA,2E;QAAA,S;aAAA,Q;;aAAA,uB;EAIA,C;EAEA,+B;IACqC,gBAA1B,mCAAY,KAAK,S;IhBElB,SgBFqC,gB;IhBErC,SgBFyD,uBAAc,CAAd,C;IAA/D,OhBGO,S;EgBFX,C;EAEA,oC;IAEI,8C;MAD2E,OAChD,6B;;MADgD,OAEnE,I;G;ECxEZ,qC;IAI+C,O1BuUF,gB0BvUY,mB1BsOhB,c0BtOgB,C1BuUZ,C;G;E0BrU7C,uC;IAI2C,OzBkWJ,cyBlWY,mBzB6Pd,cyB7Pc,CzBkWZ,C;G;EyBhWvC,uC;IAI6C,OxB2WH,ewB3WY,mBxBkQf,cwBlQe,CxB2WZ,C;G;+GwBxWH,yB;IAAA,0B;IAAA,4B;MAAQ,OAAiB,OAAhB,cAAa,CAAG,C;K;GAAzB,C;6GAGD,yB;IAAA,0B;IAAA,4B;MAAQ,OAAmB,OAAlB,YAAY,GAAM,C;K;GAA3B,C;iHAGC,yB;IAAA,4B;IAAA,4B;MAAQ,OAAe,QAAd,cAAU,EAAI,C;K;GAAvB,C;+GAGD,yB;IAAA,4B;IAAA,4B;MAAQ,OAAkB,QAAjB,YAAS,KAAQ,C;K;GAA1B,C;6GAGF,qB;IAAQ,OAAC,6BAAU,EAAV,CAAc,Q;G;2GAGxB,yB;IAAA,kBAAkB,sB;IAAlB,4B;MAAQ,OAAC,0BAAsB,Q;K;GAA/B,C;+FCiBnC,4B;IAG0D,ORxD3C,cAAK,SQwD6C,KRxD7C,C;G;+FQ0DpB,yB;ICnFA,8F;IDmFA,mC;MRnDe,yB;MS7BX,IDmF8D,KCnF1D,eAAQ,UAAZ,C;QAA2B,wBDmFmC,KCnFnC,ET6Be,OS7Bf,C;MDmF4B,ORtDvC,aQsD8C,KClFvD,QT4BS,C;K;GQmDpB,C;6FAKA,yB;ICxFA,8F;IDwFA,0C;MR1CQ,yB;MS3CJ,IDwF4E,KCxFxE,eAAQ,UAAZ,C;QAA2B,wBDwFiD,KCxFjD,ET2CQ,OS3CR,C;MT2ClB,aQ6CmE,KCvFrE,QT0CE,EQ6C0E,KR7C1E,C;K;GQ0Cb,C;+FAKA,mC;IRtDQ,cAAK,SQyDkE,KRzDlE,EQyDyE,KRzDzE,C;G;qGQ2Db,yB;IClGA,8F;IDkGA,0C;MAGoE,cAAe,KtBqJ5C,K;Mc5M/B,yB;MS3CJ,IDkGwE,KClGpE,eAAQ,UAAZ,C;QAA2B,wBDkG6C,KClG7C,ET2CQ,OS3CR,C;MT2ClB,aQuD+D,KCjGjE,QT0CE,EAAoC,OAApC,C;K;GQoDb,C;uGAKA,mC;IRhEQ,cAAK,SQmE8D,KRnE9D,EQmEqE,KtBgJ3C,KcnN1B,C;G;EQ+Eb,0D;IAKI,oBAAO,WAAP,EAAoB,MAApB,EAA4B,MAA5B,EAAwD,CAAxD,C;EACJ,C;EAQA,0D;IAKI,oBAAO,WAAP,EAAoB,MAApB,EAA4B,MAA5B,EAAwD,CAAxD,C;EACJ,C;2GEtHA,yB;IAcA,kC;IAdA,8B;MAWW,aAAgB,oBAAL,IAAK,C;MAgBhB,Q;MAFP,gBAAgB,qB;MAChB,aAAa,SAAU,eAAM,MAAN,C;;QAEnB,OAjB6B,KAiB7B,CAAM,MAAN,C;;QAEA,SAAU,cAAK,MAAL,C;;MAnBd,W;IACJ,C;GAZA,C;6GAcA,yB;IAAA,kC;IAAA,8B;MAaW,Q;MAFP,gBAAgB,qB;MAChB,aAAa,SAAU,eAAM,IAAN,C;;QAEnB,aAAM,MAAN,C;;QAEA,SAAU,cAAK,MAAL,C;;MAHd,W;IAKJ,C;GAlBA,C;;;;;;;;+GCZA,yB;I9BsUA,sC;I8BtUA,oC;MAG6D,O9B6UhB,gBMlWqB,cAAK,UwBqBE,MxBrBF,EAAiB,KAAjB,CNkW1B,C;K;G8BhV7C,C;iHAKA,yB;IF3BA,8F;I5B4VA,sC;I8BjUA,oC;MFxBI,IE2BsE,MF3BlE,eAAQ,UAAZ,C;QAA2B,wBE2B2C,MF3B3C,EtBGmE,QsBHnE,C;ME2B+B,O9BwUjB,gBMlWqB,cAAK,UwB0BG,MF1B/D,QtBA4D,EAAiB,KAAjB,CNkW1B,C;K;G8B3U7C,C;iHAKA,oC;IxBYI,cAAK,UwBT+E,MxBS/E,EwBTuF,K9BkOvD,KMzNhC,EAAuC,KAAvC,C;G;mHwBPT,yB;IFrCA,8F;IEqCA,2C;MAG4E,cAAqB,K9B6NxD,K;MMlNrC,yB;MsBhDA,IEqCqF,MFrCjF,eAAQ,UAAZ,C;QAA2B,wBEqC0D,MFrC1D,EtBgDM,QsBhDN,C;MtBgDtB,cwBXgF,MFpC9E,QtB+CF,EAAuC,OAAvC,EAA6D,KAA7D,C;K;GwBdT,C;2GAyBA,yB;I7B+TA,kC;I6B/TA,oC;MAGyD,O7BsUlB,cK/XuB,cAAK,UwByDA,MxBzDA,EAAiB,KAAjB,CL+X5B,C;K;G6BzUvC,C;6GAKA,yB;IFnEA,8F;I3B6XA,kC;I6B1TA,oC;MFhEI,IEmEgE,MFnE5D,eAAQ,UAAZ,C;QAA2B,wBEmEqC,MFnErC,EtBO6D,QsBP7D,C;MEmE2B,O7BiUnB,cK/XuB,cAAK,UwB8DC,MFlEzD,QtBIwD,EAAiB,KAAjB,CL+X5B,C;K;G6BpUvC,C;6GAKA,oC;IxB1CI,cAAK,UwB6CyE,MxB7CzE,EwB6CiF,K7BuNrD,KKpQ5B,EAAuC,KAAvC,C;G;+GwB+CT,yB;IF7EA,8F;IE6EA,2C;MAGwE,cAAmB,K7BkNtD,K;MK7PjC,yB;MsBlCA,IE6E+E,MF7E3E,eAAQ,UAAZ,C;QAA2B,wBE6EoD,MF7EpD,EtBkCM,QsBlCN,C;MtBkCtB,cwB2C0E,MF5ExE,QtBiCF,EAAuC,OAAvC,EAA6D,KAA7D,C;K;GwBwCT,C;6GAyBA,yB;I5BsSA,oC;I4BtSA,oC;MAG2D,O5B6SjB,eIzYP,oBAA9B,cAAK,WwB4F4D,MxB5F5D,EAAkB,KAAlB,CAAyB,CAA9B,WAA2C,EAA3C,CAAD,IACsC,oBAAlC,cAAK,WwB2FyD,MxB3F/C,GAAS,CAAT,IAAV,EAAsB,KAAtB,CAA6B,CADtC,CJyYsC,C;K;G4BhT1C,C;+GAKA,yB;IF3GA,8F;I1B4YA,oC;I4BjSA,oC;MFxGI,IE2GmE,MF3G/D,eAAQ,UAAZ,C;QAA2B,wBE2GwC,MF3GxC,EtBagE,QsBbhE,C;MtBakC,ewB8FM,MF1G5D,Q;ME0GiD,O5BwSlB,eIzYP,oBAA9B,cAAK,WAAU,QAAV,EAAkB,KAAlB,CAAyB,CAA9B,WAA2C,EAA3C,CAAD,IACsC,oBAAlC,cAAK,WAAU,WAAS,CAAT,IAAV,EAAsB,KAAtB,CAA6B,CADtC,CJyYsC,C;K;G4B3S1C,C;+GAKA,yB;IxB1DA,kBAKyC,sB;IwBqDzC,2C;MAGyE,cAAoB,K5B0LtD,K;MInPnC,cAAK,UwByD4E,MxBzD5E,EAAkB,mBAAU,EAAV,CAAc,QAAhC,EAAwD,KAAxD,C;MACL,cAAK,UwBwD4E,MxBxDnE,GAAS,CAAT,IAAT,EAAsB,wBAAuB,QAA7C,EAAqE,KAArE,C;K;GwBqDT,C;iHAKA,yB;IFrHA,8F;ItBsDA,kBAKyC,sB;IwB0DzC,2C;MAG0E,cAAoB,K5BqLvD,K;M0B1SnC,IEqHkF,MFrH9E,eAAQ,UAAZ,C;QAA2B,wBEqHuD,MFrHvD,EtB+DI,QsB/DJ,C;MtB+D3B,ewBsDkF,MFpH3E,Q;MtBsDP,cAAK,UAAS,QAAT,EAQqC,OARnB,YAAU,EAAV,CAAc,QAAhC,EAAwD,KAAxD,C;MACL,cAAK,UAAS,WAAS,CAAT,IAAT,EAOqC,OAPf,iBAAuB,QAA7C,EAAqE,KAArE,C;K;GwB0DT,C;iHCnHA,yB;IAAA,mD;IAAA,2E;MAOI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,OAAZ,GAAmB,iBAAnB,I;MAEb,kBAAO,WAAP,EAAoB,MAApB,EAA4B,KAA5B,EAAmC,iBAAnC,C;IACJ,C;GAXA,C;mHAaA,yB;IAAA,mD;IAAA,2E;MAQI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,OAAZ,GAAmB,iBAAnB,I;MAEb,kBAAO,WAAP,EAAoB,MAApB,EAA4B,KAA5B,EAAmC,iBAAnC,C;IACJ,C;GAZA,C;mHAcA,yB;IAAA,mD;IAAA,2E;MAQI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,KAAZ,GAAmB,iBAAnB,I;MAEb,kBAAO,WCkkGA,QDlkGP,EAAkC,MAAlC,EAA0C,KAA1C,EAAiD,iBAAjD,C;IACJ,C;GAZA,C;oHAcA,yB;IAAA,mD;IAAA,2E;MAQI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,KAAZ,GAAmB,iBAAnB,I;MAEb,kBAAO,WCojGA,QDpjGP,EAAkC,MAAlC,EAA0C,KAA1C,EAAiD,iBAAjD,C;IACJ,C;GAZA,C;qHAsCA,yB;IAAA,mE;IAAA,2E;MAQI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,KAAZ,GAAmB,iBAAnB,I;MAEb,0BAAe,MAAf,EAAuB,WC2kGhB,QD3kGP,EAAmD,iBAAnD,EAAsE,KAAtE,C;IACJ,C;GAZA,C;uHAcA,yB;IAAA,mE;IAAA,2E;MAQI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,KAAZ,GAAmB,iBAAnB,I;MAEb,0BAAe,MAAf,EAAuB,WC6jGhB,QD7jGP,EAAmD,iBAAnD,EAAsE,KAAtE,C;IACJ,C;GAZA,C;iHAsCA,yB;IAAA,+D;IAAA,2E;MAQI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,KAAZ,GAAmB,iBAAnB,I;MAEb,wBAAa,MAAb,EAAqB,WCq+Fd,QDr+FP,EAA+C,iBAA/C,EAAkE,KAAlE,C;IACJ,C;GAZA,C;mHAcA,yB;IAAA,+D;IAAA,2E;MAQI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,KAAZ,GAAmB,iBAAnB,I;MAEb,wBAAa,MAAb,EAAqB,WCu9Fd,QDv9FP,EAA+C,iBAA/C,EAAkE,KAAlE,C;IACJ,C;GAZA,C;mHAsCA,yB;IAAA,iE;IAAA,2E;MAQI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,KAAZ,GAAmB,iBAAnB,I;MAEb,yBAAc,MAAd,EAAsB,WCw9Ff,QDx9FP,EAAiD,iBAAjD,EAAoE,KAApE,C;IACJ,C;GAZA,C;qHAcA,yB;IAAA,iE;IAAA,2E;MAQI,iC;QAAA,oBAAyB,C;MACzB,qB;QAAA,QAAa,WAAY,KAAZ,GAAmB,iBAAnB,I;MAEb,yBAAc,MAAd,EAAsB,WC08Ff,QD18FP,EAAiD,iBAAjD,EAAoE,KAApE,C;IACJ,C;GAZA,C;mHA8DA,yB;IEjQA,2C;IAAA,2C;IFiQA,iE;MAOI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,OAAP,GAAc,YAAd,I;ME/PC,GAAP,gBAAO,EFiQd,MEjQc,EFiQG,YEjQH,EFiQiB,KEjQjB,CFkQG,2BAAa,CAAb,gB;IAErB,C;GAbA,C;qHAeA,yB;IAAA,SAWkC,gB;IE3RlC,2C;IAAA,2C;IFgRA,iE;MAOI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,OAAP,GAAc,YAAd,I;ME9QC,GAAP,gBAAO,EFgRd,MEhRc,EFgRG,YEhRH,EFgRiB,KEhRjB,CFiRG,+BAAuB,0BAAvB,S;IAErB,C;GAbA,C;qHAeA,yB;IE/RA,2C;IAAA,2C;IF+RA,iE;MAOI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,KAAP,GAAc,YAAd,I;MAEb,eAAuB,MC6zFhB,Q;MC5lGO,GAAP,gBAAO,EFiQd,QEjQc,EF+R+B,YE/R/B,EF+R6C,KE/R7C,CFkQG,2BAAa,CAAb,EA6B0C,KA7B1C,EA6BF,MA7BE,C;IA8BrB,C;GAXA,C;sHAaA,yB;IA5BA,SAWkC,gB;IE3RlC,2C;IAAA,2C;IF4SA,iE;MAOI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,KAAP,GAAc,YAAd,I;MAEb,eAAuB,MCgzFhB,Q;MC5lGO,GAAP,gBAAO,EFgRd,QEhRc,EF4S+B,YE5S/B,EF4S6C,KE5S7C,CFiRG,+BAAuB,oBA2BmB,KA3BnB,CAAvB,EA2BF,MA3BE,C;IA4BrB,C;GAXA,C;uHAqCA,yB;IAAA,qE;IAAA,iE;MAQI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,KAAP,GAAc,YAAd,I;MAEb,2BAAgB,MAAhB,EAAwB,MCu0FjB,QDv0FP,EAA+C,YAA/C,EAA6D,KAA7D,C;IACJ,C;GAZA,C;yHAcA,yB;IAAA,qE;IAAA,iE;MAQI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,KAAP,GAAc,YAAd,I;MAEb,2BAAgB,MAAhB,EAAwB,MCyzFjB,QDzzFP,EAA+C,YAA/C,EAA6D,KAA7D,C;IACJ,C;GAZA,C;mHAsCA,yB;IAAA,iE;IAAA,iE;MAQI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,KAAP,GAAc,YAAd,I;MAEb,yBAAc,MAAd,EAAsB,MCiuFf,QDjuFP,EAA2C,YAA3C,EAAyD,KAAzD,C;IACJ,C;GAZA,C;qHAcA,yB;IAAA,iE;IAAA,iE;MAQI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,KAAP,GAAc,YAAd,I;MAEb,yBAAc,MAAd,EAAsB,MCmtFf,QDntFP,EAA2C,YAA3C,EAAyD,KAAzD,C;IACJ,C;GAZA,C;qHAsCA,yB;IAAA,mE;IAAA,iE;MAQI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,KAAP,GAAc,YAAd,I;MAEb,0BAAe,MAAf,EAAuB,MCotFhB,QDptFP,EAA6C,YAA7C,EAA2D,KAA3D,C;IACJ,C;GAZA,C;uHAcA,yB;IAAA,mE;IAAA,iE;MAQI,4B;QAAA,eAAoB,C;MACpB,qB;QAAA,QAAa,MAAO,KAAP,GAAc,YAAd,I;MAEb,0BAAe,MAAf,EAAuB,MCssFhB,QDtsFP,EAA6C,YAA7C,EAA2D,KAA3D,C;IACJ,C;GAZA,C;E5BpbA,2D;IAKI,wBAAa,GAAb,EAAkB,KAAlB,EAAyB,SAAzB,EAAoC,OAApC,C;EACJ,C;EASA,qE;IAMI,yB;MAAA,YAAiB,C;IACjB,uB;MAAA,UAAe,KAAM,O;IAErB,OAAO,6BAAkB,KAAlB,EAAyB,SAAzB,EAAoC,OAApC,C;EACX,C;EAKA,wD;IAGI,yB;MAAA,YAAiB,C;IACjB,uB;MAAA,UAAe,KAAM,O;IACL,sB;IkB5ChB,cAAc,oBALkC,CAKlC,C;;MlB6Cd,wBkB3CU,OlB2CV,4B;MkB1CI,qBAAO,OAAQ,Q;;MACjB,gC;QACE,OAAQ,U;QACR,MAAM,C;;QALV,O;;IlB2CgB,yB;G;EAIpB,sC;IAC8E,sB;IkBjD1E,cAAc,oBALkC,CAKlC,C;;MlBkDd,+BkBhDU,OlBgDV,C;MkB/CI,qBAAO,OAAQ,Q;;MACjB,gC;QACE,OAAQ,U;QACR,MAAM,C;;QALV,O;;IlBgD0E,yB;G;EAI9E,6D;IAEI,gBAAY,SAAZ,C;IAEA,IAAI,WAAS,OAAb,C;MAAsB,M;I+BwJtB,WAAW,mB/BvJX,G+BuJW,E/BvJQ,C+BuJR,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,gB;Q/B3JX,SAAS,kCAAuB,OAAvB,W+B2JQ,I/B3JR,C;QJoBb,IAAI,EInBM,MAAM,CJmBZ,CAAJ,C;UACI,cAdW,e;UAeX,MAAM,2BAAsB,OAAQ,WAA9B,C;SIpBN,oBAAS,EAAT,I;QAGI,uB;UALJ,eAKwB,C;eACpB,WAAM,CAAN,C;UANJ,eAMe,C;;UANf,eAOY,C;;Q+BoJR,mB;QACA,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,mB/B9Jf,G+B8Je,EAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,iB/BjKJ,G+BiKI,EAAe,IAAf,C;;I/BrJJ,8BAAmB,GAAnB,C;EACJ,C;EAYA,uC;IAC+C,mB;MAAA,MAAW,U;IAC1C,QAAU,oBAAJ,GAAI,C;IAAV,QAA0B,aAAN,KAAM,C;IC6TP,kBAAxB,qBD7T+C,CLwK3C,kBAAK,CAAL,MAAJ,GAAY,CAAZ,GAAmB,CKxK4B,SC6T/C,C;ID5TH,2BMpBJ,WNoBI,M;IADJ,OMlBO,WL+U6C,W;G;ED3SvB,uC;IAAoB,mCAAwB,OAAxB,C;;G;;;;;;EAIrD,oE;IACI,aAAa,UAAU,SAAV,I;IACb,OAAO,sBAAW,sBAAkB,KAAlB,EAAyB,SAAzB,EAAoC,MAApC,CAAX,EAAwD,CAAxD,EAA2D,MAA3D,EAAmE,GAAnE,C;EACX,C;EAaA,sE;IAEI,yB;MAAA,YAAiB,C;IACjB,uB;MAAA,UAAe,KAAM,O;IAErB,gBAAY,SAAZ,C;IACA,IAAI,WAAS,OAAb,C;MAAsB,OAAO,c;IAC7B,aAAa,mCAAY,KAAK,S;;MAG1B,SAAS,sBAAW,KAAX,EAAkB,OAAlB,EAAyB,OAAzB,EAAkC,MAAlC,C;MACT,oBAAS,EAAT,I;MACA,IAAI,YAAS,OAAb,C;QACI,aAAa,cAAU,McxEc,iBdwEd,McxE8B,aAAhB,IdwExB,C;QACN,YAAP,MAAO,EAAU,MAAV,C;QACP,OAAO,M;OAGJ,sB;MkB7IX,cAAc,oBALkC,CAKlC,C;;QAEJ,OlB4IF,2BAAyB,kBAAzB,C;QACA,wBkB7IE,OlB6IF,SAA0B,OAA1B,U;QkB5IJ,qBAAO,OAAQ,Q;;QACjB,gC;UACE,OAAQ,U;UACR,MAAM,C;;UALV,O;;MlB4II,OAGE,+B;;MAEF,MAAO,iBAAQ,mCAAY,KAApB,C;;EAEf,C;EAEA,iC;IACI,kBAD4C,SAC5C,kB;MADsC,OACjB,mB;SACrB,kBAF4C,SAE5C,iB;MAAoB,QAAM,mB;MAAN,W;MAFkB,OL7G3B,kBAAK,CAAL,MAAJ,GAAY,CAAZ,GAAmB,C;;MK6GY,U;G;EAM1C,4C;IACI,eAAW,CAAX,C;IACA,uBAAmB,CAAnB,C;I+BgCA,WAAwB,mB/B9BxB,G+B8BwB,EAAiB,CAAjB,EAAoB,IAApB,C;;MAEpB,Y;QACS,WAAM,I;Q/BhCf,aAAa,Ic5F6B,Sd4F7B,Ic5FqC,cAAR,I;Qd6F1C,IAAI,0BAAe,IAAf,CAAJ,C;UACI,SAAO,C;;UAEP,uB;;QAEJ,mCAAgB,MAAhB,IAAyB,IclGiB,SdkGjB,IclGyB,cAAR,IdkG1C,M;cACA,SAAO,C;;Q+B0BH,OAAO,mB/BlCf,G+BkCe,EAAiB,CAAjB,EAAoB,IAApB,C;;;MAGX,iB/BrCJ,G+BqCI,EAAe,IAAf,C;;I/B1BJ,OAAO,c;EACX,C;EAEA,yE;IAMI,gBAAY,SAAZ,C;IACA,IAAI,WAAS,OAAb,C;MAAsB,OAAO,C;IAE7B,uBAAmB,CAAnB,C;I+B0BA,WAAW,mB/BxBX,W+BwBW,E/BxBgB,C+BwBhB,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,WAAM,I;QAAN,gB;Q/B5BX,aAAa,IcrH6B,SdqH7B,IcrHqC,cAAR,I;QdsH1C,SAAS,6BAAkB,OAAlB,WAAkC,IAAlC,C;QJ5Gb,IAAI,EI6GM,MAAM,CJ7GZ,CAAJ,C;UACI,cAdW,e;UAeX,MAAM,2BAAsB,OAAQ,WAA9B,C;SI4GN,oBAAS,EAAT,I;QACA,mCAAgB,MAAhB,IAAyB,IczHiB,SdyHjB,IczHyB,cAAR,IdyH1C,M;QAGI,uB;UAPJ,eAOwB,C;eACpB,WAAM,CAAN,C;UARJ,eAQe,C;;UARf,eASY,C;;Q+BmBR,mB;QACA,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,mB/B/Bf,W+B+Be,EAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,iB/BlCJ,W+BkCI,EAAe,IAAf,C;;I/BpBJ,kCAAgB,8BAAmB,WAAnB,CAAhB,I;IACA,OAAO,c;EACX,C;EYrNA,kF;EAAA,uE;EAAA,kD;IAOgB,sC;IAAS,gC;G;EAPzB,2CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;EoBcmC,8C;IA00B/B,qC;IAz0BA,oB;MAAA,OAAoB,mCAAY,M;IAChC,yB;MAAA,YAAuB,aAAL,IAAK,C;IACvB,oB;MAAA,OAA2C,mCAAY,K;IAAvD,gB;IAEA,uBAAoB,6BAAyB,IAAzB,EAA+B,SAA/B,C;IAkMpB,uCAAoC,K;G;;;SAnKhC,Y;MAAQ,OAAA,oBAAM,K;K;SACd,mB;MACI,4BAAa,O;MACb,kCAAmB,OAAQ,O;MAC3B,oCAAqB,OAAQ,a;MAC7B,wCAAyB,OAAQ,c;IACrC,C;;;;SAKA,Y;MAAc,gBAAN,mB;M1BgCN,S0BhCsB,2BAAkB,iBAAlB,C;MAAhB,O1BiCL,S;K;S0BhCH,mB;MAEI,sBAAQ,O;IACZ,C;;;;SAIA,Y;MAAQ,OAAA,oBAAM,W;K;SACd,iB;MACI,kCAAmB,K;IACvB,C;;;;SAIA,Y;MAAQ,OAAA,oBAAM,a;K;SACd,iB;MACI,oCAAqB,K;IACzB,C;;;;SAIA,Y;MAAQ,OAAA,oBAAM,iB;K;SACd,iB;MACI,wCAAyB,K;IAC7B,C;;;;8GAKA,Y;MAAe,+BAAmB,iBAAnB,I;K;SACf,wB;MAEI,iCAAoB,YAApB,C;IACJ,C;;EAK2B,gF;IAAA,mB;MAAE,iDAAuC,gBAAvC,W;IAAiD,C;G;;;SAF9E,Y;MAAQ,OAAA,oBAAM,c;K;SACd,oB;MpB7FJ,IAAI,EoB8FY,uBAAY,CpB9FxB,CAAJ,C;QACI,oCoB6F2B,8DpB7F3B,C;QAKA,CAAE,S;OoByFE,qCAAsB,Q;IAC1B,C;;;;SAOA,Y;MAAQ,yC;K;SACR,oB;MACI,IAAI,+CAAJ,C;QACI,MAAM,8BAAyB,+BAAzB,C;OAEd,C;;6CAEJ,e;IACI,IAAI,kBAAO,CAAX,C;MAAc,OAAO,I;IACrB,oBA3Be,wBAAmB,iBAAnB,I;IA4Bf,IAAI,iBAAiB,GAAjB,eAAwB,uCAAgB,4BAAhB,kBAAiC,GAAjC,MAA5B,C;MAAkE,OAAO,I;IAEzE,OAAO,0BAAW,GAAX,C;EACX,C;mDAEA,4D;IA0B0B,Q;IAzBtB,sBAAS,QAAM,MAAN,CAAT,C;IAEA,cAA2B,S;IAC3B,e;IACA,WAAW,M;IACX,oBAAoB,iB;IACF,QhBxHsC,oBgBwH3B,WhBxHW,KAAK,WAAW,CgBwH3B,UAAmB,iBAAnB,C;IAA7B,kBAAwB,GrCsIjB,iBAAK,CAAL,MAAJ,GqCtIqB,GrCsIrB,GAAmB,C;IqCpItB,OAAO,uBAAS,GAAT,SAAgB,uBAAS,WAAT,KAAvB,C;kBACoB,O;MAAhB,gBlB1DqC,sBAAgB,kBAAhB,I;MkB2DrC,IAAI,YAAY,IAAZ,WAAJ,C;QACe,QAAM,wCAAY,IAAZ,C;QAAN,UAAwB,qBAAc,MAAd,C;QAAnC,WrCiID,kBAAK,GAAL,MAAJ,GAAY,CAAZ,GAAmB,G;QqChId,OAAQ,OAAO,gBACX,WADW,EAEX,oBAAA,OAAQ,aAAR,MAAuB,IAAvB,CAFW,EAGX,IAHW,EAIX,aAJW,C;QAMf,S;QACA,oBAAU,IAAV,C;QACA,kCAAiB,IAAjB,C;;QAEA,yCAAQ,SAAR,E;;MAGc,OAAR,OAAQ,K;MAAR,iB;QAAgB,K;OAA1B,UAAU,I;;IAGd,OAAO,M;EACX,C;iDAEA,e;IAKI,WAAiB,SAAN,mBAAM,C;IACjB,gBAAgB,oBAvED,wBAAmB,iBAAnB,IAuEC,MAAgB,4BAAhB,C;;MAGZ,WAAW,W;MACX,IAAI,YAAJ,C;QACI,uCAAwB,I;QACxB,OAAO,K;OAGX,gBAAgB,IlB/FqB,iBkB+FrB,IlB/FqC,aAAhB,I;MkBgGrC,IAAI,SAAS,mCAAY,MAAzB,C;QACI,sBAAQ,I;QACR,OAAO,I;;QAEP,YAAY,I;QACZ,oFAAiB,SAAjB,E;;MAGJ,8CAAa,SAAb,E;;IACK,kCAAY,GAAZ,M;IAET,OAAO,I;EACX,C;;;SAKiC,Y;MAAQ,OAAc,oBAlGpC,wBAAmB,iBAAnB,IAkGoC,CAAd,KAAyB,4BAAzB,C;K;;oCAEzC,Y;IAGsC,6BAAgB,qBAAhB,IAAoC,yC;G;6CAE1E,a;IAG6C,2BA5G1B,wBAAmB,iBAAnB,IA4G0B,MAAgB,4BAAhB,gBAAiC,C;G;;;SAO1E,Y;MAAQ,sB;K;;;;SAKR,Y;MAAQ,2B;K;;;;SAKR,Y;MAAQ,QA7HO,wBAAmB,iBAAnB,IA6HP,MAAiB,CAAjB,IAAsB,wCAAtB,KAA8C,wCAAyB,+BAAvE,C;K;;oCAEZ,Y;IAMI,WAAW,S;IACX,YAAY,mCAAY,M;IAExB,IAAI,SAAS,KAAb,C;MACI,sBAAa,K;MACb,iC;MACK,WAAL,IAAK,EAAW,SAAX,C;KAEb,C;kCAEA,Y;IACI,c;IACA,IAAI,CAAC,oCAAL,C;MACI,uCAAwB,I;KAE5B,kB;EACJ,C;6CAEA,Y;IACI,WAAW,S;IACX,YAAY,mCAAY,M;IAExB,IAAI,SAAS,KAAb,C;MAAoB,OAAO,I;IAC3B,sBAAa,K;IACb,iC;IACA,OAAO,I;EACX,C;0CAEA,Y;IACI,WAAW,S;IACX,WAAW,IAAK,K;IAChB,YAAY,mCAAY,M;IACxB,IAAI,SAAS,KAAb,C;MAAoB,OAAO,I;IAE3B,IAAI,YAAJ,C;MACI,sBAAa,K;MACb,iC;;MAEA,sBAAa,I;MACb,+BAAA,IAAK,wBAAL,8BAAsB,IlB3Le,iBkB2Lf,IlB3L+B,aAAhB,IkB2LrC,E;;IAGJ,YAAY,I;IACZ,OAAO,I;EACX,C;2CAEA,iB;IACI,IAAI,UAAU,mCAAY,MAA1B,C;MAAiC,M;IAEjC,WAAiB,aAAN,KAAM,C;IACjB,IAAI,wBAAU,mCAAY,MAA1B,C;MACI,sBAAQ,K;MACR,+BAAgB,kCAzLL,wBAAmB,iBAAnB,IAyLK,E;;MAEV,SAAN,mBAAM,CAAN,QAAwB,K;MACxB,gEAAiB,IAAjB,C;;EAER,C;mDAEA,iB;IACI,WAAgB,SAAL,SAAK,C;IAChB,WAAW,KlBjN8B,iBkBiN9B,KlBjN8C,aAAhB,I;IkBmNrC,oBAAQ,C;IAAR,U;MAAa,QAAA,IlB9MyB,SkB8MzB,IlB9MiC,cAAR,IkB8MzB,IAAsB,I;KAAvC,S;MAA6C,OAAO,K;IAC/C,kBAAL,IAAK,EAAkB,KAAlB,EAAyB,IAAzB,C;IAEL,IAAI,cAAS,IAAb,C;MACI,wBAAmB,IAAK,c;;MAExB,oFAAiB,IAAjB,E;;IAGJ,OAAO,I;EACX,C;qCAEA,Y;IACI,YAAY,iB;IACZ,gBAAgB,QAAQ,CAAR,I;IAChB,IAAI,YAAY,qBAAhB,C;MAEI,oBAAe,S;MACf,OAAO,ehB1RJ,KAAK,SgB0RU,KhB1RV,C;KgB6RZ,OAAO,6B;EACX,C;mDAEA,Y;IAWe,Q;IAVX,YAAY,iB;IACZ,IAAI,QAAQ,qBAAZ,C;MACI,YAAY,ehBnST,KAAK,SgBmSe,KhBnSf,C;MgBoSR,oBAAe,K;MACf,WAAW,mB;MACX,IAAK,2BAAkB,KAAlB,C;MACL,wBAAW,IAAX,C;MACA,OAAO,K;KAGX,aAAW,iCAAY,CAAZ,oBAAkB,qBAAqB,CAArB,C;IAC7B,WAAW,MAAK,W;IAChB,yBAAiB,MAAjB,C;IACA,OAAO,I;EACX,C;sCAEA,Y;IACwC,wB;G;sCAExC,Y;IACwC,wB;G;uCAExC,Y;IAC0C,yB;G;oCAE1C,Y;IAEI,OAAO,e;EACX,C;qCAEA,Y;IAEI,OAAO,gB;EACX,C;8CAEA,+B;IAKI,SAAS,uBAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACT,IAAI,OAAM,MAAV,C;MACI,MAAM,iBAAa,gDAA6C,SAAS,EAAT,IAA7C,0BAAb,C;KAEd,C;EAOoB,iD;IAAA,mB;MAAE,6CAAmC,S;IAAG,C;G;4CAL5D,a;IpBhWA,IAAI,EoBqWQ,KAAK,CpBrWb,CAAJ,C;MACI,oCoBoWgB,+BpBpWhB,C;MAKA,CAAE,S;KoBgWF,OAAO,uCAAwB,CAAxB,EAA2B,CAA3B,C;EACX,C;iDAEA,a;IAII,IAAI,qBAAQ,CAAR,MAAc,CAAlB,C;MAAqB,MAAM,iBAAa,uBAAoB,CAApB,gCAAb,C;EAC/B,C;yIAEA,yB;ICtXJ,+E;IAAA,iF;IDsXI,wB;MChXa,Q;MAAb,aAAa,iCAL+B,CAK/B,oBAAkB,qBALa,CAKb,C;MAC/B,qBAAqB,MAAO,a;;QDkXX,KChXb,CAAM,MAAN,C;;QAEA,oBAAoB,MAAO,a;QAC3B,IAAI,gBAAgB,cAApB,C;UACI,MAAM,2BAAsB,yCAAtB,C;SAEV,IAAI,kBAAiB,MAAO,cAA5B,C;UACI,wBAAW,MAAX,C;;UAEA,oBAAe,a;;;IDwWvB,C;GAJA,C;yIAMA,yB;IC5XJ,+E;IAAA,iF;ID4XI,2B;MCtXa,Q;MAAb,aAAa,iCDyXJ,CCzXI,oBAAkB,qBDyXtB,CCzXsB,C;MAC/B,qBAAqB,MAAO,a;;QDwXhB,KCtXR,CAAM,MAAN,C;;QAEA,oBAAoB,MAAO,a;QAC3B,IAAI,gBAAgB,cAApB,C;UACI,MAAM,2BAAsB,yCAAtB,C;SAEV,IAAI,kBAAiB,MAAO,cAA5B,C;UACI,wBAAW,MAAX,C;;UAEA,oBAAe,a;;;ID8WvB,C;GAJA,C;oCAMA,Y;IAWW,gB;IAPP,WAAW,S;IACX,IAAI,CA5SW,wBAAmB,iBAAnB,IA4SX,IAAgB,CAApB,C;MACI,OAAO,IAAK,c;KAGhB,IAAI,4CAAuB,oCAA3B,C;MAAkD,OAAO,E;IAEzD,OAAO,iDAAgB,CAAhB,EAAmB,IAAnB,2DAA2C,E;EACtD,C;2CAEA,kB;IAGe,UAGV,M;IAHU,oCAAgB,CAAhB,C;IAAA,iB;MAAsB,OAAO,E;KAAxC,WAAW,I;IAEa,aAAP,MlBpUyB,SkBoUzB,MlBpUiC,cAAR,I;IkBoU/B,QAA6B,IlBzUC,iBkByUD,IlBzUiB,aAAhB,I;IkByUzC,WrCrJG,MAAO,aAAO,CAAP,C;IqCsJS,cAAlB,4DAAkB,EAAW,IAAX,EAAiB,IAAjB,C;IAEnB,OAAO,I;EACX,C;4CAEA,a;IACI,IAAI,gBAAK,CAAT,C;MAAY,S;IACZ,OAAO,uCAAwB,CAAxB,K;EACX,C;EAKc,+F;IAAA,8C;IACN,aAAkB,W;G;iFAElB,a;IACgB,Q;IAAZ,yBAAY,iBAAZ,EAAY,yBAAZ,UAAqB,C;IACrB,OAAO,I;EACX,C;iFAEA,e;IAK8B,UACN,M;IALpB,IAAI,uBAAJ,C;MACQ,iBAAJ,GAAI,EAAiB,wBAAjB,EAA8B,UAA9B,C;MACJ,0BAAO,GAAI,OAAX,I;WACG,IAAI,WAAJ,C;MACmB,OAAJ,GAAI,O;MAAtB,aAAU,CAAV,gB;QACI,yBAAY,mBAAZ,EAAY,2BAAZ,YAAqB,eAAI,CAAJ,C;;KAI7B,OAAO,I;EACX,C;iFAEA,2B;IACI,MAAM,sC;EACV,C;;;;;4DA1BR,iC;IACI,IAAI,eAAJ,C;MAAgB,OAAO,E;IAEvB,mF;IA0BA,OAAO,sBAAS,GAAT,EAAc,CAAd,EAAiB,GAAjB,C;EACX,C;6CAEA,yB;IAIqC,mB;MAAA,MAAW,C;IAAG,mB;MAAA,MAAW,U;IAC1D,IAAQ,oBAAJ,GAAI,CAAJ,iBAAgB,cAAhB,MAAJ,C;MACI,QAAQ,2BAAgC,cAAU,QAA1C,C;MACR,GAAI,gBAAO,CAAP,C;MACJ,OAAO,CAAE,O;KAEb,OAAO,yBAAU,GAAV,EAAe,GAAf,EAAoB,GAApB,C;EACX,C;kDAEA,gC;IAII,sBAAS,GAAT,EAAc,eAAd,EAA+B,eAA/B,C;EACJ,C;6CAEA,oB;IAGoB,mB;MAAA,MAAW,C;IAAG,mB;MAAA,MAAW,U;IACzC,IAAI,QAAO,CAAP,KAAa,QAAO,CAAP,IAAY,eAAzB,CAAJ,C;MAA0C,OAAO,E;IACjD,gBAAgB,c;IAChB,IAAI,uBAAY,CAAZ,IAAqB,oBAAJ,GAAI,CAAJ,iBAAgB,SAAhB,MAArB,C;MAAgD,OAAO,2BAAgC,SAAU,QAA1C,C;I/B5D5B,gBAAxB,qB+B8DsC,eAAlB,cAAJ,GAAI,EAAc,EAAd,CAAkB,EAAa,GAAb,C/B9DtC,C;I+B+DC,yB1B/YR,S0B+YQ,W;IADJ,O1B7YG,SL+U6C,W;E+BiEpD,C;kDAEA,2B;IAII,OAAO,sBAAS,eAAT,EAA0B,eAA1B,C;EACX,C;gDAEA,yB;IAEQ,YAAO,CAAP,IAAY,QAAO,CAAnB,C;MAAwB,OAAO,C;SAC/B,oB;MAAc,IAAI,QAAO,CAAX,C;QAAc,OAAO,C;;QAAO,2CAA4B,GAA5B,C;SAC1C,UAAM,GAAN,C;MAAa,+BAAgB,GAAhB,EAAqB,GAArB,C;IAGjB,iBAAa,CAAb,C;IACA,eAAW,KAAX,C;;MEpQU,gB;MADd,cAAc,I;MACA,kCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,aAAM,O;UAAN,gB;UFmQW,sB;;YlB5Ff,akB4FQ,MlB5FF,O;YAAN,YkB4FQ,MlB5FM,a;YAAd,mBkB4FQ,MlB5FoB,c;YqBnZjC,iBAAc,KAAd,UAA0B,YAA1B,U;cACI,gBAAgB,MnBkBb,KAAK,SmBlBe,KnBkBf,CmBlBQ,GAA0B,G;cACtC,0BAAc,GAAd,MAAsB,G;cAAtB,Y;gBAA+B,SAAmB,mBAAV,SAAU,E;gBAAnB,mB;gBH8e/B,IAAI,gBAAJ,C;kBAAA,kBAAmB,K;;kBAEX,mBAAO,aAAP,C;kBACJ,2B;kBAHJ,kBAII,I;;gBGlf0B,yB;eAAlC,W;gBH6eS,MG5eL,sBAAa,QAAQ,KAAR,IAAb,C;gBACA,qBAAO,K;gBAAP,uB;;YrB+YZ,SqB3YI,eAAe,KAAf,I;YHuea,MlB3FjB,sBAAa,EAAb,C;YqBzYA,qBAAO,I;;;UHoeC,6B;UAUI,S;YAVJ,eAUU,I;iBACN,qB;YAXJ,eAWqB,K;;YAEb,SAAO,I;YAbf,eAcQ,K;;UEjRR,IAAI,aAAJ,C;;WAGA,UAAU,K;UACC,mCAAoB,OAApB,C;UAAA,mB;;WAAX,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,yBAAiB,OAAjB,C;;;;IF4QJ,IAAI,MAAJ,C;MACI,OAAO,WAAS,wBAAS,GAAT,EAAc,MAAM,QAAN,IAAd,EAA4B,MAAM,QAAN,IAA5B,CAAT,I;KAEX,IAAI,WAAS,GAAb,C;MAAkB,yCAA0B,GAA1B,EAA+B,QAA/B,C;IAClB,OAAO,Q;EACX,C;kEAEA,e;IACI,MAAM,iBAAa,cAAW,GAAX,gDAAb,C;G;sDAEV,oB;IACI,MAAM,8BAAyB,kDAA+C,GAA/C,gBAA2D,GAApF,C;G;gEAEV,uB;IAAwE,MAAM,gCAC1E,gDAA6C,GAA7C,4BAAqE,MADK,C;G;+CAI9E,yB;IACI,iBAAa,CAAb,C;;ME9QU,gB;MADd,cAAc,I;MACA,kCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;cFuQG,qB;;gBGpa1B,oBAAgB,CAAhB,C;gBACA,gBAAY,CAAZ,C;gBACA,wBAAoB,CAApB,C;gBrB8RS,akBoIU,MlBpIJ,O;gBAAN,YkBoIU,MlBpII,a;gBAAd,mBkBoIU,MlBpIkB,c;gBqB3RjC,iBAAc,KAAd,UAA0B,YAA1B,U;kBACI,QAAQ,MnBtGL,KAAK,SmBsGO,KnBtGP,CmBsGA,GAA0B,G;kBAE9B,SAAM,GAAN,MAAc,CAAd,C;oBACI,IAAI,gBAAa,CAAjB,C;sBAAoB,mBAAmB,WAAnB,C;oBACf,SAAW,mBAAF,CAAE,E;oBAAX,mB;oBH2ZT,IAAI,gBAAJ,C;sBAAA,kBAAmB,K;;sBAEX,mBAAO,aAAP,C;sBACJ,2B;sBAHJ,kBAII,I;;oBG/ZA,IAAI,gBAAJ,C;sBH0ZG,MGzZC,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,E;sBAAP,sB;4BAGR,oBAAa,CAAb,C;oBAGI,WAAW,G;oBACX,UAAQ,C;oBAER,aAAU,CAAV,OAAa,CAAb,M;sBACI,IAAI,WAAU,IAAV,MAAkB,CAAtB,C;wBACI,UAAQ,UAAe,CAAL,I;wBAClB,OAAO,QAAS,C;wBAChB,iC;;wBAEA,K;;;oBAIR,kBAAgB,W;oBAChB,iC;oBAEA,IAAI,mBAAgB,eAAe,KAAf,IAAhB,CAAJ,C;sBHkYG,MGjYC,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,e;sBAAP,sB;;oBAKJ,UAAS,WAAU,CAAX,GAAkB,IAAM,G;oBAChC,iC;oBAEA,IAAI,gBAAa,CAAjB,C;sBACI,IAAI,eAAe,OAAf,CAAJ,C;wBACS,WAAe,mBAAN,OAAM,E;wBAAf,qB;wBHuXjB,IAAI,gBAAJ,C;0BAAA,oBAAmB,K;;0BAEX,mBAAO,eAAP,C;0BACJ,2B;0BAHJ,oBAII,I;;wBG3XQ,IAAI,kBAAJ,C;0BHsXL,MGrXS,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;gCAED,IAAI,CAAC,iBAAiB,OAAjB,CAAL,C;wBACH,mBAAmB,OAAnB,C;;wBAEK,WAA8B,mBAArB,cAAc,OAAd,CAAqB,E;wBAA9B,qB;wBHgXjB,IAAI,gBAAJ,C;0BAAA,oBAAmB,K;;0BAEX,mBAAO,eAAP,C;0BACJ,2B;0BAHJ,oBAII,I;;wBGpXY,+B;wBAAA,Y;0BACC,WAA6B,mBAApB,aAAa,OAAb,CAAoB,E;0BAA7B,qB;0BH+WjB,IAAI,gBAAJ,C;4BAAA,oBAAmB,K;;4BAEX,mBAAO,eAAP,C;4BACJ,2B;4BAHJ,oBAII,I;;0BGnXY,2B;yBADJ,W;0BH+WL,MG5WS,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;;sBAIR,UAAQ,C;;;gBrBmO5B,SqB7NI,eAAe,KAAf,I;gBHiWe,MlBnInB,sBAAa,EAAb,C;gBqB3NA,oBAAO,C;;;cH8VC,8B;cAUI,eAAQ,CAAR,C;gBAVJ,eAUiB,C;qBACb,aAAO,CAAP,C;gBAXJ,eAWgB,M;;gBAXhB,eAYY,C;;cEnRJ,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,mCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,yBAAiB,OAAjB,C;cACA,oCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;;WAIA,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,yBAAiB,OAAjB,C;;;;IF2PJ,IAAI,WAAS,GAAb,C;MAAkB,yCAA0B,GAA1B,EAA+B,QAA/B,C;IAElB,OAAO,Q;EACX,C;8DAEA,sB;IAEkB,Q;IADd,IAAI,aAAJ,C;MAAa,OAAO,O;IACN,gCAAY,CAAZ,C;IAAA,iB;MAAkB,OAAO,O;KAAvC,cAAc,I;IACH,QAA4B,oBAAtB,OlBvewB,iBkBuexB,OlBvewC,aAAhB,IkBueF,C;IAAvC,WAAoD,CrC1S7C,kBqC0S0C,CrC1S1C,MAAJ,GAAY,CAAZ,GqC0S8C,CAAG,S;IACpD,OAAQ,sBAAa,IAAb,C;IACR,wCAAgB,IAAhB,I;IACA,yBAAU,OAAV,C;IAEA,OAAO,uCAAwB,+BAAI,IAAJ,EAAxB,EAAkC,gCAAU,IAAV,EAAlC,C;EACX,C;8DAEA,sB;IASsB,Q;IARlB,mBAAmB,C;IACnB,qBAAqB,O;IAErB,OAAO,IAAP,C;MACI,IAAI,iBAAgB,CAApB,C;QACI,OAAO,c;OAGG,gCAAY,CAAZ,C;MAAA,iB;QAAkB,OAAO,c;OAAvC,cAAc,I;MAEH,QAAM,OlB1foB,iBkB0fpB,OlB1foC,aAAhB,I;MkB0f1B,QAA6B,Y;MAAxC,WrCtUD,MAAO,KAAI,CAAJ,EAAO,CAAP,C;MqCuUN,OAAQ,sBAAa,IAAb,C;MACR,wCAAgB,IAAhB,I;MACA,yBAAU,OAAV,C;MAEA,8BAAgB,IAAhB,I;MACA,kCAAkB,IAAlB,I;;EAER,C;2DAEA,yC;IAEkB,UAMP,M;IAPP,IAAI,WAAU,CAAd,C;MAAiB,OAAO,M;IACV,gCAAY,CAAZ,C;IAAA,iB;MAAkB,OAAO,M;KAAvC,cAAc,I;IACH,QAAc,OlBvgBgB,iBkBugBhB,OlBvgBgC,aAAhB,I;IkBugBzC,WrCnVG,MAAO,KqCmVO,MrCnVP,EAAO,CAAP,C;IqCqVF,YAAR,OAAQ,EAAU,KAAV,EAAiB,MAAjB,EAAyB,IAAzB,C;IACR,oBAAe,OAAQ,a;IAEZ,sBAAQ,M;IAAR,Y;MAAkB,UAAA,OlB5gBY,iBkB4gBZ,OlB5gB4B,aAAhB,IkB4gBZ,MAAyB,C;KAA/C,W;MACH,yBAAU,OAAV,C;MACA,6CAAqB,KAArB,EAA4B,SAAS,IAAT,IAA5B,EAA2C,SAAS,IAAT,IAA3C,EAA0D,SAAS,IAAT,IAA1D,C;;MAEA,kBAAS,IAAT,I;;IAJJ,a;EAMJ,C;8DAEA,a;IACI,MAAM,iBAAa,gCAA6B,cAA7B,6BAAiD,CAAjD,aAAb,C;EACV,C;wDAEA,qB;IAII,kBAAkB,wBAAmB,SAAnB,I;IAElB,IAAI,cAAc,CAAlB,C;MACI,MAAM,8BAAyB,iEAAzB,C;KAGV,oBAAe,W;EACnB,C;oDAEA,mB;IACyD,sCAAgB,OAAhB,EAAyB,SAAzB,C;G;mDAEzD,mB;IACgE,+BAAW,OAAX,C;G;+CAEhE,mB;IAC8D,iCAC1D,OAD0D,EAE1D,mCAAY,MAF8C,C;G;oDAK9D,mB;IAEuB,Q;IAAA,OAAR,OAAQ,K;IAAR,iB;MAAgB,OAAO,uCAAwB,OAAxB,C;KAAlC,WAAW,I;IAEX,gBAAgB,OlBrjByB,iBkBqjBzB,OlBrjByC,aAAhB,I;IkBsjBvB,QAAiB,KAAsB,OlBhkBvB,YkBgkBuB,OlBhkBZ,MAAX,IkBgkBC,K;IAAnC,kBrClYG,MAAO,KqCkYc,SrClYd,EAAO,CAAP,C;IqCmYV,IAAI,IAAK,SAAL,GAAgB,WAApB,C;MACI,OAAO,uCAAwB,OAAxB,C;KAGN,gBAAL,IAAK,EAAgB,WAAhB,C;IAEL,IAAI,YAAY,WAAhB,C;MACI,OAAQ,wB;MAER,wBAAwB,OAAQ,c;MAChC,+BAAA,IAAK,wBAAL,yBAAsB,WAAtB,E;;MAEA,sBAAa,I;MACb,+BAAA,IAAK,wBAAL,8BAAsB,CAAA,IlBpkBe,iBkBokBf,IlBpkB+B,aAAhB,IkBokBf,IAAqB,WAArB,IAAtB,E;MACA,OAAQ,Y;MACR,OAAQ,iBAAQ,SAAR,C;;EAEhB,C;8DAEA,mB;IACI,IAAI,wCAAyB,OAAQ,KAAR,QAA7B,C;MACI,oBAAoB,OAAQ,a;MAC5B,wBAAwB,OAAQ,c;MAChC,iC;MACA,M;KAGJ,WAAW,OlBllB8B,iBkBklB9B,OlBllB8C,aAAhB,I;IkBmlB3B,QAAY,KAAsB,OlB7lBd,YkB6lBc,OlB7lBH,MAAX,IkB6lBR,K;IAA1B,crC/ZG,MAAO,KqC+ZU,IrC/ZV,EAAO,CAAP,C;IqCiaV,IAAI,OAAO,OAAX,C;MACI,gDAAkC,OAAlC,EAA2C,IAA3C,EAAiD,OAAjD,C;;MAEA,YAAU,SAAK,S;MACf,KAAI,uBAAc,CAAd,C;MACJ,aAAW,OAAQ,Y;MAEf,kBAAJ,KAAI,EAAkB,OAAlB,EAA2B,IAA3B,C;MACJ,sBAAa,K;;IAGjB,OAAQ,iBAAQ,SAAR,C;EACZ,C;uEAEA,kC;IAII,aAAa,SAAK,S;IAClB,aAAa,SAAK,S;IAElB,MAAO,uBAAc,CAAd,C;IACP,MAAO,uBAAc,CAAd,C;IACP,cAAc,M;IACd,cAAc,OAAQ,Y;IAEf,kBAAP,MAAO,EAAkB,OAAlB,EAA2B,OAAO,OAAP,IAA3B,C;IACA,kBAAP,MAAO,EAAkB,OAAlB,EAA2B,OAA3B,C;IAEP,sBAAa,M;IACb,+BAA4B,aAAP,MAAO,C;EAChC,C;iDAEA,0B;IAQW,Q;IAPP,IAAI,YAAY,KAAhB,C;MACI,OAAO,uB;KAGX,WAAW,OAAQ,Y;IACnB,OAAQ,iBAAQ,SAAR,C;IAGJ,iB;MACI,sBAAa,K;MACb,iC;MACA,iCAAW,KAAX,EAAkB,KAAlB,C;;MAEJ,IAAA,IlB5UkC,iBkB4UlC,IlB5UkD,akB4UlD,C;QACI,sBAAQ,I;QACR,yFAAiB,IlBtoBgB,iBkBsoBhB,IlBtoBgC,aAAhB,IkBsoBjC,E;QACA,W;;QAEI,iCAAW,IAAX,EAAiB,KAAjB,C;;IAXZ,W;EAaJ,C;iCAEA,Y;IAMI,aAAa,SAAK,S;;MAEd,MAAO,uBAAc,CAAd,C;MACP,aAAa,kBAAK,MAAO,OAAZ,EAAoB,MAAO,cAA3B,EAA0C,MlBjpBjB,SkBipBiB,MlBjpBT,cAAR,IkBipBzB,C;MAEb,IAAI,WAAU,CAAd,C;QACI,uCAAwB,I;QAExB,IAAI,EAAC,MlBnWyB,iBkBmWzB,MlBnWyC,akBmW1C,CAAJ,C;UACI,MAAO,iBAAQ,SAAR,C;UACP,OAAO,I;UAIf,MAAO,uBAAc,MAAd,C;MAEP,OAAO,M;;MACT,gC;QACE,MAAO,iBAAQ,SAAR,C;QACP,MAAM,C;;QAlBV,O;;EAoBJ,C;sDAEA,Y;IACI,IAAI,CAAC,oCAAL,C;MACI,uCAAwB,I;KAEhC,C;6CAEA,Y;IAII,IAAI,oCAAJ,C;MAA2B,OAAO,I;IAClC,YAAY,W;IACZ,IAAI,aAAJ,C;MACI,uCAAwB,I;MACxB,OAAO,I;KAEX,0BAAW,KAAX,C;IACA,OAAO,K;EACX,C;EAMqC,2C;IACzB,MAAM,2BAAsB,qEAAtB,C;EACV,C;iDANR,iB;IAO8B,UAAN,M;IANpB,WAAiB,SAAN,mBAAM,C;IACjB,IAAI,SAAS,mCAAY,MAAzB,C;MACI,sBAAQ,K;MpBvwBhB,IAAI,CoBwwBY,wCpBxwBhB,C;QACI,oCoBuwBiC,+BpBvwBjC,C;QAKA,CAAE,S;OoBqwBE,+BAAgB,WAAM,OAAN,KAAM,KAAN,4D;;MAEhB,YAAY,K;MACZ,gEAAuB,aAAN,KAAM,CAAvB,C;;EAER,C;gDAEA,mB;IAEI,WAAW,S;IACX,IAAI,yBAAmB,iBAAnB,SAAmC,OAAvC,C;MAAgD,OAAO,I;IACvD,OAAO,+BAAgB,OAAhB,EAAyB,IAAzB,C;EACX,C;+CAEA,yB;IAEI,IAAI,yBAAmB,iBAAnB,SAAmC,OAAvC,C;MAAgD,OAAO,I;IACvD,OAAO,+BAAgB,OAAhB,EAAyB,IAAzB,C;EACX,C;sDAEA,yB;IAIoB,UAAL,M;IAHX,eA3sBe,wBAAmB,iBAAnB,I;IA4sBf,IAAI,YAAY,OAAhB,C;MAAyB,OAAO,I;IAErB,UAAK,OAAL,IAAK,KAAL,mBAAa,uB;IAAb,mB;MAAyB,OAAO,I;KAA3C,WAAW,M;IAEX,IAAI,aAAY,CAAhB,C;MACI,IAAI,SAAS,mCAAY,MAAzB,C;QACI,yBAAY,IAAZ,C;OAGJ,OAAO,+BAAgB,OAAhB,EAAyB,IAAzB,C;;MAEP,wBAAwB,UAAU,QAAV,I;MACxB,aAAkB,kBAAL,IAAK,EAAkB,IAAlB,EAAwB,iBAAxB,C;MAClB,wBAAmB,IAAK,c;MACxB,yFAAiB,MAAjB,E;MACA,IAAI,EAAC,IlBlb6B,iBkBkb7B,IlBlb6C,akBkb9C,CAAJ,C;QACI,YAAY,I;QACZ,YAAY,IAAK,Y;QACjB,IAAK,iBAAQ,SAAR,C;;QAEL,IAAK,yBAAgB,MAAhB,C;;;IAIb,IAAI,CAAA,IlBnvBqC,iBkBmvBrC,IlBnvBqD,aAAhB,IkBmvBrC,KAAsB,OAA1B,C;MAAmC,OAAO,I;IAC1C,IAAI,UAAU,CAAd,C;MAAmC,+BAAgB,OAAhB,C;IAEnC,OAAO,+BAAgB,OAAhB,EAAyB,IAAzB,C;EACX,C;sDAEA,mB;IACI,MAAM,2BAAsB,gBAAa,OAAb,kDAAtB,C;EACV,C;gDAEA,gB;IACI,IAAI,CAAA,IlB9vBqC,iBkB8vBrC,IlB9vBqD,aAAhB,IkB8vBrC,MAAsB,CAA1B,C;MACI,yBAAY,IAAZ,C;KAER,C;gDAEA,gB;IACoB,Q;IAAhB,WAAW,CAAK,OAAL,IAAK,YAAL,mBAAoB,mCAAY,M;IAC3C,sBAAa,I;IACb,+BAAA,IAAK,wBAAL,8BAAsB,IlBtwBmB,iBkBswBnB,IlBtwBmC,aAAhB,IkBswBzC,E;IACA,IAAK,iBAAQ,SAAR,C;IAEL,OAAO,I;EACX,C;EAEA,mC;IAAA,uC;G;;;;;;;EAAA,+C;IAAA,8C;MAAA,6B;KAAA,uC;G;;;;;;EAn0BA,0D;IAGI,oB;MAAA,OAAiB,gCAAS,M;IAC1B,yB;MAAA,YAAuB,aAAL,IAAK,C;IACvB,oB;MAAA,OAAgC,mCAAY,K;IALhD,uD;IAMS,Q;IAAL,0BAAK,2DAAL,EAA0B,SAA1B,EAAqC,IAArC,C;IANJ,Y;G;EIJJ,8C;IACI,8C;IACA,gB;IAkBA,uBAAoB,+B;IA2EpB,6D;G;;;SAxEI,Y;MAAQ,OAAA,oBAAM,K;K;SACd,iB;MACI,4BAAa,K;IACjB,C;;;;SAGA,Y;MAAQ,OAAA,oBAAM,K;K;SACd,iB;MACI,4BAAa,K;IACjB,C;;;;SAGA,Y;MAAQ,Q;MAAA,sDAAS,mCAAY,M;K;;;;SAK7B,Y;MACI,OAAO,8BAAiB,CAAjB,C;IACX,C;;;;SAIA,Y;MAAQ,qCAAiB,CAAjB,C;K;SACR,oB;MACI,yBAAY,QAAZ,C;IACJ,C;;;;SAGA,Y;MAAQ,OAAA,oBAAM,W;K;SACd,iB;MACI,kCAAmB,K;IACvB,C;;;;SAGA,Y;MAAQ,OAAA,oBAAM,a;K;SACd,iB;MACI,oCAAqB,K;IACzB,C;;;;SAGA,Y;MAAQ,OAAA,oBAAM,iB;K;SACd,iB;MACI,wCAAyB,K;IAC7B,C;;;;SAGA,Y;MAAQ,OAAA,oBAAM,oB;K;SACd,iB;MACI,2CAA4B,K;IAChC,C;;;;SAMA,Y;MAAQ,OAAA,oBAAM,Y;K;SACd,iB;MACI,mCAAoB,K;IACxB,C;;;;uHAEmC,Y;MAAQ,uCAAmB,yBAAnB,I;K;;;;SAM3C,Y;MAAQ,qCAAe,yBAAf,GAA8B,kCAA9B,K;K;SACR,a;IAEA,C;;;;SAEJ,Y;MAAA,+B;K;SAWI,iB;MACI,2BAAQ,K;MACR,IAAI,4CAAJ,C;QACI,MAAM,8BACF,4EACI,sBAFF,C;OAKd,C;;mCAEJ,Y;IACI,2B;EACJ,C;kDAEA,Y;IACkB,Q;IAAA,8B;IAAA,iB;MAAc,M;KAA5B,cAAc,I;;M/BbI,U;MAHtB,c+BmBQ,O;;Q/BjBJ,YAAM,O;Q+BkBE,mBAAM,KAAM,OAAZ,EAAoB,KAAM,aAA1B,EAAwC,KtBlEP,iBsBkEO,KtBlES,aAAhB,IsBkEjC,C;Q/BjBU,SAAR,OAAQ,K;QAAR,mB;UAAgB,K;SAA1B,UAAU,M;;MACL,a;;M+BmBO,WAAR,OAAQ,EAAW,SAAX,C;;EAEhB,C;8CAEA,Y;IAKoB,UAEhB,M;IAFgB,OAAL,IAAK,gB;IAAL,iB;MAAc,OAAO,I;KAAhC,WAAW,I;IAEX,iFAA+B,yBAA/B,Q;IAEA,uBAAa,I;IACb,uBAAa,I;IACb,4BAAe,C;IACf,gCAAmB,C;IACnB,qCAAsB,C;IACtB,6BAAc,C;IACd,0BAAa,8BAAO,M;IAEpB,OAAO,I;EACX,C;sDAEA,Y;IACI,WAAW,iB;IACX,IAAI,SAAS,mCAAY,MAAzB,C;MxChFJ,IAAI,EwCiFU,IAAK,KAAL,QxCjFV,CAAJ,C;QACI,cAdW,e;QAeX,MAAM,2BAAsB,OAAQ,WAA9B,C;OwCgFF,IAAK,gB;MACL,IAAK,yBAAgB,6BAAhB,C;MACL,IAAK,uBAAc,CAAd,C;MACL,4BAAe,IAAK,c;MACpB,qCAAsB,yB;MACtB,gCAAmB,IAAK,M;KAEhC,C;uDAEA,kB;IxC3FA,IAAI,EwC4FM,MAAO,KAAP,QxC5FN,CAAJ,C;MACI,cwC2F6B,qC;MxC1F7B,MAAM,2BAAsB,OAAQ,WAA9B,C;KwC2FN,+BAAgB,MAAhB,EAAwB,MAAxB,EAAgC,CAAhC,C;EACJ,C;iDAEA,gB;IACI,WAAgB,SAAL,IAAK,C;IACkD,gBAArC,aAAL,IAAK,CAAL,8BAAsB,ItBjHL,iBsBiHK,ItBjHW,aAAhB,IsBiHjB,E;IAA0C,WAAY,qB;IX5LlF,IAAI,wBAAQ,UAAZ,C;MAA2B,wBAAwB,SAAxB,EAA8B,IAA9B,C;IW4LvB,uBX3LG,iB;IW4LH,+BAAgB,IAAhB,EAAsB,IAAtB,EAA4B,gBAA5B,C;EACJ,C;sDAEA,Y;IACI,YAAU,SAAK,S;IACf,KAAI,uBAAc,CAAd,C;IAEJ,+BAAkB,KAAlB,C;IAEA,OAAO,K;EACX,C;uDAEA,2C;IACI,YAAY,oB;IACZ,IAAI,aAAJ,C;MACI,uBAAQ,I;MACR,6BAAc,C;;MAEd,aAAa,I;MACb,mBAAmB,yB;MACnB,KAAM,iCAAwB,YAAxB,C;MACN,2DAAe,YAAf,GAA8B,kCAA9B,K;;IAGJ,uBAAa,O;IACb,0DAAe,gBAAf,I;IACA,0BAAa,OAAQ,O;IACrB,4BAAe,OAAQ,c;IACvB,qCAAsB,OAAQ,a;IAC9B,gCAAmB,OAAQ,M;EAC/B,C;+CAEA,a;IACI,YAAY,yB;IACZ,IAAI,QAAQ,6BAAZ,C;MACI,4BAAe,QAAQ,CAAR,I;MACf,uBpB7LJ,KAAK,SoB6LU,KpB7LV,EoB6LmB,CpB7LnB,C;MoB8LD,M;KAGJ,OAAO,iCAAkB,CAAlB,C;EACX,C;yDAEA,a;IACI,+BAAiB,mBAAU,CAAV,C;IACjB,6D;EACJ,C;mCAEA,Y;;MAKQ,Y;;MAEA,uB;;EAER,C;4CAEA,a;IAII,mBAAmB,yB;IACnB,IAAI,iCAAmB,YAAnB,SAAmC,CAAvC,C;MAC0B,gBAAX,uB;MAAW,QAA0B,CAAE,I;MAA5B,sB;MDgG9B,IAAK,CAAL,cAAQ,GAAR,C;QnB1TI,cAAK,SoB0NiC,YpB1NjC,EmB2Ta,OAAF,CAAE,CnB3Tb,C;QmByTsD,qBAG3D,C;aAEJ,IAAK,GAAL,cAAW,IAAX,C;QACI,SnB/TA,KAAK,SoB0NiC,YpB1NjC,EmB+TyC,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CnB/TzC,C;QmBgUL,SnBhUA,KAAK,SoB0NiC,YDsGjC,GAAS,CAAT,InBhUA,EmBgUqC,OAAtB,MAAS,IAAM,EAAO,CnBhUrC,C;QmByTsD,qBAQ3D,C;aAEJ,IAAK,IAAL,cAAY,KAAZ,C;QACI,SnBpUA,KAAK,SoB0NiC,YpB1NjC,EmBoU0C,OAA/B,MAAU,KAAM,EAAP,GAAe,EAAO,CnBpU1C,C;QmBqUL,SnBrUA,KAAK,SoB0NiC,YD2GjC,GAAS,CAAT,InBrUA,EmBqU6C,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CnBrU7C,C;QmBsUL,SnBtUA,KAAK,SoB0NiC,YD4GjC,GAAS,CAAT,InBtUA,EmBsUqC,OAAtB,MAAS,IAAM,EAAO,CnBtUrC,C;QmByTsD,qBAc3D,C;aAEJ,IAAK,KAAL,cAAc,OAAd,C;QACI,SnB1UA,KAAK,SoB0NiC,YpB1NjC,EmB0U0C,OAA/B,MAAU,KAAM,EAAP,GAAe,CAAO,CnB1U1C,C;QmB2UL,SnB3UA,KAAK,SoB0NiC,YDiHjC,GAAS,CAAT,InB3UA,EmB2U8C,OAA/B,MAAU,KAAM,EAAP,GAAe,EAAO,CnB3U9C,C;QmB4UL,SnB5UA,KAAK,SoB0NiC,YDkHjC,GAAS,CAAT,InB5UA,EmB4U6C,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CnB5U7C,C;QmB6UL,SnB7UA,KAAK,SoB0NiC,YDmHjC,GAAS,CAAT,InB7UA,EmB6UqC,OAAtB,MAAS,IAAM,EAAO,CnB7UrC,C;QmByTsD,qBAqB3D,C;;QArB2D,qBAuBvD,mBAAmB,CAAnB,C;;MCtHA,6B;MACA,4BAAoB,eAAe,IAAf,I;MACpB,OAAO,I;KAGX,kCAAmB,CAAnB,C;IACA,OAAO,I;EACX,C;0DAEA,a;IAmPI,aAAa,8BAlPP,CAkPO,C;;MAjPgB,gBAmPN,MAnPD,O;MAAO,aAmPN,MAnPyB,c;MAAnB,QAAoC,K;MAApC,sB;MDqFjC,IAAK,CAAL,cAAQ,GAAR,C;QnB1TI,cAAK,SmB2TG,MnB3TH,EmB2Ta,OAAF,CAAE,CnB3Tb,C;QmByTsD,qBAG3D,C;aAEJ,IAAK,GAAL,cAAW,IAAX,C;QACI,SnB/TA,KAAK,SmB+TA,MnB/TA,EmB+TyC,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CnB/TzC,C;QmBgUL,SnBhUA,KAAK,SmBgUA,SAAS,CAAT,InBhUA,EmBgUqC,OAAtB,MAAS,IAAM,EAAO,CnBhUrC,C;QmByTsD,qBAQ3D,C;aAEJ,IAAK,IAAL,cAAY,KAAZ,C;QACI,SnBpUA,KAAK,SmBoUA,MnBpUA,EmBoU0C,OAA/B,MAAU,KAAM,EAAP,GAAe,EAAO,CnBpU1C,C;QmBqUL,SnBrUA,KAAK,SmBqUA,SAAS,CAAT,InBrUA,EmBqU6C,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CnBrU7C,C;QmBsUL,SnBtUA,KAAK,SmBsUA,SAAS,CAAT,InBtUA,EmBsUqC,OAAtB,MAAS,IAAM,EAAO,CnBtUrC,C;QmByTsD,qBAc3D,C;aAEJ,IAAK,KAAL,cAAc,OAAd,C;QACI,SnB1UA,KAAK,SmB0UA,MnB1UA,EmB0U0C,OAA/B,MAAU,KAAM,EAAP,GAAe,CAAO,CnB1U1C,C;QmB2UL,SnB3UA,KAAK,SmB2UA,SAAS,CAAT,InB3UA,EmB2U8C,OAA/B,MAAU,KAAM,EAAP,GAAe,EAAO,CnB3U9C,C;QmB4UL,SnB5UA,KAAK,SmB4UA,SAAS,CAAT,InB5UA,EmB4U6C,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CnB5U7C,C;QmB6UL,SnB7UA,KAAK,SmB6UA,SAAS,CAAT,InB7UA,EmB6UqC,OAAtB,MAAS,IAAM,EAAO,CnB7UrC,C;QmByTsD,qBAqB3D,C;;QArB2D,qBAuBvD,mBAAmB,CAAnB,C;;MC3GA,6B;MAmPmB,MAlPZ,uBAAc,IAAd,C;MAkPP,aAjPA,I;MxCjLR,IAAI,EwCmaU,UAAU,CxCnapB,CAAJ,C;QACI,cwCkayB,0C;QxCjazB,MAAM,2BAAsB,OAAQ,WAA9B,C;;MwCqaF,qB;;EApPR,C;4CAEA,e;IACI,IAAI,WAAJ,C;MACI,oBAAO,MAAP,EAAe,CAAf,EAAkB,CAAlB,C;;MAEA,oBAAO,GAAP,EAAY,CAAZ,EAAe,GAAI,OAAnB,C;;IAEJ,OAAO,I;EACX,C;4CAEA,2B;IACI,IAAI,WAAJ,C;MACI,OAAO,oBAAO,MAAP,EAAe,KAAf,EAAsB,GAAtB,C;KAGX,kBAAU,GAAV,EAAe,KAAf,EAAsB,GAAtB,EAA2B,sBAAS,MAApC,C;IAEA,OAAO,I;EACX,C;iDAEA,a;IAII,oBAAoB,CAAE,mB;IACtB,IAAI,qBAAJ,C;MACI,CAAE,U;MACF,M;KAGJ,YAAY,oB;IACZ,IAAI,aAAJ,C;MACI,yBAAY,aAAZ,C;MACA,M;KAGJ,kCAAmB,KAAnB,EAA0B,aAA1B,EAAyC,CAAE,KAA3C,C;EACJ,C;sDAEA,uB;IAII,YAAY,oB;IACZ,IAAI,aAAJ,C;MACI,yBAAY,WAAZ,C;MACA,M;KAGJ,kCAAmB,KAAnB,EAA0B,WAA1B,EAAuC,SAAvC,C;EACJ,C;0DAEA,qC;IAQqB,UAKb,MALa,EAgBC,M;IAvBlB,IAAK,iCAAwB,yBAAxB,C;IAEL,eAAe,ItB1P0B,iBsB0P1B,ItB1P0C,aAAhB,I;IsB2PzC,eAAe,atB3P0B,iBsB2P1B,atB3P0C,aAAhB,I;IsB8PzC,kBAAkB,oB;IACG,wBAAW,W;IAAX,W;MAA0B,sBAAa,CAAA,ItBzQ1B,YsByQ0B,ItBzQf,MAAX,IsByQ0B,KAAc,ItB1PhC,SsB0PgC,ItB1PxB,cAAR,IsB0PkB,KAAb,C;KAA9B,W;MACb,e;;MACG,S;IAFP,qB;IAKI,IAAI,WAAW,WAAX,IAA0B,YAAY,aAAc,SAApD,IAA8E,mBAAd,aAAc,CAAlF,C;MACI,iB;;MACG,W;IAHX,wB;IAKA,IAAI,eAAc,EAAd,IAAoB,gBAAe,EAAvC,C;MAEI,yBAAY,aAAZ,C;WACG,IAAI,gBAAe,EAAf,IAAqB,cAAc,WAAvC,C;MAEE,kBAAL,IAAK,EAAkB,aAAlB,EAAiC,CAAA,ItBxQA,SsBwQA,ItBxQQ,cAAR,IsBwQA,KAAsB,ItBvR9B,YsBuR8B,ItBvRnB,MAAX,IsBuRQ,KAAjC,C;MACL,qB;MACA,KAAc,SAAd,aAAc,YAAd,U;QACI,gC;OAGJ,aAAc,iBAAQ,IAAR,C;WACX,IAAI,eAAc,EAAd,IAAoB,cAAc,UAAtC,C;MACH,sCAAuB,aAAvB,EAAsC,IAAtC,C;;MAEA,MAAM,2BAAsB,YAAS,WAAT,gBAA6B,UAAnD,C;;EAEd,C;8DAEA,+B;IAMgB,Q;IAFE,mBAAd,aAAc,EAAmB,IAAnB,C;IAEF,U;IAAA,0C;MAAA,a;;MxCnO6B,MAAM,2BwCmOpB,oExCnOkD,WAA9B,C;;IwCmO/C,kB;IACA,IAAI,UAAU,IAAd,C;MACI,uBAAa,a;;MAIb,UAAU,K;MACV,OAAO,IAAP,C;QACI,WAAW,cAAA,GAAI,KAAJ,C;QACX,IAAI,SAAS,IAAb,C;UAAmB,K;QACnB,MAAM,I;;MAGV,WAAW,a;;IAGf,IAAK,iBAAQ,SAAR,C;IAEL,uBAA2B,SAAd,aAAc,C;EAC/B,C;iDAEA,gB;IAUgC,Q;IAN5B,oBAAgB,CAAhB,C;IAEA,OAAO,cAAY,CAAnB,C;MACI,oBAAoB,CJ9ST,oBI8SS,CJ9SU,aAAnB,I;MI+SX,IAAI,iBAAiB,WAArB,C;QACI,4BAAa,aAAb,I;QACoB,OAAF,CAAE,gB;QAAF,iB;UAAa,MAAM,iBAAa,0BAAb,C;SAArC,+BAAkB,IAAlB,C;;QHtYC,U;QAAb,aAAa,UGwYD,CHxYC,qBAL+B,CAK/B,sBAAkB,qBALa,CAKb,C;QAC/B,qBAAqB,MAAO,a;;UGwYZ,oBHtYN,MGsYM,EAAiB,WAAjB,C;;UHpYZ,oBAAoB,MAAO,a;UAC3B,IAAI,gBAAgB,cAApB,C;YACI,MAAM,2BAAsB,yCAAtB,C;WAEV,IAAI,kBAAiB,MAAO,cAA5B,C;YG+XQ,CH9XJ,oBAAW,MAAX,C;;YG8XI,CH5XJ,gBAAe,a;;;QG+XX,K;;;EAGZ,C;iDAEA,gB;IAUgC,Q;IAN5B,oBAAgB,CAAhB,C;IAEA,OAAO,mCAAP,C;MACI,oBAAoC,oBAAhB,CJlUT,oBIkUS,CJlUU,aAAnB,IIkUyB,C;MACpC,IAAI,8BAAiB,WAAjB,MAAJ,C;QACI,mCAAa,aAAb,C;QACoB,OAAF,CAAE,gB;QAAF,iB;UAAa,MAAM,iBAAa,0BAAb,C;SAArC,+BAAkB,IAAlB,C;;QH1ZC,U;QAAb,aAAa,UG4ZD,CH5ZC,qBAL+B,CAK/B,sBAAkB,qBALa,CAKb,C;QAC/B,qBAAqB,MAAO,a;;UG4ZZ,oBH1ZN,MG0ZM,EAAiB,WAAU,QAA3B,C;;UHxZZ,oBAAoB,MAAO,a;UAC3B,IAAI,gBAAgB,cAApB,C;YACI,MAAM,2BAAsB,yCAAtB,C;WAEV,IAAI,kBAAiB,MAAO,cAA5B,C;YGmZQ,CHlZJ,oBAAW,MAAX,C;;YGkZI,CHhZJ,gBAAe,a;;;QGmZX,K;;;EAGZ,C;4CAEA,2B;IACI,kBAAU,GAAV,EAAe,KAAf,EAAsB,GAAtB,EAA2B,sBAAS,MAApC,C;IACA,OAAO,I;EACX,C;2DAEA,6B;IAKI,UAAU,K;IACV,IAAI,OAAO,GAAX,C;MAAgB,OAAO,G;IACvB,MAA0B,MAApB,8BAAiB,CAAjB,CAAoB,EAAM,GAAN,C;IAC1B,qB;IAEA,OAAO,MAAM,GAAb,C;MACI,MAAuB,MAAjB,+BAAiB,EAAM,GAAN,C;MACvB,qB;;IAGJ,OAAO,G;EACX,C;qDAEA,a;IAEI,kBAAU,CAAV,C;EACJ,C;qDAEA,c;IAEI,kBAAU,EAAV,C;EACJ,C;mDAEA,yB;ICmQJ,qG;IDnQI,+B;MAEI,IAAK,CAAL,cAAQ,GAAR,C;QACI,4BAAY,OAAF,CAAE,CAAZ,C;QAFwC,OAGxC,C;aAEJ,QAAI,IAAJ,C;QACI,WAAc,mB;QtB1Cb,aAAM,gB;QAAN,YAAc,uB;QuB6SnB,qBvB7SkC,euB6Sb,GAAe,KAAf,I;QACrB,IAAI,iBDpQW,CCoQf,C;UACI,MAAM,sCDrQK,CCqQL,EAAuC,cAAvC,C;SAEV,eAAM,M;QAAN,aAAc,K;QDtQN,QpB9aR,KAAK,SoB8aU,MpB9aV,EoB8aoD,OAA/B,MAAU,KAAM,EAAP,GAAe,EAAO,CpB9apD,C;QoB+aG,QpB/aR,KAAK,SoB+aU,SAAS,CAAT,IpB/aV,EoB+auD,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CpB/avD,C;QoBgbG,QpBhbR,KAAK,SoBgbU,SAAS,CAAT,IpBhbV,EoBgb+C,OAAtB,MAAS,IAAM,EAAO,CpBhb/C,C;QFmYT,SsB0CmB,C;QtBzCnB,gCAAc,EAAd,C;QsBmCgD,OAWxC,C;;QAGA,aAAc,mB;QtBlDb,eAAM,gB;QAAN,cAAc,uB;QuB6SnB,uBvB7SkC,euB6Sb,GAAe,OAAf,I;QACrB,IAAI,mBD5PW,CC4Pf,C;UACI,MAAM,wCD7PK,CC6PL,EAAuC,gBAAvC,C;SAEV,eAAM,Q;QAAN,eAAc,O;QD9PN,QpBtbR,KAAK,SoBsbU,QpBtbV,EoBsbmD,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CpBtbnD,C;QoBubG,QpBvbR,KAAK,SoBubU,WAAS,CAAT,IpBvbV,EoBub+C,OAAtB,MAAS,IAAM,EAAO,CpBvb/C,C;QFmYT,WsBkDmB,C;QtBjDnB,gCAAc,IAAd,C;QsBmCgD,OAkBxC,C;;K;GAnBR,C;qCAuBA,Y;IAII,Y;EACJ,C;sDAEA,a;IAGQ,Q;IADJ,IAAI,CAtYuC,gCAAmB,yBAAnB,IAsYvC,KAAiB,CAArB,C;MACI,0C;QACO,qCAAwB,yBAAxB,C;QACH,W;QAGR,OAAO,+B;EACX,C;4CAEA,Y;IAEI,Q;IAAA,0C;MAAa,4BAAkB,kB;KACnC,C;6IAEA,yB;IxCxaJ,iF;IwCwaI,8B;MAEI,aAAa,8BAAiB,IAAjB,C;;QAET,aAAa,MAAM,MAAN,C;QxClarB,IAAI,EwCmaU,UAAU,CxCnapB,CAAJ,C;UACI,cwCkayB,0C;UxCjazB,MAAM,2BAAsB,OAAQ,WAA9B,C;SwCmaF,OAAO,M;;QAEP,qB;;IAER,C;GAXA,C;6CAaA,a;IxC3aA,IAAI,EwC8aM,KAAK,CxC9aX,CAAJ,C;MACI,cwC6agB,gD;MxC5ahB,MAAM,2BAAsB,OAAQ,WAA9B,C;KAFV,IAAI,EwC+aM,MAraqC,gCAAmB,yBAAnB,IAqarC,CxC/aN,CAAJ,C;MACI,gBwC8a4B,4DArae,gCAAmB,yBAAnB,IAqaf,C;MxC7a5B,MAAM,2BAAsB,SAAQ,WAA9B,C;KwCgbN,wDAAgB,CAAhB,I;EACJ,C;0CAEA,kB;IAGsB,Q;IAAlB,+BAAkB,6DAAlB,C;EACJ,C;6CAEA,Y;IAMyC,Q;IAAA,0F;G;mCAEzC,Y;EAEA,C;;;;;;EA3gBA,0C;IAAA,wD;IAAoD,2BAAK,CAAL,EAAQ,IAAR,C;IAApD,Y;G;EAEA,sC;IAAA,wD;IAAuB,oBAAK,mCAAY,KAAjB,Q;IAAvB,Y;G;ExBvBJ,kF;EAAA,uE;EAAA,kD;IAOgB,sC;IAAS,gC;G;EAPzB,2CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;EEawB,wB;IAmWpB,8B;IAnWqB,oB;IACrB,6BAA6C,sBAAkB,WEGlB,KAAK,WFHL,C;IAsD7C,gBAG2B,WEtDkB,KAAK,W;G;;;SFM9C,Y;MAAQ,OAAA,0BAAY,a;K;SACpB,iB;MACI,0CAA2B,K;IAC/B,C;;;;SASA,Y;MAAQ,OAAA,0BAAY,c;K;SACpB,iB;MACI,2CAA4B,K;IAChC,C;;;;SAOA,Y;MAAQ,OAAA,0BAAY,S;K;SACpB,iB;MACI,sCAAuB,K;IAC3B,C;;;;SAUA,Y;MAAQ,OAAA,0BAAY,M;K;SACpB,iB;MACI,mCAAoB,K;IACxB,C;;;;gGAK0B,Y;MAAQ,uBAAW,UAAX,I;K;;;;uGAUD,Y;MAAQ,4BAAgB,iBAAhB,I;K;;;;wGAKP,Y;MAAQ,oBAAQ,kBAAR,I;K;;;;SAQ1C,Y;MAAQ,OAAA,0BAAY,W;K;SACpB,iB;MACI,wCAAyB,K;IAC7B,C;;0CAEJ,iB;IAKwB,qB;MAAA,QAvBqB,qBAAgB,iBAAhB,I;KAwBzC,IAAI,UAAS,CAAb,C;MAAgB,M;IAEhB,sBAAsB,oBAAe,KAAf,I;IACtB,IAAI,QAAQ,CAAR,IAAa,kBAAkB,kBAAnC,C;MACI,cAAc,KAAd,EA5BqC,qBAAgB,iBAAhB,IA4BrC,C;KAEJ,oBAAe,e;EACnB,C;qCAEA,iB;IAEe,QAnC8B,qBAAgB,iBAAhB,I;IAmCzC,WnBiJG,MAAO,KmBjJO,KnBiJP,EAAO,CAAP,C;ImBhJV,0BAAa,IAAb,C;IACA,OAAO,I;EACX,C;qCAEA,iB;IAEe,QAA2B,oBA1CG,qBAAgB,iBAAhB,IA0CH,C;IAAtC,WAAgD,CAA/B,KnBmJV,iBAAK,CAAL,MAAJ,GmBnJc,KnBmJd,GAAmB,CmBnJ0B,S;IAChD,0BAAa,IAAb,C;IACA,OAAY,oBAAL,IAAK,C;EAChB,C;2CAEA,iB;IAEI,uBAAuB,qBAAgB,KAAhB,I;IACvB,IAAI,QAAQ,CAAR,IAAa,mBAAmB,UAApC,C;MACI,oBAAoB,KAApB,EA9CsC,aAAQ,kBAAR,IA8CtC,C;KAEJ,qBAAgB,gB;EACpB,C;qDAEA,oB;IAKI,YAAY,U;IACZ,IAAI,WAAW,kBAAf,C;MACI,oBAAoB,WAAW,kBAAX,IAApB,EA1DsC,aAAQ,kBAAR,IA0DtC,C;KAEJ,IAAI,YAAY,KAAhB,C;MACI,IAAI,aAAY,KAAhB,C;QACI,qBAAgB,Q;QAChB,OAAO,K;OAEX,oBAAoB,WAAW,kBAAX,IAApB,EAjEsC,aAAQ,kBAAR,IAiEtC,C;KAGJ,qBAAgB,Q;IAChB,OAAO,I;EACX,C;+CAEA,oB;IACI,IAAI,WAAW,CAAX,IAAgB,WAAW,kBAA/B,C;MACI,cAAc,WAAW,iBAAX,IAAd,EA/EqC,qBAAgB,iBAAhB,IA+ErC,C;KAGJ,IAAI,sBAAgB,QAApB,C;MACI,oBAAe,Q;KAEvB,C;oCAEA,iB;IAIkB,qB;MAAA,QAAa,oBAAe,aAAf,I;IAC3B,sBAAsB,oBAAe,KAAf,I;IACtB,IAAI,kBAAkB,aAAtB,C;MACI,aAAa,KAAb,EAAoB,oBAAe,aAAf,IAApB,C;KAEJ,oBAAe,e;EACnB,C;EAO2B,yD;IAAA,mB;MAAE,4CAAkC,gB;IAAU,C;G;6CALzE,oB;IFzKA,IAAI,EE8KQ,YAAY,CF9KpB,CAAJ,C;MACI,oCE6KuB,uCF7KvB,C;MAKA,CAAE,S;KE0KF,IAAI,qBAAgB,QAApB,C;MACI,gBAAgB,Q;MAChB,M;KAGJ,IAAI,sBAAgB,kBAApB,C;MACI,IAAI,WAAW,UAAf,C;QACI,0CAAoC,QAApC,C;OAGJ,qBAAqB,Q;MACrB,oBAAoB,Q;MACpB,gBAAgB,Q;MAChB,M;KAGJ,gCAA0B,QAA1B,C;EACJ,C;EAQyB,qD;IAAA,mB;MAAE,0CAAgC,c;IAAQ,C;G;2CANnE,kB;IFnMA,IAAI,EEyMQ,UAAU,CFzMlB,CAAJ,C;MACI,oCEwMqB,mCFxMrB,C;MAKA,CAAE,S;KEqMF,eAAe,gBAAW,MAAX,I;IACf,IAAI,YAAY,kBAAhB,C;MACI,aAAQ,Q;MACR,M;KAGJ,IAAI,WAAW,CAAf,C;MACI,2CAAqC,MAArC,C;KAEJ,IAAI,WAAW,aAAf,C;MACI,2CAAqC,MAArC,C;KAGJ,IAAI,sBAAgB,kBAApB,C;MACI,aAAQ,Q;MACR,oBAAe,Q;MACf,qBAAgB,Q;MAChB,M;KAGJ,0CAAoC,MAApC,C;EACJ,C;kCAEA,Y;IAII,gBAAW,C;IACX,oBAAe,C;IAEf,eAAe,a;IACf,qBAAgB,Q;EACpB,C;mCAEA,Y;IAII,2BAAc,gBAAW,aAAX,IAAd,C;EACJ,C;2CAEA,iB;IAMI,eAAe,a;IACf,oBAAe,Q;IACf,qBAAgB,Q;IAChB,aAAa,K;EACjB,C;yCAEA,Y;IAII,6BAAgB,CAAhB,C;IACA,4B;EACJ,C;2CAEA,Y;IACI,aAAQ,a;EACZ,C;EAGkC,gE;IAAA,mB;MAAE,mDAAyC,uB;IAAiB,C;G;EACjD,+E;IAAA,mB;MACrC,qEAA2D,uBAA3D,WAA8E,wB;IAClF,C;G;6CAJJ,2B;IF5QA,IAAI,EE6QQ,mBAAmB,CF7Q3B,CAAJ,C;MACI,oCE4Q8B,8CF5Q9B,C;MAKA,CAAE,S;KANN,IAAI,EE8QQ,mBAAmB,iBF9Q3B,CAAJ,C;MACI,sCE6QyC,sDF7QzC,C;MAKA,GAAE,S;KE4QF,oBAAe,e;IACf,IAAI,gBAAW,eAAf,C;MACI,gBAAW,e;KAEnB,C;yCAEA,gB;IACI,aAAa,U;IACb,gBAAgB,a;IAChB,oBAAoB,iB;IACpB,qBAAqB,kB;EACzB,C;+BAEA,Y;IAGqD,gBAAf,WAAO,WAAP,C;IR1NtC,SQ2NI,qBR3NJ,SQ2NI,C;IADkC,ORzN/B,S;G;iCQ6NP,Y;IAQI,mBAAmB,iB;IACnB,IAAI,iBAAgB,kBAApB,C;MAAmC,OAAO,E;IAC1C,OAAO,WE/RA,KAAK,SF+RE,YE/RF,CF+RL,GAAiC,G;EAC5C,C;iCAEA,Y;IAQI,mBAAmB,iB;IACnB,IAAI,iBAAgB,kBAApB,C;MAAmC,OAAO,E;IAC1C,oBAAoB,eAAe,CAAf,I;IACpB,OAAO,WE7SA,KAAK,SF6SE,YE7SF,CF6SL,GAAiC,G;EAC5C,C;8BAEA,Y;IAQI,mBAAmB,iB;IACnB,IAAI,iBAAgB,kBAApB,C;MACI,MAAM,iBAAa,8BAAb,C;KAEV,oBAAoB,eAAe,CAAf,I;IACpB,OAAO,WE7TA,KAAK,SF6TE,YE7TF,C;EF8ThB,C;uCAEA,iB;IAKI,oBAAoB,kB;IACpB,IAAI,kBAAiB,UAArB,C;MACI,MAAM,+BAA2B,6CAA3B,C;KAEV,WE3TA,KAAK,SF2TE,aE3TF,EF2TmB,KE3TnB,C;IF4TL,qBAAqB,gBAAgB,CAAhB,I;EACzB,C;2BAEA,Y;IAII,0B;IACA,oB;EACJ,C;8BAEA,Y;IACI,OAAO,aAjSkC,qBAAgB,iBAAhB,IAiSlC,iBA5RmC,aAAQ,kBAAR,IA4RnC,iBAAqD,iBA3S1B,gBAAW,UAAX,IA2S0B,KAArD,sBAAqF,aAArF,M;EACX,C;EAEA,4B;IAAA,gC;IACI,oBAMqC,C;G;;;SAMZ,Y;MAAQ,OAAA,gCAAS,M;K;;;;;;;;EAb9C,wC;IAAA,uC;MAAA,sB;KAAA,gC;G;;;;;;qGAiBJ,qB;IAG8C,iCAAgB,sB;G;uGAE9D,qB;IAG+C,yBAAQ,uB;G;iGAEvD,4B;IAYI,SAAS,MAAM,gBAAN,EAAc,sBAAd,EAA4B,uBAA5B,C;IACT,+BAAa,EAAb,C;IACA,OAAO,E;EACX,C;mGAEA,4B;IAYI,SAAS,MAAM,gBAAN,EAAc,uBAAd,EAA6B,eAA7B,C;IACT,gCAAc,EAAd,C;IACA,OAAO,E;EACX,C;EAEA,6C;IACI,MAAM,iBAAa,uBAAoB,KAApB,qBAAuC,aAAvC,2BAAb,C;EACV,C;EAEA,oD;IACI,MAAM,iBAAa,uBAAoB,KAApB,qBAAuC,cAAvC,2BAAb,C;EACV,C;EAEA,8C;IACI,MAAM,8BAAyB,sBAAmB,KAAnB,qBAAsC,eAAtC,uBAAzB,C;EACV,C;EAEA,kE;IACI,IAAI,WAAW,kBAAf,C;MACI,MAAM,8BAAyB,eAAY,QAAZ,qCAAkD,kBAA3E,C;KAGV,MAAM,2BACF,uBAAoB,QAApB,uCA7XkC,qBAAW,eAAX,IA6XlC,gCADE,C;EAGV,C;EAEA,wD;IACI,MAAM,2BACF,uBAAoB,QAApB,qBACI,wBA1XqC,0BAAgB,sBAAhB,IA0XrC,2CAAoE,sBADxE,CADE,C;EAIV,C;EAEA,iE;IACI,MAAM,8BAAyB,aAAU,MAAV,iCAA0C,kBAAnE,C;EACV,C;EAEA,iE;IACI,MAAM,8BACF,aAAU,MAAV,uCAAgD,kBAAhD,qCADE,C;EAGV,C;EAEA,gE;IACI,MAAM,8BACF,+BAA4B,MAA5B,UACI,yBA3YqC,0BAAgB,sBAAhB,IA2YrC,kCAA4D,sBADhE,CADE,C;EAIV,C;EAEA,0C;IACI,kCAAgB,yBAAe,IAAf,IAAhB,C;EACJ,C;EAGuC,6C;IAAC,uB;MAAA,UAAkB,uB;mBAAqC,O;;G;;;;;;EAC3F,sE;IAAA,oE;IAGI,uCAAK,oCAAiC,IAAjC,0BAAwD,cAAxD,YAAL,C;IAHJ,Y;G;EAKA,8E;IAAA,oE;IAII,uCAAK,oCAAiC,IAAjC,YAA0C,IAA1C,0BAAiE,cAAjE,YAAL,C;IAJJ,Y;G;EAMA,wE;IAAA,oE;IAGI,uCAAK,oCAAiC,IAAjC,qCAAwD,cAAxD,uBAAL,C;IAHJ,Y;G;EwB9eJ,sD;IAMe,QAAM,KxBwE4B,iBwBxE5B,KxBwE4C,aAAhB,I;IwBxE7C,W3C4PO,MAAO,KAAI,CAAJ,E2C5PwB,O3C4PxB,C;I2C1Pd,IAAI,CxB2E0C,kBAAQ,uBAAR,IwB3E1C,KAAkB,IAAtB,C;MACI,sCAA2B,IAA3B,C;KxBiaK,UAAM,gB;IAAN,gBAAc,uB;IAAe,e;IAjB7B,UAAM,Y;IAAN,gBAAc,kB;IAAc,mB;IwB3Y7B,GAAI,qBAAY,SAAZ,kB;IxB2YZ,a;IACA,2BAAa,EAAb,C;IAgBA,WAfO,E;IAgBP,gCAAc,IAAd,C;IwB/ZA,OxBgaO,I;EwB1ZX,C;EAEA,8C;IAOI,WAAW,KxBmDkC,iBwBnDlC,KxBmDkD,aAAhB,I;IwBlD7C,mBAAmB,sB;IAEnB,IAAI,eAAe,IAAnB,C;MACI,MAAM,8BAAyB,oDAAzB,C;KAGV,sBAAsB,eAAe,IAAf,I;IACtB,KAAM,OAAO,gBAAO,gBAAP,EAAe,KAAM,aAArB,EAAmC,IAAnC,EAAyC,eAAzC,C;IACb,KAAM,sBAAa,IAAb,C;IACN,kCAAgB,eAAhB,C;IAEA,OAAO,I;EACX,C;EAEA,0D;IACI,IAAI,ExBwC0C,kBAAQ,uBAAR,IwBxC1C,KxByBkC,qBAAW,eAAX,IwBzBlC,SAA0B,SAA9B,C;MACI,MAAM,8BAAyB,uDAAzB,C;KAEV,uBAAuB,0BAAgB,SAAhB,I;IACvB,kBAAkB,mBAAmB,eAAnB,I;IAElB,IAAI,cAAc,CAAlB,C;MACI,iC;KAER,C;E1BlDA,kF;EAAA,uE;EAAA,kD;IAOgB,sC;IAAS,gC;G;EAPzB,2CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;E2BUwB,oC;IAAA,mB;MAAE,yCAA+B,a;IAAO,C;G;EAC3B,iD;IAAA,mB;iFACgC,a;;MAA7D,ezBqE0C,cAAQ,mBAAR,IyBrE1C,C;IACJ,C;G;EAPJ,uC;I3BAI,IAAI,E2BII,SAAS,C3BJb,CAAJ,C;MACI,oC2BGgB,kB3BHhB,C;MAKA,CAAE,S;KANN,IAAI,E2BKI,UzBsEsC,kBAAQ,uBAAR,IyBtEtC,C3BLJ,CAAJ,C;MACI,sC2BI6B,+B3BJ7B,C;MAKA,GAAE,S;K2BGC,OAAP,gBAAO,EAAK,uBAAL,EAAoB,KAApB,EAA2B,KAA3B,C;IACP,gCAAc,KAAd,C;EACJ,C;EAEA,yC;IAII,gBAAK,KAAL,EAAY,KrCiOuB,KqCjOnC,C;EACJ,C;EAEA,iC;IdzBI,Ic8BK,Cd9BD,eAAQ,UAAZ,C;MAA2B,wBc8BtB,Cd9BsB,Ec8BR,Gd9BQ,C;Ic8B3B,gBAAK,Cd7BE,Qc6BP,EAAyB,CAAzB,C;EACJ,C;EAEA,gC;IAI2C,yBAAO,CAAP,C;G;EAE3C,6B;IACuC,4B;G;EAEvC,+B;IACiD,4B;G;EAEjD,0B;EAEA,C;EAEA,iD;IACI,OAAO,yBAAY,sBAAkB,GAAlB,EAAuB,CAAvB,EAA0B,GAAI,OAA9B,CAAZ,EAAiD,KAAjD,EAAwD,GAAxD,C;EACX,C;EAEA,mD;IACI,iC;IAGI,aAAiB,azB8WN,gByB9WM,mBzB8WE,uByB9WF,EzB8WiB,eyB9WjB,C;IACjB,sB1CkNkC,CAuFG,gB0BlTiB,QgBSlC,MJoKc,MZ7KM,KAAU,EAAI,C1BkTjB,CAvFH,MAAL,GAAiB,K;IiB2JlD,SjB3JsC,CAuFG,gB0B/SmB,QgBOxD,MJoK6B,MZ3KU,GAAS,KAAQ,C1B+SnB,CAvFH,MAAL,GAAiB,K;IiB4JlD,gCAAc,EAAd,C;IyB1WA,OAAO,QAAQ,mBAAR,I;EACX,C;EAEA,8B;IzBsWa,aAAM,gB;IAAN,YAAc,uB;IAAd,mBAA6B,e;IAA7B,gB;IyBnWa,QAAqB,K;IAArB,sB;IJ0RtB,IAAK,CAAL,cAAQ,GAAR,C;MI1Re,MvBhCX,KAAK,SuBgCyB,KvBhCzB,EmB2Ta,OAAF,CAAE,CnB3Tb,C;MmByTsD,qBAG3D,C;WAEJ,IAAK,GAAL,cAAW,IAAX,C;MI9Re,MvBhCX,KAAK,SuBgCyB,KvBhCzB,EmB+TyC,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CnB/TzC,C;MuBgCM,MvBhCX,KAAK,SuBgCyB,KJgSzB,GAAS,CAAT,InBhUA,EmBgUqC,OAAtB,MAAS,IAAM,EAAO,CnBhUrC,C;MmByTsD,qBAQ3D,C;WAEJ,IAAK,IAAL,cAAY,KAAZ,C;MInSe,MvBhCX,KAAK,SuBgCyB,KvBhCzB,EmBoU0C,OAA/B,MAAU,KAAM,EAAP,GAAe,EAAO,CnBpU1C,C;MuBgCM,MvBhCX,KAAK,SuBgCyB,KJqSzB,GAAS,CAAT,InBrUA,EmBqU6C,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CnBrU7C,C;MuBgCM,MvBhCX,KAAK,SuBgCyB,KJsSzB,GAAS,CAAT,InBtUA,EmBsUqC,OAAtB,MAAS,IAAM,EAAO,CnBtUrC,C;MmByTsD,qBAc3D,C;WAEJ,IAAK,KAAL,cAAc,OAAd,C;MIzSe,MvBhCX,KAAK,SuBgCyB,KvBhCzB,EmB0U0C,OAA/B,MAAU,KAAM,EAAP,GAAe,CAAO,CnB1U1C,C;MuBgCM,MvBhCX,KAAK,SuBgCyB,KJ2SzB,GAAS,CAAT,InB3UA,EmB2U8C,OAA/B,MAAU,KAAM,EAAP,GAAe,EAAO,CnB3U9C,C;MuBgCM,MvBhCX,KAAK,SuBgCyB,KJ4SzB,GAAS,CAAT,InB5UA,EmB4U6C,OAA9B,MAAU,KAAM,CAAP,GAAc,EAAO,CnB5U7C,C;MuBgCM,MvBhCX,KAAK,SuBgCyB,KJ6SzB,GAAS,CAAT,InB7UA,EmB6UqC,OAAtB,MAAS,IAAM,EAAO,CnB7UrC,C;MmByTsD,qBAqB3D,C;;MArB2D,qBAuBvD,mBAAmB,CAAnB,C;;IIhTJ,6B;IAEI,YAAO,eAAe,KAAf,IAAP,E;MAFJ,eAEmC,aAAa,CAAb,C;;MAFnC,eAGY,I;;IzBgWhB,qB;IACA,gCAAc,EAAd,C;IyB7VA,OAAO,S;EACX,C;EAEA,kC;IAEI,IAAI,WAAJ,C;MACI,OAAO,oBAAO,MAAP,C;KAGX,OAAO,oBAAO,GAAP,EAAY,CAAZ,EAAe,GAAI,OAAnB,C;EACX,C;EAEA,8C;IAEI,IAAI,WAAJ,C;MACI,OAAO,oBAAO,MAAP,a;KAGX,IAAI,iDAAJ,C;MACI,aAAa,eAAb,C;KANqE,gB;G;EAU7E,8B;IACI,MAAM,iCAA6B,8CAA2C,MAA3C,mBAA7B,C;EACV,C;EAEA,8C;IAEI,OAAO,oBAAO,sBAAkB,GAAlB,EAAuB,CAAvB,EAA0B,GAAI,OAA9B,CAAP,EAA4C,KAA5C,EAAmD,GAAnD,C;EACX,C;EAEA,4D;IAKI,mB;MAAA,MAAW,U;IAEX,OAAe,aAAR,OAAQ,EAAa,SAAb,EAAmB,GAAnB,EAAwB,UAAxB,EAAoC,GAApC,C;EACnB,C;EAEA,kC;IAQK,UAA6B,M;IAAR,CAArB,gEAAqB,kBAAQ,8DAAR,C;EAC1B,C;EAEA,4B;IAMmC,8B;G;EAEnC,qD;IAA8C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IzB8QhE,aAAM,gB;IAAN,YAAc,sB;IyB5QnB,IAAI,CzB4Q6B,uByB5Q7B,GAAe,KAAf,cAAJ,C;MACI,MAAM,iBAAa,yDAAb,C;KAGV,iBAAc,CAAd,0B;MACI,IAAI,kBAAJ,IAAsB,MvBzHnB,KAAK,SuByHqB,QAAQ,KAAR,IvBzHrB,C;;IFgYhB,e;IACA,+BAAa,EAAb,C;EyBnQJ,C;EAQI,kC;IAAQ,yC;G;EACR,4C;IACI,IAAI,+CAAJ,C;MAAsC,MAAM,mCAA8B,8BAA9B,C;EAChD,C;;2GC1JJ,yB;IAAA,kC;IAAA,gD;IAAA,8B;MAOI,OAAkD,KlCoDlC,CkCpDJ,gBAAO,qBAAiB,eAAM,IAAN,CAAxB,ClCoDI,C;IkCnDpB,C;GARA,C;6GAUA,uB;IAQW,Q;IADP,eAAe,IAAK,S;;MAEhB,aAAM,QAAN,C;;MAEA,IAAK,iBAAQ,QAAR,C;;IAHT,W;EAKJ,C;qHAEA,uB;IAUW,Q;IADP,eAAe,IAAK,S;;MAEhB,aAAM,QAAN,C;;MAEA,QAAS,iBAAQ,IAAR,C;;IAHb,W;EAKJ,C;;EAOgC,4D;IAC5B,0B;MAAA,aAA8B,I;IAC9B,wB;MAAA,WAAgB,I;IAChB,yB;MAAA,YAAmC,8B;IACnC,uBAAsB,QAAtB,C;IAHA,8B;IAEA,4B;G;gDAGA,Y;IACI,OAAO,aAAS,gBAAU,eAAM,iBAAN,CAAnB,EAAsC,IAAtC,EAA4C,IAA5C,C;EACX,C;wDAEA,oB;IACI,gBAAU,cAAK,QAAS,OAAd,C;IACJ,yDAAgB,QAAhB,C;IACN,QAAS,iB;EACb,C;yDAEA,oB;IACU,0DAAiB,QAAjB,C;IAEN,IAAI,aAAa,gCAAS,MAA1B,C;M5CkEyC,MAAM,2B4CjErC,qC5CiEmE,WAA9B,C;KA/CnD,IAAI,E4CfM,aAAa,gCAAS,M5Ce5B,CAAJ,C;MACI,c4ChBqC,qC;M5CiBrC,MAAM,2BAAsB,OAAQ,WAA9B,C;KAFV,IAAI,E4CdM,aAAa,8BAAO,M5Cc1B,CAAJ,C;MACI,gB4CfmC,qC;M5CgBnC,MAAM,2BAAsB,SAAQ,WAA9B,C;KAFV,IAAI,E4CbM,aAAa,mCAAY,M5Ca/B,CAAJ,C;MACI,gB4CdwC,qC;M5CexC,MAAM,2BAAsB,SAAQ,WAA9B,C;KAFV,IAAI,E4CXM,QAAS,eAAT,KAA2B,C5CWjC,CAAJ,C;MACI,gB4CZsC,6C;M5CatC,MAAM,2BAAsB,SAAQ,WAA9B,C;KAFV,IAAI,E4CVM,QAAS,KAAT,Q5CUN,CAAJ,C;MACI,gB4CX+B,mD;M5CY/B,MAAM,2BAAsB,SAAQ,WAA9B,C;KAFV,IAAI,E4CTM,QAAS,OAAT,Q5CSN,CAAJ,C;MACI,gB4CViC,0D;M5CWjC,MAAM,2BAAsB,SAAQ,WAA9B,C;K4CVV,C;sDAEA,oB;IACyC,gBAAxB,uDAAc,QAAd,C;IlCRjB,SkCSQ,iB;IlCTR,SkCUQ,Q;IAFJ,OlCPG,S;EkCWP,C;;;;;;E5B1FJ,kF;EAAA,uE;EAAA,kD;IAOgB,sC;IAAS,gC;G;EAPzB,2CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;EyBosB6E,6D;IAAA,mB;MACjE,MAAM,iBAAa,gCAA6B,YAA7B,iBAA2C,YAA3C,MAAb,C;IACV,C;G;EAXR,uBAQS,yB;IzBnsBT,uF;IAAA,kF;IAAA,kC;IAAA,gF;IAAA,mE;IAAA,gD;MAOgB,sC;MAAS,gC;K;IAPzB,yCAQY,Y;MACI,MAAM,8BAAyB,sBAAzB,C;IACV,C;IAVZ;;;K;WyBmsBS,oE;MAAA,8C;QAC8B,gBAAQ,gBAAe,KAAf,SAAwB,Y;QAAhC,cAAsC,mD;QzB9rBzE,IAAI,CAAC,SAAL,C;UACI,0C;UAKA,CAAE,S;SyB2rBF,kBAAQ,cAAM,MAAN,EAAc,KAAd,C;QAHR,OAIA,Y;MACJ,C;K;GANK,C;EzBnsBT,kF;EAAA,uE;EAAA,kD;IAOgB,sC;IAAS,gC;G;EAPzB,2CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;qGyBIA,4B;IvBmZa,aAAM,gB;IAAN,YAAc,sB;IAAd,mBAA4B,uB;IuB7YjC,iBAAc,KAAd,UAA0B,YAA1B,U;MACI,MAAM,MrBYH,KAAK,SqBZK,KrBYL,CqBZR,C;;IvB4YR,SuB1YI,eAAe,KAAf,I;IvB2YJ,+BAAa,EAAb,C;EuBzYJ,C;EAEA,8B;IAGuC,OnCmUG,emCnUH,oBnCmUG,C;G;2GmCjU1C,yB;IAAA,2C;IAAA,8B;IAAA,yD;IAAA,4B;MAEiD,Q;MAAD,OAAiB,UAAhB,2DAAgB,C;K;GAFjE,C;EAIA,sC;IAII,4BAAU,KnC0NyB,KmC1NnC,C;EACJ,C;EAEA,wC;IAGK,Q;IAAgB,WAAhB,2DAAgB,EAAW,KAAX,C;EACrB,C;EAEA,gC;IAIuC,WAAa,e;IAspBhD,qB;IvB1SS,aAAM,gB;IAAN,YAAc,sB;IFjZvB,IAAI,EyB8rBuC,CvB7SN,uBuB6SM,GAAe,KAAf,SAzpBE,CzBrCzC,CAAJ,C;MACI,oCyB6rBqE,8BAzpB5B,CAypB4B,CzB7rBrE,C;MAKA,CAAE,S;KyB2rBF,UAAc,MlCrsB4C,KAAK,UkCqsBzC,KlCrsByC,EAAiB,KAAjB,C;IWqZnE,SuB5W6C,C;IvB6W7C,+BAAa,EAAb,C;IuB7WmC,OAgqB5B,O;G;2GA5pBX,yB;IAAA,2C;IAAA,8B;IAAA,yD;IAAA,4B;MAEiD,Q;MAAD,OAAiB,UAAhB,2DAAgB,C;K;GAFjE,C;EAIA,+B;IAIyC,WAAa,wB;IA0oBlD,qB;IvB1SS,aAAM,gB;IAAN,YAAc,sB;IFjZvB,IAAI,EyB8rBuC,CvB7SN,uBuB6SM,GAAe,KAAf,SA7oBI,CzBjD3C,CAAJ,C;MACI,oCyB6rBqE,8BA7oB1B,CA6oB0B,CzB7rBrE,C;MAKA,CAAE,S;KyB2rBF,UxCnWqC,gBwCmWvB,MlCrsB4C,KAAK,UkCqsBzC,KlCrsByC,EAAiB,KAAjB,CNkW1B,C;IiBmDzC,SuBhW+C,C;IvBiW/C,+BAAa,EAAb,C;IuBjWqC,OAopB9B,O;G;6GAhpBX,yB;IAAA,2C;IAAA,8B;IAAA,2D;IAAA,4B;MAEmD,Q;MAAD,OAAiB,WAAhB,2DAAgB,C;K;GAFnE,C;EAIA,8B;IAImC,WAAa,iB;IA8nB5C,qB;IvB1SS,aAAM,gB;IAAN,YAAc,sB;IFjZvB,IAAI,EyB8rBuC,CvB7SN,uBuB6SM,GAAe,KAAf,SAjoBF,CzB7DrC,CAAJ,C;MACI,oCyB6rBqE,8BAjoBhC,CAioBgC,CzB7rBrE,C;MAKA,CAAE,S;KyB2rBF,UAAc,MlCjsBwC,KAAK,UkCisBrC,KlCjsBqC,EAAiB,KAAjB,C;IWiZ/D,SuBpVyC,C;IvBqVzC,+BAAa,EAAb,C;IuBrV+B,OAwoBxB,O;G;uGApoBX,yB;IAAA,2C;IAAA,8B;IAAA,qD;IAAA,4B;MAE6C,Q;MAAD,OAAiB,QAAhB,2DAAgB,C;K;GAF7D,C;EAIA,6B;IAIqC,WAAa,0B;IAknB9C,qB;IvB1SS,aAAM,gB;IAAN,YAAc,sB;IFjZvB,IAAI,EyB8rBuC,CvB7SN,uBuB6SM,GAAe,KAAf,SArnBA,CzBzEvC,CAAJ,C;MACI,oCyB6rBqE,8BArnB9B,CAqnB8B,CzB7rBrE,C;MAKA,CAAE,S;KyB2rBF,UvClU+B,cuCkUjB,MlCjsBwC,KAAK,UkCisBrC,KlCjsBqC,EAAiB,KAAjB,CL+X5B,C;IgBkBnC,SuBxU2C,C;IvByU3C,+BAAa,EAAb,C;IuBzUiC,OA4nB1B,O;G;yGAxnBX,yB;IAAA,2C;IAAA,8B;IAAA,uD;IAAA,4B;MAE+C,Q;MAAD,OAAiB,SAAhB,2DAAgB,C;K;GAF/D,C;EAIA,+B;IAIqC,WAAa,c;IAsmB9C,qB;IvB1SS,aAAM,gB;IAAN,YAAc,sB;IFjZvB,IAAI,EyB8rBuC,CvB7SN,uBuB6SM,GAAe,KAAf,SAzmBA,CzBrFvC,CAAJ,C;MACI,oCyB6rBqE,8BAzmB9B,CAymB8B,CzB7rBrE,C;MAKA,CAAE,S;KyB2rBM,eAAM,M;IAAN,aAAc,K;IAAtB,UlC5rB2B,oBkCiF/B,QlCjFC,KAAK,WkCiFY,MlCjFZ,EAAkB,KAAlB,CAAyB,CAA9B,WAA2C,EAA3C,CAAD,IACsC,oBkCgFtC,QlChFI,KAAK,WkCgFS,MlChFC,GAAS,CAAT,IAAV,EAAsB,KAAtB,CAA6B,CADtC,C;IW4YA,SuB5T2C,C;IvB6T3C,+BAAa,EA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yCimBI,UAAU,CzCjmBd,CAAJ,C;MACI,cAda,qB;MAeb,MAAM,8BAAyB,OAAQ,WAAjC,C;KAFV,IAAI,EyCkmBI,WAAU,GvBhjB4B,SuBgjB5B,GvBhjBoC,cAAR,IuBgjBtC,CzClmBJ,CAAJ,C;MACI,gBAda,qB;MAeb,MAAM,8BAAyB,SAAQ,WAAjC,C;KyCkmBV,WAAkB,gB;IA8DlB,qB;IvB1SS,aAAM,gB;IAAN,YAAc,sB;IFjZvB,IAAI,EyB8rBuC,CvB7SN,uBuB6SM,GAAe,KAAf,SAjEjC,MzB7nBN,CAAJ,C;MACI,oCyB6rBqE,8BAjE/D,MAiE+D,CzB7rBrE,C;MAKA,CAAE,S;KyB2rBY,MAnEP,gBAAW,UAAX,EAmEe,KAnEf,UAAuC,iBAAvC,C;IACH,iC;IAkEJ,c;IvBhTJ,SuB4OU,M;IvB3OV,+BAAa,EAAb,C;IuBmTO,O;IAnEP,OAAO,M;EACX,C;EAEA,kD;IAI6C,sB;MAAA,SAAc,GvB9jBT,SuB8jBS,GvB9jBD,cAAR,I;KuB+jB9C,IAAI,EvB5QsC,0BAAgB,sBuB4QtD,CAAJ,C;MAAgB,OAAO,E;IAEE,WAAJ,GvBjkByB,SuBikBzB,GvBjkBiC,cAAR,I;IuBikB/B,QvBtkB8B,0BAAgB,sBAAhB,I;IuBskB7C,e1C9UO,MAAO,WAAO,CAAP,E0C8U0C,M1C9U1C,C;I0CgVd,WAAoB,gB;IA6CpB,qB;IvB1SS,aAAM,gB;IAAN,YAAc,sB;IFjZvB,IAAI,EyB8rBuC,CvB7SN,uBuB6SM,GAAe,KAAf,SAhDjC,QzB9oBN,CAAJ,C;MACI,oCyB6rBqE,8BAhD/D,QAgD+D,CzB7rBrE,C;MAKA,CAAE,S;KyB2rBY,MAlDP,gBAAW,UAAX,EAkDe,KAlDf,YAAyC,iBAAzC,C;IACH,mC;IAiDJ,c;IvBhTJ,SuB6PU,Q;IvB5PV,+BAAa,EAAb,C;IuBmTO,O;IAlDP,OAAO,Q;EACX,C;EAEA,uC;IAII,aAAa,GvBplBgC,iBuBolBhC,GvBplBgD,aAAhB,I;IuBslB7C,WAAmB,yB;IvB1PV,aAAM,gB;IAAN,YAAc,uB;IuB6SnB,qBvB7SkC,euB6Sb,GAAe,KAAf,I;IACrB,IAAI,iBApDG,MAoDP,C;MACI,MAAM,wCArDH,MAqDG,EAAuC,cAAvC,C;KAEV,eAAM,M;IAAN,aAAc,K;IAtDV,UAAO,gBAAO,QAAP,EAAmB,gBAAnB,UAAyC,MAAzC,C;IACP,gC;IvB5PR,SuB0PW,M;IvBzPX,gCAAc,EAAd,C;EuB6PJ,C;EAOyB,2C;IAAA,mB;MAAE,0CAAgC,c;IAAQ,C;G;EAC1B,0D;IAAA,mB;kFAC6B,c;kBAAW,W;MAAzE,evBnmByC,sBAAgB,kBAAhB,IuBmmBzC,C;IACJ,C;G;EACkC,8D;IAAA,mB;8FAC4C,c;;MAA1E,evBjmB0C,cAAQ,mBAAR,IuBimB1C,C;IACJ,C;G;EAXJ,+C;IzBlqBI,IAAI,EyBuqBI,UAAU,CzBvqBd,CAAJ,C;MACI,oCyBsqBiB,yBzBtqBjB,C;MAKA,CAAE,S;KANN,IAAI,EyBwqBI,WAAU,GvBlmB2B,iBuBkmB3B,GvBlmB2C,aAAhB,IuBkmBrC,CzBxqBJ,CAAJ,C;MACI,sCyBuqBiC,gCzBvqBjC,C;MAKA,GAAE,S;KANN,IAAI,EyB2qBI,WvBhmBsC,kBAAQ,uBAAR,IuBgmBtC,CzB3qBJ,CAAJ,C;MACI,sCyB0qB8B,sCzB1qB9B,C;MAKA,GAAE,S;KyByqBN,WAAmB,yB;IvB7QV,aAAM,gB;IAAN,YAAc,uB;IuB6SnB,qBvB7SkC,euB6Sb,GAAe,KAAf,I;IACrB,IAAI,iBAjCG,MAiCP,C;MACI,MAAM,wCAlCH,MAkCG,EAAuC,cAAvC,C;KAEV,eAAM,M;IAAN,aAAc,K;IAnCV,UAAO,gBAAO,QAAP,EAAmB,gBAAnB,UAAyC,MAAzC,C;IACP,gC;IvB/QR,SuB6QW,M;IvB5QX,gCAAc,EAAd,C;EuBgRJ,C;yGAEA,yB;IAAA,sC;IAAA,8D;IzB3rBA,uF;IAAA,kF;IAAA,kC;IAAA,gF;IAAA,mE;IAAA,gD;MAOgB,sC;MAAS,gC;K;IAPzB,yCAQY,Y;MACI,MAAM,8BAAyB,sBAAzB,C;IACV,C;IAVZ;;;K;IyBosB6E,6D;MAAA,mB;QACjE,MAAM,sBAAa,gCAA6B,YAA7B,iBAA2C,YAA3C,MAAb,C;MACV,C;K;IAXR,uBAQS,yB;MzBnsBT,uF;MAAA,kF;MAAA,kC;MAAA,gF;MAAA,mE;MAAA,gD;QAOgB,sC;QAAS,gC;O;MAPzB,yCAQY,Y;QACI,MAAM,8BAAyB,sBAAzB,C;MACV,C;MAVZ;;;O;ayBmsBS,oE;QAAA,8C;UAC8B,gBAAQ,gBAAe,KAAf,SAAwB,Y;UAAhC,cAAsC,mD;UzB9rBzE,IAAI,CAAC,SAAL,C;YACI,0C;YAKA,CAAE,S;WyB2rBF,kBAAQ,cAAM,MAAN,EAAc,KAAd,C;UAHR,OAIA,Y;QACJ,C;O;KANK,C;IART,+C;MAMI,qB;MvB1SS,aAAM,gB;MAAN,YAAc,sB;MFjZvB,IAAI,EyB8rBuC,CvB7SN,uBuB6SM,GAAe,KAAf,azB9rBvC,CAAJ,C;QACI,kCyB6rBqE,mCzB7rBrE,C;QAKA,CAAE,S;OyB2rBF,UAAQ,MAAM,MAAN,EAAc,KAAd,C;MvBhTZ,a;MACA,+BAAa,EAAb,C;MuBmTA,OAAO,O;IACX,C;GAjBA,C;2GAmBA,yB;IAAA,qG;IAAA,+C;MvBtSa,aAAM,gB;MAAN,YAAc,uB;MuB6SnB,qBvB7SkC,euB6Sb,GAAe,KAAf,I;MACrB,IAAI,qBAAJ,C;QACI,MAAM,4CAAuC,cAAvC,C;OAEV,MAAM,MAAN,EAAc,KAAd,C;MvBjTJ,a;MACA,gCAAc,EAAd,C;IuBmTJ,C;GAdA,C;EhC/oBA,qC;IAG4B,qB;MAAA,QSUqB,0BAAgB,sBAAhB,I;KTT7C,IAAI,UAAS,CAAb,C;MACI,OAAO,c;KAGX,aAAa,cAAU,KAAV,C;IACb,uBAAU,MAAV,C;IACA,OAAO,M;EACX,C;EAEA,gC;IAEI,yBAAY,gCAAS,KAArB,C;EACJ,C;EAEA,wC;IAUqB,gB;IAHjB,IAAI,CAAC,2BAAL,C;MAAgB,M;IAEhB,aAAa,gB;IACb,gBAAgB,cAAC,gEAAc,IAAf,mC;IAGZ,kBADE,MACF,Y;MACI,0B;MACA,MAAO,iBAAQ,IAAR,C;;MAGP,SAAU,iBAAQ,SAAR,C;;EAGtB,C;EAEA,+B;IAAA,mC;IACsC,qB;G;yCAClC,Y;IAAwB,OAAA,gCAAS,M;G;;;;;;;EAFrC,2C;IAAA,0C;MAAA,yB;KAAA,mC;G;EAKA,qC;IACI,cAAc,S;IACd,OAAO,eAAP,C;MACI,WAAW,OAAQ,Y;MACnB,OAAQ,iBAAQ,IAAR,C;MACR,UAAU,I;;EAElB,C;+GAEA,4B;IAO0B,Q;IAHtB,cAAc,S;;MAEV,MAAM,OAAN,C;MACkB,OAAR,OAAQ,K;MAAR,iB;QAAgB,K;OAA1B,UAAU,I;;IACL,a;EACb,C;EAEA,4B;IAKoB,Q;IADhB,aAAa,qB;IACG,OAAL,SAAK,K;IAAL,iB;MAAa,OAAO,M;KAA/B,WAAW,I;IAEX,OAAY,UAAL,IAAK,EAAQ,MAAR,EAAgB,MAAhB,C;EAChB,C;EAEA,0C;IAIoB,Q;IAHhB,aAAa,qB;IACb,YAAY,M;IAEI,OAAL,SAAK,K;IAAL,iB;MAAa,OAAO,I;KAA/B,WAAW,I;IAEX,OAAY,UAAL,IAAK,EAAQ,IAAR,EAAc,MAAd,C;EAChB,C;EAEA,6B;IACoB,Q;IAAA,OAAL,SAAK,K;IAAL,iB;MAAa,OAAO,S;KAA/B,WAAW,I;IACX,OAAY,SAAL,IAAK,C;EAChB,C;EAEA,iC;IAI8C,oC;G;EAE9C,gC;IAEkD,OAAO,aAAP,MAAO,C;G;EAEzD,sC;IAEoB,Q;IADhB,UAAwB,oBSxFqB,0BAAgB,sBAAhB,ITwFrB,CAAd,KAAyB,CAAzB,C;IACM,OAAL,SAAK,K;IAAL,iB;MAAa,OAAO,G;KAA/B,WAAW,I;IAEX,OAAY,eAAL,IAAK,EAAa,GAAb,C;EAChB,C;EAEA,4B;IAEoB,Q;IADhB,IAAI,CS/FyC,0BAAgB,sBAAhB,IT+FzC,IAAgB,CAApB,C;MAAuB,OAAO,K;IACd,OAAL,SAAK,K;IAAL,iB;MAAa,OAAO,I;KAA/B,WAAW,I;IACX,OAAY,QAAL,IAAK,C;EAChB,C;2HAEA,yB;IAAA,kBACiE,+B;IADjE,4B;MACqD,mB;MAAA,OAAoC,CAA9B,SVwF5C,iBAAK,CAAL,MAAJ,GUxFgD,SVwFhD,GAAmB,CUxF2D,S;K;GADzF,C;uIAGA,yB;IAAA,kBAEe,+B;IAFf,uF;IAAA,qC;MAEI,IAAI,0CAAJ,C;QAAmC,MAAM,8BAAyB,OAAzB,C;MACzC,OAAO,SAAK,Q;IAChB,C;GAJA,C;EAMA,6E;IAEQ,WWhLwD,oBXgLxD,WWhLwC,KAAK,WAAW,CXgLxD,UAAmB,iBAAnB,C;IADO,QAGO,oBSjH2B,0BAAgB,sBAAhB,ITiH3B,C;IVgJX,UUjJH,GV6EO,iBAoEc,CApEd,MAAJ,GU7EH,GV6EG,GAoEkB,C;IUnJzB,WV+EW,qBAAK,GAAL,MAAJ,UAAmB,G;IUzE1B,gBAAO,gBACH,WADG,EAEH,gDAAe,MAAf,CAFG,EAGH,IAHG,EAIH,iBAJG,C;IAOP,OAAO,I;EACX,C;EAEyC,+C;mBAA8B,O;;G;;;;;;6GatMvE,yB;IAAA,yE;IAAA,qB;IAAA,wC;MAG8B,8B;QAAA,iBAAsB,C;MAKhD,cAAc,kBAAkB,cAAlB,C;;QAEV,MAAM,OAAN,C;QACA,OAAO,OAAQ,Q;;QACjB,gC;UACE,OAAQ,U;UACR,MAAM,C;;UALV,O;;IAOJ,C;GAhBA,C;EAoBA,0B;IAKI,mB;EACJ,C;EAMA,6C;IAAsD,iCAAsB,IAAtB,C;G;;;;;;EAMtD,qC;wBAAqE,I;G;;;;;;EN1CrE,kF;EAAA,uE;EAAA,kD;IAOgB,sC;IAAS,gC;G;EAPzB,2CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;E6BgC8B,iD;IAC1B,8B;MAAA,iBAAkC,C;IAElC,yCAC0B,IAD1B,C;IAFA,sC;I7B3BA,IAAI,E6BiCQ,yBAAkB,C7BjC1B,CAAJ,C;MACI,oC6BgC6B,mC7BhC7B,C;MAKA,CAAE,S;M;;;S6BkCF,Y;MAAQ,iB;K;;;;SAMR,Y;MAAQ,sBAAS,C;K;;;;SAMjB,Y;MAAQ,oBAAQ,C;K;;;;SAIhB,Y;MAAQ,gB;K;;iDAEZ,Y;EAIA,C;8CAEA,kC;EAIA,C;+CAEA,a;IACW,IAAM,I;IAAb,OAAO,cAAM,yEAAO,CAAP,CAAN,wC;EACX,C;+CAEA,e;IACW,IAAM,I;IAAb,OAAO,cAAM,yEAAO,GAAP,CAAN,wC;EACX,C;+CAEA,2B;IACW,IAAM,I;IAAb,OAAO,cAAM,yEAAO,GAAP,EAAY,KAAZ,EAAmB,GAAnB,CAAN,wC;EACX,C;kDAEA,a;IAGuD,2BAAO,CAAP,C;G;kDAEvD,e;IAGkE,2BAAO,GAAP,C;G;kDAElE,2B;IAGwF,2BAAO,GAAP,EAAY,KAAZ,EAAmB,GAAnB,C;G;gDAExF,iB;ICzFO,Q;IADP,aAAa,e;;MAET,ODiGe,KCjGf,CAAM,MAAN,C;;MAEA,MAAO,U;;ID+FP,W;EACJ,C;sCAEA,Y;IAOiB,IAAN,I;IAHP,WAAW,S;IACX,WAAW,uB;IAGP,IADS,IACT,S;MAAuB,OAAf,sCAAe,M;;MACf,0BAAe,IAAf,EAA0B,oBAAL,IAAK,CAA1B,EAAoC,SAApC,C;IAFZ,W;EAIJ,C;sCAEA,Y;IAKI,c;EACJ,C;wCAEA,Y;IAII,OAAO,e;EACX,C;yCAEA,Y;IACI,OAAO,uBAAoB,SAApB,oB;EACX,C;EA1GiC,+D;IAAA,mB;MAAE,oDAA0C,uC;IAAgB,C;G;;;;;;EE9BrE,+C;IAqCxB,sC;IAhCA,sCAC2B,IAD3B,EACiC,SADjC,EAC4C,IAD5C,C;IAUI,gC;G;kCAGJ,Y;IAI0C,0BAAoB,QAAL,SAAK,CAApB,EAA+B,cAA/B,EAA0C,SAA1C,C;G;kCAE1C,Y;IAA0C,W;G;0CAE1C,uC;IACI,OAAO,C;EACX,C;yCAEA,Y;EACA,C;sCAEA,Y;IACI,OAAO,oBAAiB,cAAjB,iC;EACX,C;EAEA,oC;IAAA,wC;IACI,aAAmC,mBAAe,mCAAY,MAA3B,MAAsC,mCAAY,UAAlD,C;G;;;SAI/B,Y;MAAQ,Q;K;;;;;;;;EALhB,gD;IAAA,+C;MAAA,8B;KAAA,wC;G;;;;;;EA7BA,gD;IAAA,wD;IAAuE,2BAAK,IAAL,EAAgB,aAAL,IAAK,CAAhB,EAAgC,IAAhC,C;IAAvE,Y;G;EAEA,kD;IAAA,wD;IAEoE,2BAAK,IAAL,EAAgB,aAAL,IAAK,CAAhB,EAAgC,IAAhC,C;IAFpE,Y;G;EA2C6C,2D;IAI7C,8BAAmB,IAAnB,EAAyB,SAAzB,EAAoC,IAApC,C;G;;;;;;EACA,uE;IAAA,oE;IAKS,Q;IAAL,uCAAK,2DAAL,EAA0B,SAA1B,EAAqC,IAArC,C;IALJ,Y;G;qHAeJ,yB;IAAA,6B;IAAA,mE;IAEiD,mC;MAAC,W;IAAA,C;IAFlD,wC;MACmD,sB;QAAA,SAAc,C;MAAG,sB;QAAA,SAAc,KAAM,O;MACpF,OAAO,eAAe,KAAf,EAAsB,MAAtB,EAA8B,MAA9B,EAAsC,qBAAtC,C;IACX,C;GAHA,C;6FChFA,yB;IAAA,iF;IAAA,qB;IAAA,mC;MAGW,Q;MAFP,aAAa,K;;QAGT,aAAM,SAAN,C;;QACF,oC;;YAEM,SAAS,I;YACT,iB;;YACF,qC;cACQ,sBAAN,KAAM,EAAsB,MAAtB,C;;cAJV,Y;;UAOA,MAAM,K;;UAVH,W;;;QAYH,IAAI,CAAC,MAAL,C;UACI,iB;;MAbR,W;IAgBJ,C;GAnBA,C;ECFA,qC;IAOI,IAAI,4CAA0B,sCAA9B,C;MAEI,OAAO,0BAAe,MAAf,C;KAGX,e;;MAEI,WAAW,4B;MACX,IAAI,YAAJ,C;QACI,IAAI,8BAAY,CAAZ,SAAJ,C;UAA4B,K;QAC5B,Q;OAGJ,oBAAe,aAAL,IAAK,CAAf,C;MACA,MAAO,qBAAY,IAAZ,C;;IACF,a;IAET,OAAO,M;EACX,C;EAEA,2C;IACI,aAAa,mCAAY,KAAK,S;IAC9B,e;;;QAIQ,MAAO,gB;QACP,SAAS,4BAAc,MAAd,C;QACT,IAAI,OAAM,EAAV,C;UAAc,K;QACd,wCAAU,EAAV,E;QACO,cAAP,MAAO,EAAW,MAAX,C;;MACF,a;MAET,OAAO,M;;MAEP,MAAO,iBAAQ,mCAAY,KAApB,C;;EAEf,C;EC7CA,6B;G;;;;;;EZyMA,8B;IAKI,OAAO,mD;EACX,C;EAEA,sC;IAII,gBAAgB,0BAAQ,CAAR,C;IAChB,IAAI,mBAAa,CAAb,CAAJ,C;MACI,MAAM,2BAAsB,UAAO,SAAP,4CAA0C,CAA1C,0BAAtB,C;KAEd,C;EAEA,sC;IAII,0BAAe,oBAAF,CAAE,CAAf,C;EACJ,C;yGAEA,yB;IAAA,wF;IAAA,sF;IAAA,gF;IAAA,mC;MAWkB,UAQK,M;MATnB,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,M;OAAzC,cAAc,I;;;UAIN,IAAI,CAAC,MAAM,OAAN,CAAL,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,4BAAiB,OAAjB,C;;IAGZ,C;GA5BA,C;iHA8BA,yB;IAAA,wF;IAAA,sF;IAAA,gF;IAAA,gD;MASsC,2B;QAAA,cAAmB,C;MAEvC,UAoBK,M;MArBnB,cAAc,I;MACA,uCAAqB,WAArB,C;MAAA,iB;QAAqC,M;OAAnD,cAAc,I;MACd,WAAW,W;;;sBAIU,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEQ,OAAO,MAAM,OAAN,C;;4BAEC,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,4BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,4BAAiB,OAAjB,C;;IAGZ,C;GApDA,C;EAsDA,iC;IAEI,SAAS,mB;IACT,IAAI,MAAO,GAAP,MAAe,CAAnB,C;MAAsB,OAAU,OAAH,EAAG,C;IAChC,IAAI,OAAM,EAAV,C;MAAc,MAAM,iBAAa,qCAAb,C;IAEpB,OAAO,4BAAiB,EAAjB,C;EACX,C;uGAEA,yB;IA7FA,wF;IAAA,sF;IAAA,gF;IA6FA,mC;;QAlFkB,gB;QADd,cAAc,I;QACA,uCAAqB,CAArB,C;QAAA,iB;UAA2B,qB;SAAzC,cAAc,I;;;YAID,aAAM,O;YpBuKV,aoBnFL,MpBmFW,O;YAAN,YoBnFL,MpBmFmB,a;YAAd,mBoBnFL,MpBmFiC,c;YuB7YjC,iBAAc,KAAd,UAA0B,YAA1B,U;cACI,MAAM,MrBYH,KAAK,SqBZK,KrBYL,CqBZR,C;;YvB4YR,SuB1YI,eAAe,KAAf,I;YHuTA,MpBoFJ,sBAAa,EAAb,C;YoBxKQ,IAAI,CAqFR,IArFI,C;cACI,K;aAEJ,UAAU,K;YACC,wCAAoB,OAApB,C;YAAA,mB;cAAgC,K;aAA3C,WAAW,M;YACX,UAAU,I;YACV,UAAU,I;;UACL,a;;UAET,IAAI,OAAJ,C;YACI,4BAAiB,OAAjB,C;;;;IA6EZ,C;GATA,C;EAWA,4C;IACI,aAAS,EAAT,C;IACA,gBAAY,KAAZ,C;IAEA,kBAAc,cAAc,KAAd,C;;MAnEA,gB;MADd,cAAc,I;MACA,uCAAqB,WAArB,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAAW,W;;;sBAIU,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,SAAM,O;cA0DtB,qB;;gBCvNP,oBAAgB,CAAhB,C;gBACA,gBAAY,CAAZ,C;gBACA,wBAAoB,CAApB,C;gBrB8RS,aoBzEL,EpByEW,O;gBAAN,YoBzEL,EpByEmB,a;gBAAd,mBoBzEL,EpByEiC,c;gBqB3RjC,iBAAc,KAAd,UAA0B,YAA1B,U;kBACI,QAAQ,MnBtGL,KAAK,SmBsGO,KnBtGP,CmBsGA,GAA0B,G;kBAE9B,SAAM,GAAN,MAAc,CAAd,C;oBACI,IAAI,gBAAa,CAAjB,C;sBAAoB,mBAAmB,WAAnB,C;oBACf,SAAW,mBAAF,CAAE,E;oBD8MxB,UAAQ,I;oBACR,OAAK,a;oBC/MG,IAAI,CDgNZ,KChNQ,C;sBD6MZ,EC5MgB,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,E;sBAAP,sB;4BAGR,oBAAa,CAAb,C;oBAGI,WAAW,G;oBACX,UAAQ,C;oBAER,aAAU,CAAV,OAAa,CAAb,M;sBACI,IAAI,WAAU,IAAV,MAAkB,CAAtB,C;wBACI,UAAQ,UAAe,CAAL,I;wBAClB,OAAO,QAAS,C;wBAChB,iC;;wBAEA,K;;;oBAIR,kBAAgB,W;oBAChB,iC;oBAEA,IAAI,mBAAgB,eAAe,KAAf,IAAhB,CAAJ,C;sBDqLZ,ECpLgB,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,e;sBAAP,sB;;oBAKJ,UAAS,WAAU,CAAX,GAAkB,IAAM,G;oBAChC,iC;oBAEA,IAAI,gBAAa,CAAjB,C;sBACI,IAAI,eAAe,OAAf,CAAJ,C;wBACS,WAAe,mBAAN,OAAM,E;wBD0KpC,UAAQ,I;wBACR,OAAK,e;wBC3KW,IAAI,CD4KpB,KC5KgB,C;0BDyKpB,ECxKwB,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;gCAED,IAAI,CAAC,iBAAiB,OAAjB,CAAL,C;wBACH,mBAAmB,OAAnB,C;;wBAEK,WAA8B,mBAArB,cAAc,OAAd,CAAqB,E;wBDmKnD,UAAQ,I;wBACR,OAAK,e;wBCpKe,cDqKpB,K;wBCrKoB,Y;0BACC,WAA6B,mBAApB,aAAa,OAAb,CAAoB,E;0BDkKlD,UAAQ,I;0BACR,OAAK,e;0BCnKe,UDoKpB,K;yBCrKgB,W;0BDkKpB,EC/JwB,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;;sBAIR,UAAQ,C;;;gBrBmO5B,WqB7NI,eAAe,KAAf,I;gBDoJA,EpB0EJ,sBAAa,IAAb,C;gBqB3NA,oBAAO,C;;;cDuFS,wB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;;WAIA,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IAqCR,IAAI,CAAC,OAAL,C;MACI,MAAM,gCAA4B,0BAA5B,C;KAGV,OAAO,I;EACX,C;EAEA,gD;IAE8C,oB;MAAA,OAAY,GpB7QR,SoB6QQ,GpB7QA,cAAR,I;KoB6QmC,mCAAc,GAAd,EAAmB,IAAnB,C;G;EAErF,0D;IAGkD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAC7E,OAAO,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;EACX,C;EAEA,4D;IAGmD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAC9E,mCAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;G;EAEJ,4D;IAGiD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAC5E,mCAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;G;EAEJ,4D;IAGkD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAC7E,mCAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;G;EAEJ,4D;IAGmD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAC9E,mCAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;G;EAEJ,4D;IAGoD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAC/E,mCAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;G;EAEJ,4C;IAE0C,oB;MAAA,OAAY,GpBtTJ,SoBsTI,GpBtTI,cAAR,I;KoBsTgC,wBAAU,GAAV,EAAe,IAAf,C;G;EAElF,sD;IAG8C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACzE,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;G;EAEJ,wD;IAG+C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAC1E,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;G;EAEJ,wD;IAG6C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACxE,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;G;EAEJ,wD;IAG8C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACzE,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;G;EAEJ,wD;IAG+C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAC1E,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;G;EAEJ,wD;IAGgD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAC3E,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;G;E9B3aJ,sD;IAC2C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAiItE,oBAhI+B,MAgI/B,C;IACA,oBAjIuB,MAiIvB,C;;M8ByGc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,aAAM,O;U9B1GG,wB;UAAN,QAAiB,MU1DY,iBV0DZ,MU1D4B,aAAhB,I;UV0DzC,YT0HG,MAAO,aAAO,CAAP,C;US7PN,YAoIM,MApIN,OAoIc,WApId,EAoIyB,KApIzB,C;UAqIJ,4BAAa,KAAb,I;UACA,4BAAa,KAAb,I;U8BuGI,IAAI,E9BrGR,cAAY,C8BqGJ,CAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9BtPN,kBA0IK,W;IAwDP,IAAI,cAAO,CAAX,C;MACI,qBAAqB,WAArB,C;KAlMR,C;EAEA,sD;IAC4C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IA0KvE,oBAzK0B,MAyK1B,C;IACA,oBA1KkB,MA0KlB,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IA7KC,CA6KD,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cStPN,YA6KM,MA7KN,OA6Kc,WA7Kd,EA6KyB,KA7KzB,C;cA8KJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eA7K8B,C;;gBA6K9B,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9BrSN,kBAsLK,W;IAKP,IAAI,cAAO,CAAX,C;MACI,qBAAqB,WAArB,C;KA3LR,C;EAEA,sD;IAC0C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAmKrE,oBAlK0B,MAkK1B,C;IACA,oBAnKkB,MAmKlB,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IAtKC,CAsKD,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cS/ON,YAsKM,MAtKN,OAsKc,WAtKd,EAsKyB,KAtKzB,C;cAuKJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eAtK8B,C;;gBAsK9B,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9B9RN,kBA+KK,W;IAKP,IAAI,cAAO,CAAX,C;MACI,qBAAqB,WAArB,C;KApLR,C;EAEA,sD;IAC2C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IA4JtE,oBA3J0B,MA2J1B,C;IACA,oBA5JkB,MA4JlB,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IA/JC,CA+JD,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cSxON,YA+JM,MA/JN,OA+Jc,WA/Jd,EA+JyB,KA/JzB,C;cAgKJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eA/J8B,C;;gBA+J9B,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9BvRN,kBAwKK,W;IAKP,IAAI,cAAO,CAAX,C;MACI,qBAAqB,WAArB,C;KA7KR,C;EAEA,sD;IAC4C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAqJvE,oBApJ0B,MAoJ1B,C;IACA,oBArJkB,MAqJlB,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IAxJC,CAwJD,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cSjON,aAwJM,MAxJN,OAwJc,WAxJd,EAwJyB,KAxJzB,C;cAyJJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eAxJ8B,C;;gBAwJ9B,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9BhRN,kBAiKK,W;IAKP,IAAI,cAAO,CAAX,C;MACI,qBAAqB,WAArB,C;KAtKR,C;EAEA,sD;IAC6C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IA8IxE,oBA7I0B,MA6I1B,C;IACA,oBA9IkB,MA8IlB,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IAjJC,CAiJD,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cS1NN,aAiJM,MAjJN,OAiJc,WAjJd,EAiJyB,KAjJzB,C;cAkJJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eAjJ8B,C;;gBAiJ9B,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9BzQN,kBA0JK,W;IAKP,IAAI,cAAO,CAAX,C;MACI,qBAAqB,WAArB,C;KA/JR,C;EAEA,8C;IACwC,sB;MAAA,SAAc,GUsCJ,SVtCI,GUsCI,cAAR,I;KViD9C,oBAtF0B,MAsF1B,C;IACA,oBAvFuB,CAuFvB,C;;M8ByGc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,aAAM,O;U9B1GG,wB;UAAN,QAAiB,MU1DY,iBV0DZ,MU1D4B,aAAhB,I;UV0DzC,YT0HG,MAAO,aAAO,CAAP,C;USnNN,aA0FM,MA1FN,OA0FyB,KA1FzB,C;UA2FJ,4BAAa,KAAb,I;UACA,4BAAa,KAAb,I;U8BuGI,IAAI,E9BrGR,cAAY,C8BqGJ,CAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9B5MN,kBAgGK,W;IAwDP,IAAI,cAAO,CAAX,C;MACI,qBAAqB,WAArB,C;KAxJR,C;EAEA,yE;IACI,wBAAU,WAAV,EAAyC,oBAAlB,iBAAkB,CAAzC,EAA0D,oBAAP,MAAO,CAA1D,C;EACJ,C;EAEA,yE;IACI,IAAI,oCAAc,WAAd,EAA2B,iBAA3B,EAA8C,MAA9C,GAAyD,MAAzD,CAAJ,C;MACI,uBAAqB,MAArB,C;KAER,C;EAEA,0D;IAC+C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAsE1E,oBArE+C,MAqE/C,C;IACA,oBAtEuC,MAsEvC,C;;M8ByGc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,aAAM,O;U9B1GG,wB;UAAN,QAAiB,MU1DY,iBV0DZ,MU1D4B,aAAhB,I;UV0DzC,YT0HG,MAAO,aAAO,CAAP,C;USlMN,YAyEM,MAzEN,OAyEc,WAzEd,EAyEyB,KAzEzB,C;UA0EJ,4BAAa,KAAb,I;UACA,4BAAa,KAAb,I;U8BuGI,IAAI,E9BrGR,cAAY,C8BqGJ,CAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9B7LR,OAAO,SAiFA,WAjFA,I;EAGX,C;EAEA,0D;IACgD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IA+G3E,oBA9G0C,MA8G1C,C;IACA,oBA/GkC,MA+GlC,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IAlHiB,CAkHjB,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cS3LN,YAkHM,MAlHN,OAkHc,WAlHd,EAkHyB,KAlHzB,C;cAmHJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eAlH8C,C;;gBAkH9C,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9B5OR,OAAO,SA6HA,WA7HA,I;EAGX,C;EAEA,0D;IAC8C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAwGzE,oBAvG0C,MAuG1C,C;IACA,oBAxGkC,MAwGlC,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IA3GiB,CA2GjB,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cSpLN,YA2GM,MA3GN,OA2Gc,WA3Gd,EA2GyB,KA3GzB,C;cA4GJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eA3G8C,C;;gBA2G9C,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9BrOR,OAAO,SAsHA,WAtHA,I;EAGX,C;EAEA,0D;IAC+C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAiG1E,oBAhG0C,MAgG1C,C;IACA,oBAjGkC,MAiGlC,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IApGiB,CAoGjB,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cS7KN,YAoGM,MApGN,OAoGc,WApGd,EAoGyB,KApGzB,C;cAqGJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eApG8C,C;;gBAoG9C,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9B9NR,OAAO,SA+GA,WA/GA,I;EAGX,C;EAEA,0D;IACgD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IA0F3E,oBAzF0C,MAyF1C,C;IACA,oBA1FkC,MA0FlC,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IA7FiB,CA6FjB,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cStKN,aA6FM,MA7FN,OA6Fc,WA7Fd,EA6FyB,KA7FzB,C;cA8FJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eA7F8C,C;;gBA6F9C,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9BvNR,OAAO,SAwGA,WAxGA,I;EAGX,C;EAEA,0D;IACiD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAmF5E,oBAlF0C,MAkF1C,C;IACA,oBAnFkC,MAmFlC,C;;M8BuFc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,WAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,IAAd,C;;cAEe,aAAM,O;cAAN,gB;c9B9FD,wB;cAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,IAtFiB,CAsFjB,I;cAA7B,YT0EG,MAAO,aAAO,CAAP,C;cS/JN,aAsFM,MAtFN,OAsFc,WAtFd,EAsFyB,KAtFzB,C;cAuFJ,4BAAa,KAAb,I;cACA,4BAAa,KAAb,I;cAGI,kBAAY,CAAZ,C;gBANJ,eAtF8C,C;;gBAsF9C,eAOY,C;;c8BuFA,mB;;4BAEQ,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,I;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,IAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;YACI,K;WAGJ,UAAU,I;UACV,UAAU,I;;QACL,eAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9BhNR,OAAO,SAiGA,WAjGA,I;EAGX,C;EAEA,kD;IAA4C,sB;MAAA,SAAc,GUpBR,SVoBQ,GUpBA,cAAR,I;KViD9C,oBA5B0C,MA4B1C,C;IACA,oBA7BuC,CA6BvC,C;;M8ByGc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,aAAM,O;U9B1GG,wB;UAAN,QAAiB,MU1DY,iBV0DZ,MU1D4B,aAAhB,I;UV0DzC,YT0HG,MAAO,aAAO,CAAP,C;USzJN,aAgCM,MAhCN,OAgCyB,KAhCzB,C;UAiCJ,4BAAa,KAAb,I;UACA,4BAAa,KAAb,I;U8BuGI,IAAI,E9BrGR,cAAY,C8BqGJ,CAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9BpJR,OAAO,SAwCA,WAxCA,I;EAGX,C;EAEA,6E;IACI,OAAO,4BAAc,WAAd,EAA6C,oBAAlB,iBAAkB,CAA7C,EAA8D,oBAAP,MAAO,CAA9D,CAAwE,Q;EACnF,C;EAEA,6E;IAKW,Q;IAqCP,oBAzC0D,MAyC1D,C;IACA,oBA1CuC,iBA0CvC,C;;M8BkFc,kB;MADd,cAAc,I;MACA,yCAAqB,CAArB,C;MAAA,mB;QAA2B,qB;OAAzC,cAAc,M;;;UAID,aAAM,O;U9BnFG,wB;UAAN,QAAsC,oBAArB,MUjFY,iBViFZ,MUjF4B,aAAhB,IViFS,C;UAAlD,YAA4D,CT4GrD,uBAAK,CAAL,MAAJ,YAAmB,CS5GsC,S;UAC5D,UAAU,MAAO,O;UAAjB,gBAA6C,oBAApB,MAAO,aAAa,C;UAA7C,kBAAuD,W;UA7CvD,GAAI,6BAAoB,SAApB,EAAqC,oBA6CyB,KA7CzB,CAArC,EAA+C,WAA/C,C;UA8CJ,MAAO,sBAAa,KAAb,C;UACP,uDAAa,KAAb,E;UACA,kDAAa,KAAb,E;U8B+EI,IAAI,E9B7ER,yBAAY,C8B6EJ,CAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;I9B1IR,kBAsDO,W;IAnDP,aAAa,gBAAS,WAAT,C;IAET,0BAAgB,oBAAhB,C;;;MACQ,a;IAFZ,W;EAIJ,C;+BAEA,yB;ITgIA,iB;IuCzBA,wF;IAAA,sF;IAAA,gF;I9BvGA,iE;MAQI,oBAAgB,MAAhB,C;MACA,oBAAgB,gBAAhB,C;;Q8ByGc,gB;QADd,cAAc,I;QACA,uCAAqB,CAArB,C;QAAA,iB;UAA2B,qB;SAAzC,cAAc,I;;;YAID,aAAM,O;Y9B1GG,wB;YAAN,QAAiB,MU1DY,iBV0DZ,MU1D4B,aAAhB,I;YV0DzC,YT0HG,MAAO,aAAO,CAAP,C;YSzHV,UAAU,MAAV,EAAkB,WAAlB,EAA6B,KAA7B,C;YACA,4BAAa,KAAb,I;YACA,4BAAa,KAAb,I;Y8BuGI,IAAI,E9BrGR,cAAY,C8BqGJ,CAAJ,C;cACI,K;aAEJ,UAAU,K;YACC,wCAAoB,OAApB,C;YAAA,mB;cAAgC,K;aAA3C,WAAW,M;YACX,UAAU,I;YACV,UAAU,I;;UACL,a;;UAET,IAAI,OAAJ,C;YACI,4BAAiB,OAAjB,C;;;;M9B5GR,OAAO,W;IACX,C;GArBA,C;iCAuBA,yB;I8BgFA,wF;IAAA,sF;IAAA,gF;I9BhFA,iE;MAQI,oBAAgB,MAAhB,C;MACA,oBAAgB,gBAAhB,C;;Q8BkFc,gB;QADd,cAAc,I;QACA,uCAAqB,CAArB,C;QAAA,iB;UAA2B,qB;SAAzC,cAAc,I;;;YAID,aAAM,O;Y9BnFG,wB;YAAN,QAAsC,oBAArB,MUjFY,iBViFZ,MUjF4B,aAAhB,IViFS,C;YAAlD,YAA4D,CT4GrD,uBAAK,CAAL,MAAJ,YAAmB,CS5GsC,S;YAC5D,UAAU,MAAO,OAAjB,EAA6C,oBAApB,MAAO,aAAa,CAA7C,EAAuD,WAAvD,EAAkE,KAAlE,C;YACA,MAAO,sBAAa,KAAb,C;YACP,uDAAa,KAAb,E;YACA,kDAAa,KAAb,E;Y8B+EI,IAAI,E9B7ER,yBAAY,C8B6EJ,CAAJ,C;cACI,K;aAEJ,UAAU,K;YACC,wCAAoB,OAApB,C;YAAA,mB;cAAgC,K;aAA3C,WAAW,M;YACX,UAAU,I;YACV,UAAU,I;;UACL,a;;UAET,IAAI,OAAJ,C;YACI,4BAAiB,OAAjB,C;;;;M9BpFR,OAAO,W;IACX,C;GAtBA,C;0BAwBA,yB;ITiFA,iB;IuCKA,wF;IAAA,sF;IAAA,gF;I9BtFA,sE;MASI,oBAAgB,MAAhB,C;MACA,oBAAgB,MAAhB,C;;Q8BuFc,gB;QADd,cAAc,I;QACA,uCAFuC,CAEvC,C;QAAA,iB;UAAqC,yB;SAAnD,cAAc,I;QACd,WAHqD,C;;;wBAOhC,O;YAAb,apBnMqC,sBAAgB,kBAAhB,I;YoBoMrC,S;YAEA,IAAI,UAAU,IAAd,C;;gBAEe,aAAM,O;gBAAN,gB;gB9B9FD,wB;gBAAN,QAAiB,CAAA,MU1GY,iBV0GZ,MU1G4B,aAAhB,IV0GZ,qB;gBAA7B,YT0EG,MAAO,aAAO,CAAP,C;gBSzEV,UAAU,MAAV,EAAkB,WAAlB,EAA6B,KAA7B,C;gBACA,4BAAa,KAAb,I;gBACA,4BAAa,KAAb,I;gBAGI,kBAAY,CAAZ,C;kBANJ,4B;;kBAAA,eAOY,C;;gB8BuFA,mB;;8BAEQ,O;gBAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;coB6MjC,QAAQ,M;;YAGZ,UAAU,K;YAGN,cAAS,CAAT,C;cAAc,wCAAoB,OAApB,C;;cACd,qBAAQ,I;cAAR,Y;8BAAgB,O;gBAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;eAAjC,W;gBACI,4BAAiB,OAAjB,C;gBACA,yCAAqB,IAArB,C;;gBAEI,gB;;YANZ,iB;YASA,IAAI,YAAJ,C;cACI,K;aAGJ,UAAU,I;YACV,UAAU,I;;UACL,eAAO,CAAP,C;;UAET,IAAI,OAAJ,C;YACI,4BAAiB,OAAjB,C;;;;M9B/GR,OAAO,W;IACX,C;GAzBA,C;EA2BA,uC;IAEI,IAAI,YAAO,CAAX,C;MACI,qBAAqB,SAArB,C;KAER,C;E2CvMA,2C;IAsRiB,Q;IACT,WAtRkB,SAsRlB,sC;MAAwB,OAtRO,sB;;MAuRhB,OAvRiC,mBAAjB,sBAAiB,C;;IAApD,W;G;EAEJ,yC;IAmRiB,Q;IACT,WAnRkB,SAmRlB,sC;MAAwB,OAnRO,oB;;MAoRhB,OApR+B,mBAAf,oBAAe,C;;IAAlD,W;G;EAEJ,0C;IAgRiB,Q;IACT,WAhRkB,SAgRlB,sC;MAAwB,OAhRO,qB;;MAiRhB,OAjRgC,mBAAhB,qBAAgB,C;;IAAnD,W;G;EAEJ,2C;IA6QiB,Q;IACT,WA7QkB,SA6QlB,sC;MAAwB,OA7QO,sB;;MA8QhB,OA9QiC,mBAAjB,sBAAiB,C;;IAApD,W;G;EAEJ,4C;IA0QiB,Q;IACT,WA1QkB,SA0QlB,sC;MAAwB,OA1QO,uB;;MA2QhB,OA3QkC,mBAAlB,uBAAkB,C;;IAArD,W;G;EAEJ,4C;IAAkD,OAAyC,mBAAjB,sBAAiB,C;G;EAE3F,0C;IAA8C,OAAuC,mBAAf,oBAAe,C;G;EAErF,2C;IAAgD,OAAwC,mBAAhB,qBAAgB,C;G;EAExF,4C;IAAkD,OAAyC,mBAAjB,sBAAiB,C;G;EAE3F,6C;IAAoD,OAA0C,mBAAlB,uBAAkB,C;G;EAE9F,4C;IAAmD,OAAyC,mBAAjB,sBAAiB,C;G;EAE5F,0C;IAA+C,OAAuC,mBAAf,oBAAe,C;G;EAEtF,2C;IAAiD,OAAwC,mBAAhB,qBAAgB,C;G;EAEzF,4C;IAAmD,OAAyC,mBAAjB,sBAAiB,C;G;EAE5F,6C;IAAqD,OAA0C,mBAAlB,uBAAkB,C;G;EAE/F,+D;IAAyD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACpF,mCAAsB,GlB+nGf,QkB/nGP,EAA0C,MAA1C,EAAkD,MAAlD,C;EACJ,C;EAEA,iE;IAAwD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACnF,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,iE;IAAuD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IAClF,mCAAsB,GlBikGf,QkBjkGP,EAAwC,MAAxC,EAAgD,MAAhD,C;EACJ,C;EAEA,iE;IAAsD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACjF,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,iE;IAAwD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACnF,mCAAsB,GlB4lGf,QkB5lGP,EAAyC,MAAzC,EAAiD,MAAjD,C;EACJ,C;EAEA,iE;IAAuD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAClF,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,iE;IAAwD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACnF,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,iE;IAAyD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACpF,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,mE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACxF,OAAO,uCAA0B,GlB2kG1B,QkB3kGA,EAA8C,MAA9C,EAAsD,MAAtD,C;EACX,C;EAEA,qE;IAA4D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACvF,aAAa,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,IAAI,SAAS,CAAb,C;MACI,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;MAChB,iBAAc,MAAd,WAAsB,SAAtB,U;QACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;KAGhC,OAAO,M;EACX,C;EAEA,qE;IAA2D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACtF,OAAO,uCAA0B,GlB0gG1B,QkB1gGA,EAA4C,MAA5C,EAAoD,MAApD,C;EACX,C;EAEA,qE;IAA0D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACrF,aAAa,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,IAAI,SAAS,CAAb,C;MACI,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;MAChB,iBAAc,MAAd,WAAsB,SAAtB,U;QACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;KAGhC,OAAO,M;EACX,C;EAEA,qE;IAA4D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACvF,OAAO,uCAA0B,GlBkiG1B,QkBliGA,EAA6C,MAA7C,EAAqD,MAArD,C;EACX,C;EAEA,qE;IAA2D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACtF,aAAa,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,IAAI,SAAS,CAAb,C;MACI,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;MAChB,iBAAc,MAAd,WAAsB,SAAtB,U;QACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;KAGhC,OAAO,M;EACX,C;EAEA,qE;IAA4D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACvF,aAAa,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,IAAI,SAAS,CAAb,C;MACI,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;MAChB,iBAAc,MAAd,WAAsB,SAAtB,U;QACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;KAGhC,OAAO,M;EACX,C;EAEA,qE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACxF,aAAa,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,IAAI,SAAS,CAAb,C;MACI,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;MAChB,iBAAc,MAAd,WAAsB,SAAtB,U;QACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;KAGhC,OAAO,M;EACX,C;EAEA,iE;IAA0D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACrF,mCAAsB,GlBwgGf,QkBxgGP,EAA0C,MAA1C,EAAkD,MAAlD,C;EACJ,C;EAEA,iE;IAAyD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACpF,uBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,iE;IAAwD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACnF,oCAAsB,GlB08Ff,QkB18FP,EAAwC,MAAxC,EAAgD,MAAhD,C;EACJ,C;EAEA,kE;IAAuD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAClF,uBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,kE;IAAyD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACpF,oCAAsB,GlBq+Ff,QkBr+FP,EAAyC,MAAzC,EAAiD,MAAjD,C;EACJ,C;EAEA,kE;IAAwD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACnF,uBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,kE;IAAyD,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACpF,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,kE;IAA0D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACrF,wBAAU,GAAV,EAAe,MAAf,EAAuB,MAAvB,C;IACA,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;EAEhC,C;EAEA,qE;IAA8D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACzF,OAAO,uCAA0B,GlBo9F1B,QkBp9FA,EAA8C,MAA9C,EAAsD,MAAtD,C;EACX,C;EAEA,qE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACxF,aAAa,2BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;IAE5B,OAAO,M;EACX,C;EAEA,qE;IAA4D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACvF,OAAO,wCAA0B,GlBq5F1B,QkBr5FA,EAA4C,MAA5C,EAAoD,MAApD,C;EACX,C;EAEA,sE;IAA2D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACtF,aAAa,2BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;IAChB,iBAAc,MAAd,WAAsB,SAAtB,U;MACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;IAE5B,OAAO,M;EACX,C;EAEA,sE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;IACxF,OAAO,wCAA0B,GlB+6F1B,QkB/6FA,EAA6C,MAA7C,EAAqD,MAArD,C;EACX,C;EAEA,sE;IAA4D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACvF,aAAa,2BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,IAAI,SAAS,CAAb,C;MACI,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;MAChB,iBAAc,MAAd,WAAsB,SAAtB,U;QACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;KAGhC,OAAO,M;EACX,C;EAEA,sE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACxF,aAAa,2BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,IAAI,SAAS,CAAb,C;MACI,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;MAChB,iBAAc,MAAd,WAAsB,SAAtB,U;QACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;KAGhC,OAAO,M;EACX,C;EAEA,sE;IAA8D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IACzF,aAAa,4BAAc,GAAd,EAAmB,MAAnB,EAA2B,MAA3B,C;IACb,IAAI,SAAS,CAAb,C;MACI,gBAAgB,SAAS,MAAT,GAAkB,CAAlB,I;MAChB,iBAAc,MAAd,WAAsB,SAAtB,U;QACI,IAAI,KAAJ,IAAwB,mBAAX,IAAI,KAAJ,CAAW,C;;KAGhC,OAAO,M;EACX,C;EAEA,8C;IACI,OAAc,QAAP,MAAO,C;EAClB,C;EAEA,2D;IAKiB,IAAN,I;IACH,WADS,SACT,sC;MAAwB,a;;MACT,eAAP,MAAO,C;IAFnB,W;EAIJ,C;EC5RA,4D;IAoB+C,sB;MAAA,SAAc,C;IAAG,mB;MAAA,MAAW,C;IAAG,mB;MAAA,MAAW,U;IACvE,Q;IAAd,OAAO,oBAAO,6DAAP,EAA8B,MAA9B,EAAsC,GAAtC,EAA2C,GAA3C,C;EACX,C;EAEA,4D;IAoB6C,sB;MAAA,SAAc,C;IAAG,mB;MAAA,MAAW,C;IAAG,mB;MAAA,MAAW,U;IACnF,YAAY,WAAZ,EAAyB,MAAzB,EAAiC,GAAjC,EAAsC,GAAtC,C;IAEA,aAAa,yBACT,WAAY,OADH,EAEiB,oBAA1B,WAAY,cAAc,CAFjB,EAGF,oBAAP,MAAO,CAHE,EAIL,oBAAJ,GAAI,CAJK,EAKoC,oBAAzC,eAAJ,GAAI,EAAa,WlC6ByB,SkC7BzB,WlC6BiC,cAAR,IkC7BtC,CAAyC,CALpC,CAMX,Q;IAEF,WAAY,uBAAc,MAAd,C;IACZ,OAAO,M;EACX,C;ECxDA,gC;IAEW,wB;;MA4CH,kD;MAAA,S;QAAyB,QjB4CV,6BAAmB,sBAAnB,IiB5CU,IA5CR,C;OA4CrB,S;QACI,YAAY,sB;QACZ,yBAAe,QA9CE,CA8CF,I;QACf,uBAAY,oB9ChD8C,KAAK,U8CgDvC,K9ChDuC,EAAiB,KAAjB,C;Q8CgD/D,yB;OAGJ,uBAlD0E,4B;;;IAA1E,2B;EACJ,C;EAEA,sC;IAmDe,Q;IAAX,WAAW,wCAlDkB,CAkDlB,oBAA8B,qBAlDZ,CAkDY,C;IACzC,YAnDqC,YAmDpB,IAnDoB,C;IAoDrC,8BAAiB,IAAjB,C;IApDA,OAqDO,K;EApDX,C;EAEA,8B;IAEW,wB;;MAmCH,kD;MAAA,S;QAAyB,QjB4CV,6BAAmB,sBAAnB,IiB5CU,IAnCR,C;OAmCrB,S;QACI,YAAY,sB;QACZ,yBAAe,QArCE,CAqCF,I;QACf,uBAAY,oB9C5C0C,KAAK,U8C4CnC,K9C5CmC,EAAiB,KAAjB,C;Q8C4C3D,yB;OAGJ,uBAzCwE,0B;;;IAAxE,2B;EACJ,C;EAEA,oC;IA0Ce,Q;IAAX,WAAW,wCAzCkB,CAyClB,oBAA8B,qBAzCZ,CAyCY,C;IACzC,YA1CqC,UA0CpB,IA1CoB,C;IA2CrC,8BAAiB,IAAjB,C;IA3CA,OA4CO,K;EA3CX,C;EAEA,+B;IAEW,wB;;MA0BH,kD;MAAA,S;QAAyB,QjB4CV,6BAAmB,sBAAnB,IiB5CU,IA1BR,C;OA0BrB,S;QACI,YAAY,sB;QACZ,yBAAe,QA5BE,CA4BF,I;QACR,aAAK,oB;QAAZ,uB9CvC2B,oB8CUY,M9CV1C,KAAK,W8CuCsB,K9CvCtB,EAAkB,KAAlB,CAAyB,CAA9B,WAA2C,EAA3C,CAAD,IACsC,oB8CSK,M9CTvC,KAAK,W8CsCmB,K9CtCT,GAAS,CAAT,IAAV,EAAsB,KAAtB,CAA6B,CADtC,C;Q8CuCI,yB;OAGJ,uBAhCyE,2B;;;IAAzE,2B;EACJ,C;EAEA,qC;IAiCe,Q;IAAX,WAAW,wCAhCkB,CAgClB,oBAA8B,qBAhCZ,CAgCY,C;IACzC,YAjCqC,WAiCpB,IAjCoB,C;IAkCrC,8BAAiB,IAAjB,C;IAlCA,OAmCO,K;EAlCX,C;EAEA,gC;IAEW,wB;;MAiBH,kD;MAAA,S;QAAyB,QjB4CV,6BAAmB,sBAAnB,IiB5CU,IAjBR,C;OAiBrB,S;QACI,YAAY,sB;QACZ,yBAAe,QAnBE,CAmBF,I;QACf,uBAAY,oB9ClC8C,KAAK,Y8CkCvC,K9ClCuC,EAAmB,KAAnB,C;Q8CkC/D,yB;OAGJ,uBAvB0E,4B;;;IAA1E,2B;EACJ,C;EAEA,sC;IAwBe,Q;IAAX,WAAW,wCAvBkB,CAuBlB,oBAA8B,qBAvBZ,CAuBY,C;IACzC,YAxBqC,YAwBpB,IAxBoB,C;IAyBrC,8BAAiB,IAAjB,C;IAzBA,OA0BO,K;EAzBX,C;EAEA,iC;IAEW,wB;;MAQH,kD;MAAA,S;QAAyB,QjB4CV,6BAAmB,sBAAnB,IiB5CU,IARR,C;OAQrB,S;QACI,YAAY,sB;QACZ,yBAAe,QAVE,CAUF,I;QACf,uBAAY,oB9C9BgD,KAAK,Y8C8BzC,K9C9ByC,EAAmB,KAAnB,C;Q8C8BjE,yB;OAGJ,uBAd2E,6B;;;IAA3E,2B;EACJ,C;EAEA,uC;IAee,Q;IAAX,WAAW,wCAdkB,CAclB,oBAA8B,qBAdZ,CAcY,C;IACzC,YAfqC,aAepB,IAfoB,C;IAgBrC,8BAAiB,IAAjB,C;IAhBA,OAiBO,K;EAhBX,C;EAEA,wD;IACQ,kD;IAAA,S;MAAyB,QjB4CV,6BAAmB,sBAAnB,IiB5CU,IAAgB,I;KAA7C,S;MACI,YAAY,sB;MACZ,yBAAe,QAAQ,IAAR,I;MACf,OAAO,KAAK,oBAAL,EAAiB,KAAjB,C;KAGX,OAAO,U;EACX,C;EAEA,sD;IACe,Q;IAAX,WAAW,wCAAqB,IAArB,oBAA8B,qBAAqB,IAArB,C;IACzC,YAAY,KAAK,IAAL,C;IACZ,8BAAiB,IAAjB,C;IACA,OAAO,K;EACX,C;ElBuCA,8C;IAC4C,qB;MAAA,QAAa,C;IAAG,mB;MAAA,MAAW,GAAI,O;IACvE,OAAO,yBAAO,GAAP,EAAY,KAAZ,EAAmB,GAAnB,C;EACX,C;EAEA,8C;IACyC,qB;MAAA,QAAa,C;IAAG,mB;MAAA,MAAW,GAAI,O;IACpE,OAAO,yBAAO,GAAP,EAAY,KAAZ,EAAmB,GAAnB,C;EACX,C;EAEA,uD;IAC6C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IA8IxE,wBA7IwB,MA6IxB,C;IACA,oBA9IgC,MA8IhC,C;IApDA,WAAwB,8BAAiB,CAAjB,EAAoB,IAApB,C;;MAEpB,Y;QACS,aAAM,I;QAoDE,sB;QAAN,QAAiB,MjBhLc,SiBgLd,MjBhLsB,cAAR,I;QiBgL1C,WpCDG,MAAO,WAAO,CAAP,C;QoC/IH,aAiJD,MAjJC,OAiJO,eAjJP,EAiJsB,IAjJtB,C;QAkJP,oCAAiB,IAAjB,I;QACA,4BAAa,IAAb,I;cACA,cAAY,C;;QAvDR,OAAO,8BAAiB,CAAjB,EAAoB,IAApB,C;;;MAGX,4BAAe,IAAf,C;;EA9FR,C;EAEA,uD;IAC8C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IA2KzE,wBA1KsB,MA0KtB,C;IACA,oBA3K8B,MA2K9B,C;IArEA,WAAW,8BAtGQ,CAsGR,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAmEA,sB;QAAN,QAAiB,MjBpNc,SiBoNd,MjBpNsB,cAAR,I;QiBoN1C,apCrCG,MAAO,WAAO,CAAP,C;QoCxIH,aA8KD,MA9KC,OA8KO,eA9KP,EA8KsB,MA9KtB,C;QA+KP,oCAAiB,MAAjB,I;QACA,4BAAa,MAAb,I;QAtEI,OAuEJ,yBAlLe,CAkLf,C;QAtEI,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EA7GR,C;EAEA,uD;IAC4C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAoKvE,wBAnKsB,MAmKtB,C;IACA,oBApK8B,MAoK9B,C;IArEA,WAAW,8BA/FQ,CA+FR,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAmEA,sB;QAAN,QAAiB,MjBpNc,SiBoNd,MjBpNsB,cAAR,I;QiBoN1C,apCrCG,MAAO,WAAO,CAAP,C;QoCjIH,aAuKD,MAvKC,OAuKO,eAvKP,EAuKsB,MAvKtB,C;QAwKP,oCAAiB,MAAjB,I;QACA,4BAAa,MAAb,I;QAtEI,OAuEJ,yBA3Ke,CA2Kf,C;QAtEI,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EAtGR,C;EAEA,uD;IAC6C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IA6JxE,wBA5JsB,MA4JtB,C;IACA,oBA7J8B,MA6J9B,C;IArEA,WAAW,8BAxFQ,CAwFR,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAmEA,sB;QAAN,QAAiB,MjBpNc,SiBoNd,MjBpNsB,cAAR,I;QiBoN1C,apCrCG,MAAO,WAAO,CAAP,C;QoC1HH,aAgKD,MAhKC,OAgKO,eAhKP,EAgKsB,MAhKtB,C;QAiKP,oCAAiB,MAAjB,I;QACA,4BAAa,MAAb,I;QAtEI,OAuEJ,yBApKe,CAoKf,C;QAtEI,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EA/FR,C;EAEA,uD;IAC8C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IAsJzE,wBArJsB,MAqJtB,C;IACA,oBAtJ8B,MAsJ9B,C;IArEA,WAAW,8BAjFQ,CAiFR,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAmEA,sB;QAAN,QAAiB,MjBpNc,SiBoNd,MjBpNsB,cAAR,I;QiBoN1C,apCrCG,MAAO,WAAO,CAAP,C;QoCnHH,aAyJD,MAzJC,OAyJO,eAzJP,EAyJsB,MAzJtB,C;QA0JP,oCAAiB,MAAjB,I;QACA,4BAAa,MAAb,I;QAtEI,OAuEJ,yBA7Je,CA6Jf,C;QAtEI,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EAxFR,C;EAEA,uD;IAC+C,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,OAAJ,GAAW,MAAX,I;IA+I1E,wBA9IsB,MA8ItB,C;IACA,oBA/I8B,MA+I9B,C;IArEA,WAAW,8BA1EQ,CA0ER,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAmEA,sB;QAAN,QAAiB,MjBpNc,SiBoNd,MjBpNsB,cAAR,I;QiBoN1C,apCrCG,MAAO,WAAO,CAAP,C;QoC5GH,cAkJD,MAlJC,OAkJO,eAlJP,EAkJsB,MAlJtB,C;QAmJP,oCAAiB,MAAjB,I;QACA,4BAAa,MAAb,I;QAtEI,OAuEJ,yBAtJe,CAsJf,C;QAtEI,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EAjFR,C;EAEA,+C;IAE4C,sB;MAAA,SAAc,GjB9ET,iBiB8ES,GjB9EO,aAAhB,I;KiB+ElC,Q;IAAX,yBAAW,qDAAX,EAA0B,MAA1B,C;EACJ,C;EAEA,+C;IAA0C,sB;MAAA,SAAc,GjBlFP,iBiBkFO,GjBlFS,aAAhB,I;KiBiL7C,wBA9FwB,CA8FxB,C;IACA,oBA/F2B,MA+F3B,C;IApDA,WAAwB,8BAAiB,CAAjB,EAAoB,IAApB,C;;MAEpB,Y;QACS,aAAM,I;QAoDE,sB;QAAN,QAAiB,MjBhLc,SiBgLd,MjBhLsB,cAAR,I;QiBgL1C,WpCDG,MAAO,WAAO,CAAP,C;QoChGH,cAkGD,MAlGC,OAkGsB,IAlGtB,C;QAmGP,oCAAiB,IAAjB,I;QACA,4BAAa,IAAb,I;cACA,cAAY,C;;QAvDR,OAAO,8BAAiB,CAAjB,EAAoB,IAApB,C;;;MAGX,4BAAe,IAAf,C;;EA/CR,C;EAEA,uD;IACI,yBAAW,GAAX,EAAuB,oBAAP,MAAO,CAAvB,EAAwC,oBAAP,MAAO,CAAxC,C;EACJ,C;EAEA,uD;IAsGI,wBArGwB,MAqGxB,C;IACA,oBAtGgC,MAsGhC,C;IArEA,WAAwB,8BAAiB,CAAjB,EAAoB,IAApB,C;;MAEpB,Y;QACS,aAAM,I;QAqEE,sB;QAAN,QAAuC,oBAAtB,MjBjMc,SiBiMd,MjBjMsB,cAAR,IiBiMQ,C;QAAlD,WpCTO,qBAAK,CAAL,MAAJ,UAAmB,C;QoC/FlB,mBAyGE,MAAO,OAzGT,EAyGgD,eAzGhD,EAyG+D,IAzG/D,EAyGsC,oBAArB,MAAO,cAAc,CAzGtC,C;QA0GJ,MAAO,uBAAc,IAAK,QAAnB,C;QACP,sCAAiB,IAAjB,C;QACA,mCAAa,IAAb,C;cACA,yBAAY,C;;QAzER,OAAO,8BAAiB,CAAjB,EAAoB,IAApB,C;;;MAGX,4BAAe,IAAf,C;;EArCR,C;EAEA,yC;IACoC,qB;MAAA,QAAc,C;IAC9C,IAAI,wCAAJ,C;MACI,qB;MAyBJ,WAAwB,8BAAiB,CAAjB,EAAoB,IAApB,C;;QAEpB,Y;UACS,aAAM,I;UA1BK,QAA4B,oBAAtB,MjBlGgB,SiBkGhB,MjBlGwB,cAAR,IiBkGM,C;UAA5B,QAAsC,eAAQ,SAAR,C;UAAtD,gBAAuE,CpCsFpE,kBAAK,CAAL,MAAJ,GAAY,CAAZ,GAAmB,CoCtFqD,S;UAChE,KAAP,MAAO,EAAK,SAAL,Q;UACP,8CAAW,SAAX,E;gBACA,oC;;UAwBA,OAAO,8BAAiB,CAAjB,EAAoB,IAApB,C;;;QAGX,4BAAe,IAAf,C;;;MAxBA,wBAAa,KAAb,EAAoB,KAApB,C;;EAER,C;EAEA,+C;IACoB,Q;IAAA,gBAAQ,KAAR,Y;IAAhB,OAAgB,cAAhB,C;MAAgB,yB;MACZ,4BAAU,KAAV,C;;EAER,C;2GAEA,yB;IAAA,gF;IAAA,4E;IAAA,mC;MAOI,WAAwB,4BAAiB,CAAjB,EAAoB,IAApB,C;;QAEpB,OACS,MAAM,IAAN,CADT,C;UAEI,OAAO,4BAAiB,CAAjB,EAAoB,IAApB,C;;;QAGX,0BAAe,IAAf,C;;IAER,C;GAhBA,C;mHAkBA,yB;IAAA,gF;IAAA,4E;IAAA,gD;MAOwC,2B;QAAA,cAAmB,C;MACvD,WAAW,4BAAiB,WAAjB,EAA8B,IAA9B,C;;QAGP,Q;QACA,OAAO,IAAP,C;UACI,OAAO,MAAM,IAAN,C;UACP,IAAI,QAAQ,CAAZ,C;YAAe,K;UACf,OAAO,4BAAiB,IAAjB,EAAuB,IAAvB,C;;;QAGX,0BAAe,IAAf,C;;IAER,C;GApBA,C;EAsBA,0C;IAEI,IAAI,+CAAJ,C;MACI,8BAAY,MAAZ,C;MACA,M;;MGHU,gB;MADd,cAAc,I;MACA,4BHMd,MGNc,EAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UHOV,yBGHe,OHGf,C;UGHI,IAAI,CHIR,IGJI,C;YACI,K;WAEJ,UAAU,K;UACC,6BHFnB,MGEmB,EAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,mBHRR,MGQQ,EAAiB,OAAjB,C;;;;EHJZ,C;gCAEA,yB;IpCEA,iB;IoCvDA,gF;IAAA,4E;IAqDA,mD;MAKI,wBAAoB,MAApB,C;MACA,oBAAgB,MAAhB,C;MApDA,WAAwB,4BAAiB,CAAjB,EAAoB,IAApB,C;;QAEpB,Y;UACS,aAAM,I;UAoDE,sB;UAAN,QAAiB,MjBhLc,SiBgLd,MjBhLsB,cAAR,I;UiBgL1C,WpCDG,MAAO,WAAO,CAAP,C;UoCEV,MAAM,MAAN,EAAc,eAAd,EAA6B,IAA7B,C;UACA,oCAAiB,IAAjB,I;UACA,4BAAa,IAAb,I;gBACA,cAAY,C;;UAvDR,OAAO,4BAAiB,CAAjB,EAAoB,IAApB,C;;;QAGX,0BAAe,IAAf,C;;IAsDR,C;GAfA,C;kCAiBA,yB;IAtEA,gF;IAAA,4E;IAsEA,0D;MAKI,wBAAoB,aAApB,C;MACA,oBAAgB,MAAhB,C;MArEA,WAAwB,4BAAiB,CAAjB,EAAoB,IAApB,C;;QAEpB,Y;UACS,aAAM,I;UAqEE,sB;UAAN,QAAuC,oBAAtB,MjBjMc,SiBiMd,MjBjMsB,cAAR,IiBiMQ,C;UAAlD,WpCTO,qBAAK,CAAL,MAAJ,UAAmB,C;UoCUtB,MAAM,MAAO,OAAb,EAA0C,oBAArB,MAAO,cAAc,CAA1C,EAAoD,eAApD,EAAmE,IAAnE,C;UACA,MAAO,uBAAc,IAAK,QAAnB,C;UACP,sCAAiB,IAAjB,C;UACA,mCAAa,IAAb,C;gBACA,yBAAY,C;;UAzER,OAAO,4BAAiB,CAAjB,EAAoB,IAApB,C;;;QAGX,0BAAe,IAAf,C;;IAwER,C;GAhBA,C;2BAkBA,yB;IpCjCA,iB;IoCrCA,gF;IAAA,4E;IAsEA,kE;MAMI,wBAAoB,MAApB,C;MACA,oBAAgB,MAAhB,C;MArEA,WAAW,4BAuEI,aAvEJ,EAA8B,IAA9B,C;;QAGP,Q;QACA,OAAO,IAAP,C;UACW,aAAM,I;UAmEA,sB;UAAN,QAAiB,MjBpNc,SiBoNd,MjBpNsB,cAAR,I;UiBoN1C,apCrCG,MAAO,WAAO,CAAP,C;UoCsCV,MAAM,MAAN,EAAc,eAAd,EAA6B,MAA7B,C;UACA,oCAAiB,MAAjB,I;UACA,4BAAa,MAAb,I;UAtEI,OAuEJ,uC;UAtEI,IAAI,QAAQ,CAAZ,C;YAAe,K;UACf,OAAO,4BAAiB,IAAjB,EAAuB,IAAvB,C;;;QAGX,0BAAe,IAAf,C;;IAoER,C;GAhBA,C;EmBzRA,mD;IAyLc,Q;IACF,WAzLsB,SAyLtB,sC;MAAwB,OAzLT,K;;MA0LD,OA1LyC,mBAAxC,KAAwC,C;;IAApB,6B;EAC/C,C;EAEA,iD;IAqLc,Q;IACF,WArLsB,SAqLtB,sC;MAAwB,OArLT,K;;MAsLD,OAtLuC,mBAAtC,KAAsC,C;;IAAlB,2B;EAC/C,C;EAEA,kD;IAiLc,Q;IACF,WAjLsB,SAiLtB,sC;MAAwB,OAjLT,K;;MAkLD,OAlLwC,mBAAvC,KAAuC,C;;IAAnB,4B;EAC/C,C;EAEA,mD;IA6Kc,Q;IACF,WA7KsB,SA6KtB,sC;MAAwB,OA7KT,K;;MA8KD,OA9KyC,mBAAxC,KAAwC,C;;IAApB,6B;EAC/C,C;EAEA,oD;IAyKc,Q;IACF,WAzKsB,SAyKtB,sC;MAAwB,OAzKT,K;;MA0KD,OA1K0C,mBAAzC,KAAyC,C;;IAArB,8B;EAC/C,C;EAEA,oD;IACoC,wBAAoB,mBAA7B,KAA6B,CAApB,C;EACpC,C;EAEA,kD;IACoC,sBAAkB,mBAA3B,KAA2B,CAAlB,C;EACpC,C;EAEA,mD;IACoC,uBAAmB,mBAA5B,KAA4B,CAAnB,C;EACpC,C;EAEA,oD;IACoC,wBAAoB,mBAA7B,KAA6B,CAApB,C;EACpC,C;EAEA,qD;IACoC,yBAAqB,mBAA9B,KAA8B,CAArB,C;EACpC,C;EAEA,mE;IAA8D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,KAAP,GAAc,MAAd,I;IACzF,oCAAuB,MrB0nGhB,QqB1nGP,EAA8C,MAA9C,EAAsD,MAAtD,C;EACJ,C;EAEA,oD;IACoC,wBAAoB,mBAA7B,KAA6B,CAApB,C;EACpC,C;EAEA,kD;IACoC,sBAAkB,mBAA3B,KAA2B,CAAlB,C;EACpC,C;EAEA,mD;IACoC,uBAAmB,mBAA5B,KAA4B,CAAnB,C;EACpC,C;EAEA,oD;IACoC,wBAAoB,mBAA7B,KAA6B,CAApB,C;EACpC,C;EAEA,qD;IACoC,yBAAqB,mBAA9B,KAA8B,CAArB,C;EACpC,C;EAEA,qE;IAA8D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,KAAP,GAAc,MAAd,I;IACzF,oCAAuB,MrBkmGhB,QqBlmGP,EAA8C,MAA9C,EAAsD,MAAtD,C;EACJ,C;EAEA,qE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IAkIxF,iBAhII,MAgIa,GA/Hb,MA+Ha,I;IACjB,gBAjII,MAiIJ,C;InBoBA,WAAW,8BmBnJP,CnBmJO,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAAN,gB;QmBvBA,QAAM,CAAA,MpC1HyB,SoC0HzB,MpC1HiC,cAAR,IoC0HzB,IAjIjB,CAiIiB,I;QAAN,QAA6C,aAAa,OAAb,I;QAAxD,avDqDG,MAAO,KAAI,CAAJ,EAAO,CAAP,C;QuDpDV,gBAAgB,UAAQ,MAAR,GAAe,CAAf,I;QAChB,iBAAc,OAAd,WAAqB,SAArB,U;UAlIE,aAmIiB,MAnIjB,EAAsB,mBAAX,OAmIc,KAnId,CAAW,CAAtB,C;;QAqIF,oBAAS,MAAT,I;QAEI,yB;UAPJ,eAjIA,C;;UAiIA,eAQY,C;;QnBeR,mB;QACA,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EmB1JR,C;EAEA,qE;IAA4D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,KAAP,GAAc,MAAd,I;IACvF,oCAAuB,MrBmiGhB,QqBniGP,EAA4C,MAA5C,EAAoD,MAApD,C;EACJ,C;EAEA,qE;IAA2D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IAqHtF,iBAnHI,MAmHa,GAlHb,MAkHa,I;IACjB,gBApHI,MAoHJ,C;InBoBA,WAAW,8BmBtIP,CnBsIO,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAAN,gB;QmBvBA,QAAM,CAAA,MpC1HyB,SoC0HzB,MpC1HiC,cAAR,IoC0HzB,IApHjB,CAoHiB,I;QAAN,QAA6C,aAAa,OAAb,I;QAAxD,avDqDG,MAAO,KAAI,CAAJ,EAAO,CAAP,C;QuDpDV,gBAAgB,UAAQ,MAAR,GAAe,CAAf,I;QAChB,iBAAc,OAAd,WAAqB,SAArB,U;UArHE,WAsHiB,MAtHjB,EAAoB,mBAAX,OAsHgB,KAtHhB,CAAW,CAApB,C;;QAwHF,oBAAS,MAAT,I;QAEI,yB;UAPJ,eApHA,C;;UAoHA,eAQY,C;;QnBeR,mB;QACA,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EmB7IR,C;EAEA,qE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,KAAP,GAAc,MAAd,I;IACxF,oCAAuB,MrB6jGhB,QqB7jGP,EAA6C,MAA7C,EAAqD,MAArD,C;EACJ,C;EAEA,qE;IAA4D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IAwGvF,iBAtGI,MAsGa,GArGb,MAqGa,I;IACjB,gBAvGI,MAuGJ,C;InBoBA,WAAW,8BmBzHP,CnByHO,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAAN,gB;QmBvBA,QAAM,CAAA,MpC1HyB,SoC0HzB,MpC1HiC,cAAR,IoC0HzB,IAvGjB,CAuGiB,I;QAAN,QAA6C,aAAa,OAAb,I;QAAxD,avDqDG,MAAO,KAAI,CAAJ,EAAO,CAAP,C;QuDpDV,gBAAgB,UAAQ,MAAR,GAAe,CAAf,I;QAChB,iBAAc,OAAd,WAAqB,SAArB,U;UAxGE,YAyGiB,MAzGjB,EAAqB,mBAAX,OAyGe,KAzGf,CAAW,CAArB,C;;QA2GF,oBAAS,MAAT,I;QAEI,yB;UAPJ,eAvGA,C;;UAuGA,eAQY,C;;QnBeR,mB;QACA,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EmBhIR,C;EAEA,qE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IA+FxF,iBA7FI,MA6Fa,GA5Fb,MA4Fa,I;IACjB,gBA9FI,MA8FJ,C;InBoBA,WAAW,8BmBhHP,CnBgHO,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAAN,gB;QmBvBA,QAAM,CAAA,MpC1HyB,SoC0HzB,MpC1HiC,cAAR,IoC0HzB,IA9FjB,CA8FiB,I;QAAN,QAA6C,aAAa,OAAb,I;QAAxD,avDqDG,MAAO,KAAI,CAAJ,EAAO,CAAP,C;QuDpDV,gBAAgB,UAAQ,MAAR,GAAe,CAAf,I;QAChB,iBAAc,OAAd,WAAqB,SAArB,U;UA/FE,aAgGiB,MAhGjB,EAAsB,mBAAX,OAgGc,KAhGd,CAAW,CAAtB,C;;QAkGF,oBAAS,MAAT,I;QAEI,yB;UAPJ,eA9FA,C;;UA8FA,eAQY,C;;QnBeR,mB;QACA,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EmBvHR,C;EAEA,qE;IAA8D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IAsFzF,iBApFI,MAoFa,GAnFb,MAmFa,I;IACjB,gBArFI,MAqFJ,C;InBoBA,WAAW,8BmBvGP,CnBuGO,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAAN,gB;QmBvBA,QAAM,CAAA,MpC1HyB,SoC0HzB,MpC1HiC,cAAR,IoC0HzB,IArFjB,CAqFiB,I;QAAN,QAA6C,aAAa,OAAb,I;QAAxD,avDqDG,MAAO,KAAI,CAAJ,EAAO,CAAP,C;QuDpDV,gBAAgB,UAAQ,MAAR,GAAe,CAAf,I;QAChB,iBAAc,OAAd,WAAqB,SAArB,U;UAtFE,cAuFiB,MAvFjB,EAAuB,mBAAX,OAuFa,KAvFb,CAAW,CAAvB,C;;QAyFF,oBAAS,MAAT,I;QAEI,yB;UAPJ,eArFA,C;;UAqFA,eAQY,C;;QnBeR,mB;QACA,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EmB9GR,C;EAEA,qE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IAmGxF,iBAjGI,MAiGa,GAhGb,MAgGa,I;IACjB,YAlGI,M;IAmGJ,sB;IAEW,QAAM,CAAA,MpCjJ6B,SoCiJ7B,MpCjJqC,cAAR,IoCiJ7B,IAnGb,CAmGa,I;IAAN,QAA6C,aAAa,KAAb,I;IAAxD,WvD8BO,MAAO,KAAI,CAAJ,EAAO,CAAP,C;IuD7Bd,gBAAgB,QAAQ,IAAR,GAAe,CAAf,I;IAChB,iBAAc,KAAd,WAAqB,SAArB,U;MApGM,aAqGa,MArGb,EAAsB,mBAAX,OAqGU,KArGV,CAAW,CAAtB,C;;IAuGN,gBAAS,IAAT,I;EArGJ,C;EAEA,qE;IAA4D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,KAAP,GAAc,MAAd,I;IACvF,qCAAuB,MrB8+FhB,QqB9+FP,EAA4C,MAA5C,EAAoD,MAApD,C;EACJ,C;EAEA,sE;IAA2D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IAsFtF,iBApFI,MAoFa,GAnFb,MAmFa,I;IACjB,YArFI,M;IAsFJ,sB;IAEW,QAAM,CAAA,MpCjJ6B,SoCiJ7B,MpCjJqC,cAAR,IoCiJ7B,IAtFb,CAsFa,I;IAAN,QAA6C,aAAa,KAAb,I;IAAxD,WvD8BO,MAAO,KAAI,CAAJ,EAAO,CAAP,C;IuD7Bd,gBAAgB,QAAQ,IAAR,GAAe,CAAf,I;IAChB,iBAAc,KAAd,WAAqB,SAArB,U;MAvFM,WAwFa,MAxFb,EAAoB,mBAAX,OAwFY,KAxFZ,CAAW,CAApB,C;;IA0FN,gBAAS,IAAT,I;EAxFJ,C;EAEA,sE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,KAAP,GAAc,MAAd,I;IACxF,qCAAuB,MrBwgGhB,QqBxgGP,EAA6C,MAA7C,EAAqD,MAArD,C;EACJ,C;EAEA,sE;IAA4D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IAyEvF,iBAvEI,MAuEa,GAtEb,MAsEa,I;IACjB,YAxEI,M;IAyEJ,sB;IAEW,QAAM,CAAA,MpCjJ6B,SoCiJ7B,MpCjJqC,cAAR,IoCiJ7B,IAzEb,CAyEa,I;IAAN,QAA6C,aAAa,KAAb,I;IAAxD,WvD8BO,MAAO,KAAI,CAAJ,EAAO,CAAP,C;IuD7Bd,gBAAgB,QAAQ,IAAR,GAAe,CAAf,I;IAChB,iBAAc,KAAd,WAAqB,SAArB,U;MA1EM,YA2Ea,MA3Eb,EAAqB,mBAAX,OA2EW,KA3EX,CAAW,CAArB,C;;IA6EN,gBAAS,IAAT,I;EA3EJ,C;EAEA,sE;IAA6D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IAgExF,iBA9DI,MA8Da,GA7Db,MA6Da,I;IACjB,YA/DI,M;IAgEJ,sB;IAEW,QAAM,CAAA,MpCjJ6B,SoCiJ7B,MpCjJqC,cAAR,IoCiJ7B,IAhEb,CAgEa,I;IAAN,QAA6C,aAAa,KAAb,I;IAAxD,WvD8BO,MAAO,KAAI,CAAJ,EAAO,CAAP,C;IuD7Bd,gBAAgB,QAAQ,IAAR,GAAe,CAAf,I;IAChB,iBAAc,KAAd,WAAqB,SAArB,U;MAjEM,aAkEa,MAlEb,EAAsB,mBAAX,OAkEU,KAlEV,CAAW,CAAtB,C;;IAoEN,gBAAS,IAAT,I;EAlEJ,C;EAEA,sE;IAA8D,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,MAAO,OAAP,GAAc,MAAd,I;IAuDzF,iBArDI,MAqDa,GApDb,MAoDa,I;IACjB,YAtDI,M;IAuDJ,sB;IAEW,QAAM,CAAA,MpCjJ6B,SoCiJ7B,MpCjJqC,cAAR,IoCiJ7B,IAvDb,CAuDa,I;IAAN,QAA6C,aAAa,KAAb,I;IAAxD,WvD8BO,MAAO,KAAI,CAAJ,EAAO,CAAP,C;IuD7Bd,gBAAgB,QAAQ,IAAR,GAAe,CAAf,I;IAChB,iBAAc,KAAd,WAAqB,SAArB,U;MAxDM,cAyDa,MAzDb,EAAuB,mBAAX,OAyDS,KAzDT,CAAW,CAAvB,C;;IA2DN,gBAAS,IAAT,I;EAzDJ,C;EAEA,uD;IACI,MAAY,QAAN,KAAM,CAAZ,C;EACJ,C;EAEA,oE;IAOc,IAAN,I;IACI,WADE,SACF,sC;MAAwB,Y;;MACV,eAAN,KAAM,C;IAHtB,W;EAMJ,C;2BAEA,yB;IvDwDA,iB;IoCrCA,gF;IAAA,4E;ImBnBA,2E;MAMI,iBAAiB,SAAS,MAAT,I;MACjB,gBAAY,MAAZ,C;MnBoBA,WAAW,4BmBnBI,anBmBJ,EAA8B,IAA9B,C;;QAGP,Q;QACA,OAAO,IAAP,C;UACW,aAAM,I;UAAN,gB;UmBvBA,QAAM,CAAA,MpC1HyB,SoC0HzB,MpC1HiC,cAAR,IoC0HzB,qB;UAAN,QAA6C,aAAa,OAAb,I;UAAxD,avDqDG,MAAO,KAAI,CAAJ,EAAO,CAAP,C;UuDpDV,gBAAgB,UAAQ,MAAR,GAAe,CAAf,I;UAChB,iBAAc,OAAd,WAAqB,SAArB,U;YACI,eAAe,MAAf,EAAuB,KAAvB,C;;UAEJ,oBAAS,MAAT,I;UAEI,yB;YAPJ,4B;;YAAA,eAQY,C;;UnBeR,mB;UACA,IAAI,QAAQ,CAAZ,C;YAAe,K;UACf,OAAO,4BAAiB,IAAjB,EAAuB,IAAvB,C;;;QAGX,0BAAe,IAAf,C;;ImBjBR,C;GApBA,C;6BAsBA,yB;IvDkCA,iB;IuDlCA,2E;MAMI,iBAAiB,SAAS,MAAT,I;MACjB,YAAY,M;MACZ,aAAa,S;MAEF,QAAM,CAAA,MpCjJ6B,SoCiJ7B,MpCjJqC,cAAR,IoCiJ7B,IAAwB,aAAxB,I;MAAN,QAA6C,aAAa,KAAb,I;MAAxD,WvD8BO,MAAO,KAAI,CAAJ,EAAO,CAAP,C;MuD7Bd,gBAAgB,QAAQ,IAAR,GAAe,CAAf,I;MAChB,iBAAc,KAAd,WAAqB,SAArB,U;QACI,eAAe,MAAf,EAAuB,KAAvB,C;;MAEJ,gBAAS,IAAT,I;IACJ,C;GAhBA,C;ECtNA,wC;IACS,iC;;MAgEL,IAAI,wCAAJ,C;QACI,YAAY,8B;QACZ,IAAI,sCAAmB,KAAnB,QAlEoB,CAkExB,C;UACI,iCAAe,QAnEK,CAmEL,I;UACT,4BhD7Bd,KAAK,UgD6BqB,KhD7BrB,SAAuC,KAAvC,C;UgD8BG,gCAAO,I;UAAP,kC;UAIR,gCAAO,K;;;IAzEP,IAAI,8BAAJ,C;MACI,8BAAmB,KAAnB,C;KAER,C;EAEA,8C;IACS,yC;;MA0EL,IAAI,wCAAJ,C;QACI,WAAW,mCA3EqB,CA2ErB,C;QA3E6B,aA4EzB,IA5EyB,Q;QA6ExC,0B;QACA,wCAAO,I;QAAP,0C;OAGJ,wCAAO,K;;;IAjFP,IAAI,sCAAJ,C;MACI,4B5BkCwD,O4BlC9C,K5BkC8B,KAAa,CAAG,C4BlCxD,C;MACA,4B5BoCyD,O4BpC/C,K5BoC6B,GAAY,GAAM,C4BpCzD,C;KAER,C;EAEA,sC;IACS,iC;;MAmDL,IAAI,wCAAJ,C;QACI,YAAY,8B;QACZ,IAAI,sCAAmB,KAAnB,QArDoB,CAqDxB,C;UACI,iCAAe,QAtDK,CAsDL,I;UACT,4BhD3Cd,KAAK,UgD2CqB,KhD3CrB,SAAuC,KAAvC,C;UgD4CG,gCAAO,I;UAAP,kC;UAIR,gCAAO,K;;;IA5DP,IAAI,8BAAJ,C;MACI,4BAAiB,KAAjB,C;KAER,C;EAEA,4C;IACS,yC;;MA6DL,IAAI,wCAAJ,C;QACI,WAAW,mCA9DqB,CA8DrB,C;QA9D6B,WA+DzB,IA/DyB,Q;QAgExC,0B;QACA,wCAAO,I;QAAP,0C;OAGJ,wCAAO,K;;;IApEP,IAAI,sCAAJ,C;MACI,8BAAmB,KAAnB,C;KAER,C;EAEA,8C;I7CgFW,SiBzDmD,Q4BtB1D,K5BsB4C,KAAU,EAAI,C;I4BrBtD,4B5BewD,O4Bf9C,E5Be8B,KAAa,CAAG,C4BfxD,C;IACA,4B5BiByD,O4BjB/C,E5BiB6B,GAAY,GAAM,C4BjBzD,C;I7C6EG,WiBtDqD,Q4BrB5D,K5BqB2C,GAAS,KAAQ,C;I4BpBxD,4B5BWwD,O4BX9C,I5BW8B,KAAa,CAAG,C4BXxD,C;IACA,4B5BayD,O4Bb/C,I5Ba6B,GAAY,GAAM,C4BbzD,C;EAER,C;EAEA,uC;IACS,iC;;MA4BL,IAAI,wCAAJ,C;QACI,YAAY,8B;QACZ,IAAI,sCAAmB,KAAnB,QA9BoB,CA8BxB,C;UACI,iCAAe,QA/BK,CA+BL,I;UACf,aAAM,4B;UAhCoC,MhDiBlD,KAAK,UgDeqB,KhDfrB,EAAkB,iBAAU,EAAV,CAAc,QAAhC,EAAwD,KAAxD,C;UgDjB6C,MhDkBlD,KAAK,UgDcqB,KhDdZ,GAAS,CAAT,IAAT,EAAsB,sBAAuB,QAA7C,EAAqE,KAArE,C;UgDeG,gCAAO,I;UAAP,kC;UAIR,gCAAO,K;;;IArCP,IAAI,8BAAJ,C;MACI,6BAAkB,KAAlB,C;KAER,C;EAEA,6C;IACS,yC;;MAsCL,IAAI,wCAAJ,C;QACI,WAAW,mCAvCqB,CAuCrB,C;QAvC6B,YAwCzB,IAxCyB,Q;QAyCxC,0B;QACA,wCAAO,I;QAAP,0C;OAGJ,wCAAO,K;;;IA7CP,IAAI,sCAAJ,C;MACI,8BAAmB,K5BUkB,oBAAU,EAAV,CAAc,Q4BVnD,C;MACA,8BAAmB,K5BYiB,iBAAsB,Q4BZ1D,C;KAER,C;EAEA,wC;IACS,iC;;MAeL,IAAI,wCAAJ,C;QACI,YAAY,8B;QACZ,IAAI,sCAAmB,KAAnB,QAjBoB,CAiBxB,C;UACI,iCAAe,QAlBK,CAkBL,I;UACT,4BhDAd,KAAK,YgDAqB,KhDArB,SAAyC,KAAzC,C;UgDCG,gCAAO,I;UAAP,kC;UAIR,gCAAO,K;;;IAxBP,IAAI,8BAAJ,C;MACI,4BAAuB,UAAN,KAAM,CAAvB,C;KAER,C;EAEA,yC;IACS,iC;;MASL,IAAI,wCAAJ,C;QACI,YAAY,8B;QACZ,IAAI,sCAAmB,KAAnB,QAXoB,CAWxB,C;UACI,iCAAe,QAZK,CAYL,I;UACT,4BhDcd,KAAK,YgDdqB,KhDcrB,SAAyC,KAAzC,C;UgDbG,gCAAO,I;UAAP,kC;UAIR,gCAAO,K;;;IAlBP,IAAI,8BAAJ,C;MACI,6BAAwB,YAAN,KAAM,CAAxB,C;KAER,C;EAEA,mE;IAII,IAAI,wCAAJ,C;MACI,YAAY,8B;MACZ,IAAI,sCAAmB,KAAnB,QAA2B,aAA/B,C;QACI,iCAAe,QAAQ,aAAR,I;QACf,MAAM,4BAAN,EAAkB,KAAlB,C;QACA,OAAO,I;QAIf,OAAO,K;EACX,C;EAEA,kF;IAII,IAAI,wCAAJ,C;MACI,WAAW,mCAAiB,aAAjB,C;MACX,eAAe,IAAf,C;MACA,0B;MACA,OAAO,I;KAGX,OAAO,K;EACX,C;EtClFwC,mD;IAcpC,0C;IAVA,yBAAc,IAAd,EAAoB,SAApB,EAA+B,IAA/B,C;G;EAUA,wC;IAAA,4C;G;;;SAOQ,Y;MAAQ,OAAA,sCAAe,M;K;;;;;;;;EAP/B,oD;IAAA,mD;MAAA,kC;KAAA,4C;G;;;;;;EARA,+D;IAAA,4D;IAMS,Q;IAAL,+BAAK,2DAAL,EAA0B,SAA1B,EAAqC,IAArC,C;IANJ,Y;G;6GA0BA,qB;IAAQ,2B;G;EAWR,mC;IAEI,Q;IADA,IAAI,oBAAJ,C;MAAgB,OAAO,K;IACvB,4CAAqB,CAArB,W;MACI,mC;MACA,OAAO,I;KAEX,OAAO,K;EACX,C;+GAIA,qB;IAAQ,2B;G;qHAIR,qB;IAAQ,QAAC,oB;G;iGoBnEb,yB;IAAA,+E;IAAA,iF;IAAA,sC;MACuC,iB;QAAA,IAAS,C;MAK/B,Q;MAAb,aAAa,sCAAY,CAAZ,oBAAkB,qBAAqB,CAArB,C;MAC/B,qBAAqB,MAAO,a;;QAExB,MAAM,MAAN,C;;QAEA,oBAAoB,MAAO,a;QAC3B,IAAI,gBAAgB,cAApB,C;UACI,MAAM,2BAAsB,yCAAtB,C;SAEV,IAAI,kBAAiB,MAAO,cAA5B,C;UACI,6BAAW,MAAX,C;;UAEA,yBAAe,a;;;IAG3B,C;GArBA,C;qGSCA,yB;IAAA,qD;IAAA,mC;MAaW,Q;MADP,aAAa,kB;;QAET,aAAM,MAAN,C;;QAEA,MAAO,U;;MAHX,W;IAKJ,C;GAlBA,C;EAoBA,8B;IAGW,Q;IADP,WAAW,sB;IAEP,aAAS,mCAAY,MAArB,C;MAA6C,OAAf,sCAAe,M;;MACrC,2BAAoB,QAAL,IAAK,CAApB,EAA+B,eAA/B,C;IAFZ,W;EAIJ,C;EU5BA,qD;IAKI,4B;;MlBuOc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,YAAM,O;UkBxOf,gBAAsB,0BAAN,KAAM,Y;UACtB,4DAAkB,SAAlB,E;UACA,yBAAY,C;UAAZ,W;YAAiB,WAAC,KtC0XoB,iBsC1XpB,KtC0XoC,asC1XrC,C;WlBsOb,IAAI,OAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IkB7OR,OAAO,gB;EACX,C;EAEA,mE;IAKI,4B;;MlBuNc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,YAAM,O;UkBxNf,gBAAsB,2BAAN,KAAM,yB;UACtB,4DAAkB,SAAlB,E;UACA,yBAAY,C;UAAZ,W;YAAiB,WAAC,KtC0WoB,iBsC1WpB,KtC0WoC,asC1WrC,C;WlBsNb,IAAI,OAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IkB7NR,OAAO,gB;EACX,C;EAEA,uE;IAIqE,sB;MAAA,SAAc,C;IAAG,sB;MAAA,SAAc,GAAI,O;IACpG,wBAAoB,MAApB,C;IACA,uBAAmB,MAAnB,C;;MlBsMc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,YAAM,O;UkBvMf,aAAmB,uBAAN,KAAM,kBAAuC,eAAvC,EAAsD,cAAtD,C;UACnB,oCAAiB,MAAjB,I;UACA,kCAAgB,MAAhB,I;UACA,8BAAe,C;UAAf,W;YAAoB,WAAC,KtCwViB,iBsCxVjB,KtCwViC,asCxVlC,C;WlBoMhB,IAAI,OAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IkB3MR,OAAO,kBAAgB,MAAhB,I;EACX,C;EAEA,qF;IASI,sB;MAAA,SAAc,C;IACd,sB;MAAA,SAAc,GAAI,O;IAElB,IAAI,eAAc,UAAlB,C;MAA8B,OAAO,8BAAmB,UAAnB,EAA+B,GAA/B,EAAoC,MAApC,EAA4C,MAA5C,C;IAErC,wBAAoB,MAApB,C;IACA,uBAAmB,MAAnB,C;;MlB2Kc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,YAAM,O;UkB5Kf,aAAmB,wBAAN,KAAM,+BAAqD,eAArD,EAAoE,cAApE,C;UACnB,oCAAiB,MAAjB,I;UACA,kCAAgB,MAAhB,I;UlB0KI,IAAI,EkBzKR,EAAC,KtC6TqC,iBsC7TrC,KtC6TqD,asC7TtD,KAAoB,iBAAe,ClByK3B,CAAJ,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IkBhLR,OAAO,kBAAgB,MAAhB,I;EACX,C;EAEA,yD;IAKI,yB;;MlB0Jc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,YAAM,O;UkB5Jf,aAAmB,yBAAN,KAAM,iB;UACnB,sDAAe,MAAf,E;UlB2JI,IAAI,CkB1JR,EAAC,KtC8SqC,iBsC9SrC,KtC8SqD,asC9StD,ClB0JI,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IkBjKR,OAAO,a;EACX,C;EAEA,uE;IAMI,yB;;MlB0Ic,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,YAAM,O;UkB3If,aAAmB,0BAAN,KAAM,8B;UACnB,sDAAe,MAAf,E;UlB0II,IAAI,CkBzIR,EAAC,KtC6RqC,iBsC7RrC,KtC6RqD,asC7RtD,ClByII,C;YACI,K;WAEJ,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;YAAgC,K;WAA3C,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IkBhJR,OAAO,a;EACX,C;EAIA,4D;IACI,YAAY,MAAO,a;IACnB,QAAQ,K;IACR,YAAY,MAAO,c;IACnB,aAAa,MAAO,O;IAEpB,OAAO,IAAI,KAAX,IACQ,MpC/FG,KAAK,SoC+FD,CpC/FC,CoC8FhB,KACqB,SADrB,C;MAEI,a;;IAGJ,MAAO,2BAAkB,CAAlB,C;IACP,OAAO,IAAI,KAAJ,I;EACX,C;EAIA,0E;IACI,YAAY,MAAO,a;IACnB,QAAQ,K;IACR,YAAY,MAAO,c;IACnB,aAAa,MAAO,O;IAEpB,OAAO,IAAI,KAAX,C;MACI,QAAQ,MpChHD,KAAK,SoCgHG,CpChHH,C;MoCiHZ,IAAI,MAAK,UAAL,IAAmB,MAAK,UAA5B,C;QAAwC,K;MACxC,a;;IAGJ,MAAO,2BAAkB,CAAlB,C;IACP,OAAO,IAAI,KAAJ,I;EACX,C;yGA4BA,yB;IzDgFA,iB;IiC1PA,mD;IwB0KA,4D;MAIqC,Q;MAHjC,mBAAmB,sB;MACT,QAAM,uB;MAAN,QAAqB,eAAe,MAAf,I;MAA/B,UzDoFO,MAAO,KAAI,CAAJ,EAAO,CAAP,C;MyDnFd,aAAa,gB;MACoB,U;MAAjC,iBAAc,YAAd,wB;QACI,IAAI,UAAU,MpCxJP,KAAK,SoCwJgB,KpCxJhB,CoCwJR,CAAJ,C;UACI,MAAM,K;UACN,K;;MAIR,eAAe,MAAM,YAAN,I;MxB3Kf,OwB4KA,MxB5KA,EwB4KmC,GxB5KnC,EwB4KqB,YxB5KrB,EwB4KgD,QxB5KhD,EwB4KwC,MxB5KxC,C;MwB6KA,OAAO,Q;IACX,C;GAdA,C;2GAgBA,yB;IAAA,2D;IAAA,4C;MACI,YAAY,sB;MACZ,UAAU,uB;MACV,aAAa,gB;;QAEL,qBAAS,G;QAAT,U;UAAgB,iBAAU,MpCxKvB,KAAK,SoCwKgC,KpCxKhC,CoCwKQ,C;SAApB,S;UACI,K;SAEJ,qB;;MACK,a;MAET,WAAW,QAAQ,sBAAR,I;MACP,WAAJ,GAAI,EAAW,SAAX,EAAiB,IAAjB,C;MACJ,OAAO,I;IACX,C;GAdA,C;6GzCzLA,yB;IAAA,0C;IAAA,6E;IAAA,qC;MACqC,uB;QAAA,UAAmB,iBAAS,M;MAC7D,OAAqB,kBAArB,OAAQ,aAAa,EAAkB,SAAlB,EAAwB,CAAxB,EAA2B,gBAA3B,C;K;GAFzB,C;EAgBA,oD;IAIuC,wB;MAAA,WAAgB,E;IAAI,qB;MAAA,QAAa,U;IACpE,IEyCQ,oBFzCR,C;MAAa,OAAO,I;IACpB,SAAS,qBAAc,QAAd,C;IACT,OAAW,4BAAe,EAAf,EAAmB,KAAnB,CAAJ,GAA+B,EAAG,WAAlC,GAAkD,I;EAC7D,C;EAEA,oD;IAI8B,wB;MAAA,WAAgB,E;IAAI,qB;MAAA,QAAa,U;IAC3D,SAAS,qBAAc,QAAd,C;IACT,OAAW,4BAAe,EAAf,EAAmB,KAAnB,CAAJ,GAA+B,EAAG,WAAlC,GAAkD,I;EAC7D,C;EAEA,iD;IAMI,kBAAc,CAAd,C;IACA,eAAW,CAAX,C;IACA,aAAS,KAAT,C;IACA,cAAU,KAAV,C;;MuB6Nc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,aAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,MAAd,C;;cAEe,aAAM,O;cvBpOzB,eAAW,CAAX,C;cACc,qB;;gBwBsElB,oBAAgB,CAAhB,C;gBACA,gBAAY,CAAZ,C;gBACA,wBAAoB,CAApB,C;gBrB8RS,aHtWE,MGsWI,O;gBAAN,YHtWE,MGsWY,a;gBAAd,mBHtWE,MGsW0B,c;8BqB3RjC,iBAAc,KAAd,UAA0B,YAA1B,U;kBACI,QAAQ,MnBtGL,KAAK,SmBsGO,KnBtGP,CmBsGA,GAA0B,G;kBAE9B,SAAM,GAAN,MAAc,CAAd,C;oBACI,IAAI,gBAAa,CAAjB,C;sBAAoB,mBAAmB,WAAnB,C;oBACf,SAAW,mBAAF,CAAE,E;oBAAX,mB;;sBxB/Eb,QAAM,aAAN,C;6BACI,E;0BACI,IAAI,IAAJ,C;4BACI,QAAM,I;4BACN,kBAAkB,K;4BAAlB,oB;;0BAEJ,OAAK,I;0BANb,kBAOQ,I;0BAPR,oB;6BASI,E;0BACI,QAAM,I;0BACN,SAAO,C;0BAXf,kBAYQ,K;0BAZR,oB;gCAeQ,IAAI,IAAJ,C;4BACI,QAAM,I;4BACN,kBAAkB,K;4BAAlB,oB;;0BAGJ,IAAI,mBAAJ,C;4BAAsB,0B;0BACtB,6B;0BACI,mBAAO,aAAP,C;0BAtBZ,kBAuBQ,I;0BAvBR,oB;;;;oBwB+EQ,IAAI,gBAAJ,C;sBxBhFL,MwBiFS,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,E;sBAAP,sB;4BAGR,oBAAa,CAAb,C;oBAGI,WAAW,G;oBACX,UAAQ,C;oBAER,aAAU,CAAV,OAAa,CAAb,M;sBACI,IAAI,WAAU,IAAV,MAAkB,CAAtB,C;wBACI,UAAQ,UAAe,CAAL,I;wBAClB,OAAO,QAAS,C;wBAChB,iC;;wBAEA,K;;;oBAIR,kBAAgB,W;oBAChB,iC;oBAEA,IAAI,mBAAgB,eAAe,KAAf,IAAhB,CAAJ,C;sBxBxGL,MwByGS,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,e;sBAAP,sB;;oBAKJ,UAAS,WAAU,CAAX,GAAkB,IAAM,G;oBAChC,iC;oBAEA,IAAI,gBAAa,CAAjB,C;sBACI,IAAI,eAAe,OAAf,CAAJ,C;wBACS,WAAe,mBAAN,OAAM,E;wBAAf,qB;;0BxBnHrB,QAAM,eAAN,C;iCACI,E;8BACI,IAAI,IAAJ,C;gCACI,QAAM,I;gCACN,oBAAkB,K;gCAAlB,oB;;8BAEJ,OAAK,I;8BANb,oBAOQ,I;8BAPR,oB;iCASI,E;8BACI,QAAM,I;8BACN,SAAO,C;8BAXf,oBAYQ,K;8BAZR,oB;oCAeQ,IAAI,IAAJ,C;gCACI,QAAM,I;gCACN,oBAAkB,K;gCAAlB,oB;;8BAGJ,IAAI,mBAAJ,C;gCAAsB,0B;8BACtB,6B;8BACI,mBAAO,eAAP,C;8BAtBZ,oBAuBQ,I;8BAvBR,oB;;;;wBwBmHgB,IAAI,kBAAJ,C;0BxBpHb,MwBqHiB,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;gCAED,IAAI,CAAC,iBAAiB,OAAjB,CAAL,C;wBACH,mBAAmB,OAAnB,C;;wBAEK,WAA8B,mBAArB,cAAc,OAAd,CAAqB,E;wBAA9B,qB;;0BxB1HrB,QAAM,eAAN,C;iCACI,E;8BACI,IAAI,IAAJ,C;gCACI,QAAM,I;gCACN,oBAAkB,K;gCAAlB,oB;;8BAEJ,OAAK,I;8BANb,oBAOQ,I;8BAPR,oB;iCASI,E;8BACI,QAAM,I;8BACN,SAAO,C;8BAXf,oBAYQ,K;8BAZR,oB;oCAeQ,IAAI,IAAJ,C;gCACI,QAAM,I;gCACN,oBAAkB,K;gCAAlB,oB;;8BAGJ,IAAI,mBAAJ,C;gCAAsB,0B;8BACtB,6B;8BACI,mBAAO,eAAP,C;8BAtBZ,oBAuBQ,I;8BAvBR,oB;;;;wBwB0HoB,+B;wBAAA,Y;0BACC,WAA6B,mBAApB,aAAa,OAAb,CAAoB,E;0BAA7B,qB;;4BxB3HrB,QAAM,eAAN,C;mCACI,E;gCACI,IAAI,IAAJ,C;kCACI,QAAM,I;kCACN,oBAAkB,K;kCAAlB,oB;;gCAEJ,OAAK,I;gCANb,oBAOQ,I;gCAPR,oB;mCASI,E;gCACI,QAAM,I;gCACN,SAAO,C;gCAXf,oBAYQ,K;gCAZR,oB;sCAeQ,IAAI,IAAJ,C;kCACI,QAAM,I;kCACN,oBAAkB,K;kCAAlB,oB;;gCAGJ,IAAI,mBAAJ,C;kCAAsB,0B;gCACtB,6B;gCACI,mBAAO,eAAP,C;gCAtBZ,oBAuBQ,I;gCAvBR,oB;;;;0BwB2HoB,2B;yBADJ,W;0BxB3Hb,MwB8HiB,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;;sBAIR,UAAQ,C;;;gBrBmO5B,SqB7NI,eAAe,KAAf,I;gBxBzIO,MGuWX,sBAAa,EAAb,C;gBqB3NA,oBAAO,C;;;cxB5IH,0B;cA6BA,IAAI,SAAO,CAAX,C;gBACI,MAAO,sBAAa,MAAb,C;euBqMC,SvBlMR,KAAJ,GAAS,CAAT,GAAqB,cAAL,MAAK,EAAc,CAAd,C;;4BuBoMD,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,M;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,MAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;;WAIA,UAAU,I;UACV,UAAU,I;;QACL,iBAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IvB3NR,IAAI,SAAO,CAAX,C;MAAc,qBAAqB,MAArB,C;IAEd,OAAO,YAAU,CAAV,IAAe,CAAC,oB;EAC3B,C;EAEA,8D;IAM4D,qB;MAAA,QAAa,U;IVmT9C,kBAAhB,oB;IUjTH,oCLpBJ,WKoBI,oB;IADJ,OLlBO,WLoUqC,W;EU/ShD,C;EAEA,qE;IAO+E,qB;MAAA,QAAa,U;IACxF,kBAAc,CAAd,C;IACA,oBAAgB,KAAhB,C;;MuB6Hc,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,aAAM,O;UvB9HR,sB;;YGqSF,aHrSL,MGqSW,O;YAAN,YHrSL,MGqSmB,a;YAAd,mBHrSL,MGqSiC,c;YqBnZjC,iBAAc,KAAd,UAA0B,YAA1B,U;cACI,gBAAgB,MnBkBb,KAAK,SmBlBe,KnBkBf,CmBlBQ,GAA0B,G;cACtC,0BAAc,GAAd,MAAsB,G;cAAtB,Y;gBAA+B,SAAmB,mBAAV,SAAU,E;gBAAnB,mB;gBxB6GnC,IAAI,mCAAJ,C;kBACI,cAAY,I;kBADhB,kBAEI,K;;kBAEA,IAAI,mBAAJ,C;oBAAsB,0B;kBACtB,6B;kBACI,mBAAO,aAAP,C;kBANR,kBAOI,I;;gBwBpH8B,yB;eAAlC,W;gBxB4GJ,MwB3GQ,sBAAa,QAAQ,KAAR,IAAb,C;gBACA,qBAAO,K;gBAAP,uB;;YrB+YZ,SqB3YI,eAAe,KAAf,I;YxBsGA,MGsSJ,sBAAa,EAAb,C;YqBzYA,qBAAO,I;;;UDiOC,IAAI,mBAAJ,C;;WAGA,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;;WAAX,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IvB3HR,IAAI,CAAC,WAAL,C;MACI,YAAU,8CAAiC,GAAjC,EAAsC,UAAtC,EAAkD,KAAlD,EAAyD,SAAzD,C;KAGd,OAAO,S;EACX,C;EAEA,uE;IAO2E,qB;MAAA,QAAa,U;IACpF,sBAAsB,UAAW,O;IAC7B,+BAAmB,C;IAAnB,S;MAAsC,OAuON,CAvOR,sBAAW,CAAX,CAuOQ,SAAW,G;KAvO/C,S;MACI,OAAO,gCAAiC,OAAd,sBAAW,CAAX,CAAc,KAAjC,EAA2C,GAA3C,CAAgD,Q;;MAChD,iCAAmB,C;MAAnB,W;QAAsC,SAqOb,CArOD,sBAAW,CAAX,CAqOC,SAAW,G;;MArOpC,W;QAAqE,SAqO5C,CArO8B,sBAAW,CAAX,CAqO9B,SAAW,G;OArOxC,W;QACH,OAAO,iCAAkC,OAAd,sBAAW,CAAX,CAAc,KAAlC,EAA0D,OAAd,sBAAW,CAAX,CAAc,KAA1D,EAAoE,GAApE,CAAyE,Q;;IAGpF,OAAO,4CAAiC,UAAjC,EAA6C,KAA7C,EAAoD,GAApD,C;EACX,C;EAEA,uE;IAKI,qB;MAAA,QAAa,U;IAEmB,Q;IAAhC,OAAO,sCAAyB,qDAAzB,EAAwC,UAAxC,EAAoD,KAApD,C;EACX,C;EAEA,mC;IAKI,iB;MAAmB,kBAAV,mB;MAAU,cAAyB,qD;MNc5C,IAAI,4CAAJ,C;QAAmC,MAAM,8BAAyB,OAAzB,C;MMdzC,INeO,WAAK,Q;KMbZ,UAAK,CAAL,C;MAAuB,kBAAb,cAAU,CAAV,C;MAAoB,wBL5ExB,WK4EwB,EAAc,CAAd,I;MADnB,OL1EJ,W;;MK0EI,OAEH,c;G;EAGZ,mC;IAGgD,8BAAY,CAAZ,EAAe,CAAf,C;G;EAEhD,gC;IAG0C,6B;G;EAE1C,0C;IAI6B,mB;MAAA,MAAW,C;IAAG,mB;MAAA,MAAW,U;IAA4B,IAAI,QAAO,GAAP,IAAc,QAAO,CAAzB,C;MAAA,OAC9E,c;WACG,IAAI,QAAO,GAAX,C;MACY,kBAAf,cAAU,GAAV,C;MAAsB,wBLjGhB,WKiGgB,EAAc,CAAd,M;MAHwD,OL7FvE,W;;MKkGP,YAAY,cAAoD,gBAA7B,aAAT,oBAAJ,GAAI,CAAS,EAAa,uBAAb,CAA6B,EAAkB,oBAAJ,GAAI,CAAlB,CAA4B,QAAhF,C;MACZ,WAAW,C;MAEX,OAAO,OAAO,GAAd,C;QACmB,QAAW,KAAM,O;QAAhC,ehB4DG,MAAO,KgB5DW,GhB4DX,EAAO,CAAP,CgB5DK,GAAyB,IAAzB,I;QACf,SAAS,4BAAc,KAAd,EAAqB,IAArB,EAA2B,QAA3B,C;QACT,IAAI,MAAM,CAAV,C;UAAa,K;QACb,cAAQ,EAAR,I;QACA,IAAI,KAAM,OAAN,KAAc,IAAlB,C;UACI,QAAc,OAAN,KAAM,EAAO,OAAO,CAAP,IAAP,C;;MAItB,IAAI,OAAO,GAAX,C;QACI,MAAM,iBAAa,wCAAqC,GAArC,iBAAkD,MAAM,IAAN,IAAlD,oBAAb,C;OAnBoE,OAsB1E,SAAQ,KAAM,OAAlB,GAAwB,KAAxB,GAAyC,OAAN,KAAM,EAAO,IAAP,C;;G;EAG7C,kD;IASoE,mB;MAAA,MAAW,U;IAC3E,OAAe,SAAR,OAAQ,EAAO,SAAP,EAAa,GAAb,EAAkB,GAAlB,C;EACnB,C;EAEA,kD;IAI2C,uB;MAAA,UAAmB,sBAAS,M;IAAO,mB;MAAA,MAAW,U;IACrF,OAA4B,SAArB,OAAQ,aAAa,EAAO,SAAP,EAAa,GAAb,EAAkB,GAAlB,C;EAChC,C;EAEA,6C;IAQmD,mB;MAAA,MAAW,U;IAC1D,OAAe,OAAR,OAAQ,EAAO,SAAP,EAAa,GAAb,C;EACnB,C;EAEA,6C;IAI0B,uB;MAAA,UAAmB,sBAAS,M;IAAO,mB;MAAA,MAAW,U;IACpE,OAA4B,OAArB,OAAQ,aAAa,EAAO,SAAP,EAAa,GAAb,C;EAChC,C;EAEA,6C;IAI2B,uB;MAAA,UAAmB,sBAAS,M;IAAO,mB;MAAA,MAAW,U;IVkJ9C,kBAAhB,oB;IUjJc,aAAb,oBAAa,aLpLrB,WKoLqB,EAAkC,IAAlC,M;IADyE,OLlLvF,WLoUqC,W;G;EU9IhD,8C;IAO+B,uB;MAAA,UAAmB,sBAAS,M;IACvD,OAAO,mCAAwB,CAAxB,EAA2B,OAA3B,C;EACX,C;EAEA,sE;IAG+D,uB;MAAA,UAAmB,sBAAS,M;IACvF,QAAQ,sBAAS,OAAT,EAAkB,eAAlB,C;IACR,IAAI,CAAE,OAAF,GAAW,eAAf,C;MACI,gCAAgC,eAAhC,C;KAEJ,OAAO,C;EACX,C;EAEA,uD;IAKoC,uB;MAAA,UAAmB,sBAAS,M;IAC5D,OAAO,gCAAmB,KAAnB,EAA0B,OAA1B,C;EACX,C;EAEA,8D;IAGqD,uB;MAAA,UAAmB,sBAAS,M;IAC7E,OAA4B,iBAArB,OAAQ,aAAa,EAAiB,SAAjB,EAAqC,UAArC,C;EAChC,C;EAEA,iE;IAaI,yB;MAAA,YAAiB,C;IACjB,uB;MAAA,UAAe,IAAK,O;IAGZ,aAAR,OAAQ,EAAa,SAAb,EAAmB,IAAnB,EAAyB,SAAzB,EAAoC,OAApC,C;EACZ,C;EAEA,mE;IAKI,yB;MAAA,YAAiB,C;IACjB,uB;MAAA,UAAe,IAAK,O;IACpB,uB;MAAA,UAAmB,sBAAS,M;IAE5B,IAAI,YAAY,sBAAS,MAAzB,C;MACI,OAAO,yBAAc,IAAd,EAAoB,SAApB,EAA+B,OAA/B,C;KAGU,aAArB,OAAQ,aAAa,EAAa,SAAb,EAAmB,IAAnB,EAAyB,SAAzB,EAAoC,OAApC,C;EACzB,C;EAEA,mE;IAKI,yB;MAAA,YAAiB,C;IACjB,uB;MAAA,UAAe,IAAK,O;IACpB,uB;MAAA,UAAmB,sBAAS,M;IAE5B,IAAI,YAAY,sBAAS,MAAzB,C;MACI,OAAO,yBAAc,sBAAkB,IAAlB,EAAwB,CAAxB,EAA2B,IAAK,OAAhC,CAAd,EAAqD,SAArD,EAAgE,OAAhE,C;KAGU,SAArB,OAAQ,aAAa,EAAO,IAAP,EAAa,SAAb,EAAwB,OAAxB,EAAiC,SAAjC,C;EACzB,C;EAEA,4D;IACI,gBAAY,SAAZ,C;IoBnIA,WAAW,8BpBoII,CoBpIJ,EAA8B,IAA9B,C;;MAGP,Q;MACA,OAAO,IAAP,C;QACW,aAAM,I;QAAN,gB;QpBgIX,aAAa,MAAO,O;QACpB,gBAAgB,MAAO,c;QACvB,eAAe,MAAO,M;mBAEW,aAAP,MAAO,QAAiB,OAAjB,WAAiC,SAAjC,EAA4C,QAA5C,C;QAA5B,iBdFgC,gB0BlTiB,QY6KpB,UZ7KM,KAAU,EAAI,C1BkTjB,C;QcEpB,YdFoB,gB0B/SmB,QY2K3B,UZ3KU,GAAS,KAAQ,C1B+SnB,C;QcIrC,qBAAS,Ud3FyB,KAAL,GAAiB,Kc2F9C,K;QACA,MAAO,uBAAc,Kd5Fa,KAAL,GAAiB,Kc4FvC,C;QAGH,KAAA,Ud/F8B,KAAL,GAAiB,Kc+F1C,MAAsB,CAAtB,IAA2B,iBAA3B,C;UAVJ,eAUkD,C;eAC9C,sB;UAXJ,eAWuB,C;;UAXvB,eAYY,C;;QoB5IR,mB;QACA,IAAI,QAAQ,CAAZ,C;UAAe,K;QACf,OAAO,8BAAiB,IAAjB,EAAuB,IAAvB,C;;;MAGX,4BAAe,IAAf,C;;EpB0IR,C;EAIA,gC;IACwC,0BAAW,G;G;EAEnD,6E;IACI,kBAAc,CAAd,C;IACA,oBAAgB,KAAhB,C;;MuB9Ic,gB;MADd,cAAc,I;MACA,uCAAqB,CAArB,C;MAAA,iB;QAA2B,qB;OAAzC,cAAc,I;;;UAID,aAAM,O;UvB6If,aAAa,MGjT4B,iBHiT5B,MGjT4C,aAAhB,I;UHmTzB,sB;;YGwBX,aHxBI,MGwBE,O;YAAN,YHxBI,MGwBU,a;YAAd,mBHxBI,MGwBwB,c;YqBnZjC,iBAAc,KAAd,UAA0B,YAA1B,U;cACI,gBAAgB,MnBkBb,KAAK,SmBlBe,KnBkBf,CmBlBQ,GAA0B,G;cACtC,0BAAc,GAAd,MAAsB,G;cAAtB,Y;gBAA+B,mB;gBxB0XnC,IAAI,+BwB1XkD,mBAAV,SAAU,ExB0XlD,EAAJ,C;kBACI,cAAY,I;kBADhB,kBAEI,K;;kBAEA,IAAI,mBAAJ,C;oBAAsB,0B;kBACtB,6B;kBALJ,kBAMI,I;;gBwBhY8B,yB;eAAlC,W;gBxByXK,MwBxXD,sBAAa,QAAQ,KAAR,IAAb,C;gBACA,qBAAO,K;gBAAP,uB;;YrB+YZ,SqB3YI,eAAe,KAAf,I;YxBmXS,MGyBb,sBAAa,EAAb,C;YqBzYA,qBAAO,I;;;UxBgXH,6B;UAWA,YAAY,UAAS,MG9ToB,iBH8TpB,MG9ToC,aAAhB,IH8T7B,K;UACZ,IAAI,QAAQ,CAAZ,C;YACI,MAAO,gBAAO,KAAP,C;YACH,mBAAW,MAAX,EAAmB,KAAnB,C;WuB7JJ,IAAI,CvBgKR,IuBhKI,C;;WAGA,UAAU,K;UACC,wCAAoB,OAApB,C;UAAA,mB;;WAAX,WAAW,M;UACX,UAAU,I;UACV,UAAU,I;;QACL,a;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IvByJR,IAAI,CAAC,WAAD,IAAc,CAAC,oBAAnB,C;MACI,YAAU,4CAAiC,GAAjC,EAAsC,UAAtC,EAAkD,KAAlD,EAAyD,SAAzD,C;KAGd,OAAO,S;EACX,C;EAEA,uF;IAMI,kBAAc,QAAd,C;IACA,eAAW,CAAX,C;;MuBvJc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,aAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,MAAd,C;;cAEe,aAAM,O;cvBgJzB,eAAa,MGxV4B,iBHwV5B,MGxV4C,aAAhB,I;cH0V3B,qB;;gBwB/SlB,oBAAgB,CAAhB,C;gBACA,gBAAY,CAAZ,C;gBACA,wBAAoB,CAApB,C;gBrB8RS,aHeE,MGfI,O;gBAAN,YHeE,MGfY,a;gBAAd,mBHeE,MGf0B,c;gBqB3RjC,iBAAc,KAAd,UAA0B,YAA1B,U;kBACI,QAAQ,MnBtGL,KAAK,SmBsGO,KnBtGP,CmBsGA,GAA0B,G;kBAE9B,SAAM,GAAN,MAAc,CAAd,C;oBACI,IAAI,gBAAa,CAAjB,C;sBAAoB,mBAAmB,WAAnB,C;oBACf,mB;oBxBsSb,IAAI,+BwBtSoB,mBAAF,CAAE,ExBsSpB,EAAJ,C;sBAAA,kBACI,K;;sBAEA,IAAI,mBAAJ,C;wBACI,0B;uBAEJ,6B;sBANJ,kBAOI,I;;oBwB7SI,IAAI,gBAAJ,C;sBxBqSL,MwBpSS,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,E;sBAAP,sB;4BAGR,oBAAa,CAAb,C;oBAGI,WAAW,G;oBACX,UAAQ,C;oBAER,aAAU,CAAV,OAAa,CAAb,M;sBACI,IAAI,WAAU,IAAV,MAAkB,CAAtB,C;wBACI,UAAQ,UAAe,CAAL,I;wBAClB,OAAO,QAAS,C;wBAChB,iC;;wBAEA,K;;;oBAIR,kBAAgB,W;oBAChB,iC;oBAEA,IAAI,mBAAgB,eAAe,KAAf,IAAhB,CAAJ,C;sBxB6QL,MwB5QS,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,e;sBAAP,sB;;oBAKJ,UAAS,WAAU,CAAX,GAAkB,IAAM,G;oBAChC,iC;oBAEA,IAAI,gBAAa,CAAjB,C;sBACI,IAAI,eAAe,OAAf,CAAJ,C;wBACS,qB;wBxBkQrB,IAAI,+BwBlQgC,mBAAN,OAAM,ExBkQhC,EAAJ,C;0BAAA,oBACI,K;;0BAEA,IAAI,mBAAJ,C;4BACI,0B;2BAEJ,6B;0BANJ,oBAOI,I;;wBwBzQY,IAAI,kBAAJ,C;0BxBiQb,MwBhQiB,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;gCAED,IAAI,CAAC,iBAAiB,OAAjB,CAAL,C;wBACH,mBAAmB,OAAnB,C;;wBAEK,qB;wBxB2PrB,IAAI,+BwB3P+C,mBAArB,cAAc,OAAd,CAAqB,ExB2P/C,EAAJ,C;0BAAA,oBACI,K;;0BAEA,IAAI,mBAAJ,C;4BACI,0B;2BAEJ,6B;0BANJ,oBAOI,I;;wBwBlQgB,+B;wBAAA,Y;0BACC,qB;0BxB0PrB,IAAI,+BwB1P8C,mBAApB,aAAa,OAAb,CAAoB,ExB0P9C,EAAJ,C;4BAAA,oBACI,K;;4BAEA,IAAI,mBAAJ,C;8BACI,0B;6BAEJ,6B;4BANJ,oBAOI,I;;0BwBjQgB,2B;yBADJ,W;0BxB0Pb,MwBvPiB,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;;sBAIR,UAAQ,C;;;gBrBmO5B,SqB7NI,eAAe,KAAf,I;gBxB4OO,MGdX,sBAAa,EAAb,C;gBqB3NA,oBAAO,C;;;cxByOH,0B;cAYA,YAAY,YAAS,MGtWoB,iBHsWpB,MGtWoC,aAAhB,IHsW7B,K;cACZ,IAAI,QAAQ,CAAZ,C;gBACI,MAAO,gBAAO,KAAP,C;gBACH,mBAAW,MAAX,EAAmB,KAAnB,C;eAGR,SAAW,WAAQ,EAAZ,GAAgB,CAAhB,GAA4B,cAAL,MAAK,EAAc,CAAd,C;cuBpKvB,SvBqKZ,M;;4BuBnKoB,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,M;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,MAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;;WAIA,UAAU,I;UACV,UAAU,I;;QACL,iBAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IvB4IR,IAAI,SAAO,CAAX,C;MAAc,qBAAqB,MAArB,C;IAEd,OAAO,S;EACX,C;EAEA,yF;IAMI,kBAAc,QAAd,C;IACA,eAAW,CAAX,C;;MuB9Lc,gB;MADd,cAAc,I;MACA,uCAFuC,CAEvC,C;MAAA,iB;QAAqC,yB;OAAnD,cAAc,I;MACd,aAHqD,C;;;sBAOhC,O;UAAb,apBnMqC,sBAAgB,kBAAhB,I;UoBoMrC,S;UAEA,IAAI,UAAU,MAAd,C;;cAEe,aAAM,O;cvBuLX,qB;;gBwBpVlB,oBAAgB,CAAhB,C;gBACA,gBAAY,CAAZ,C;gBACA,wBAAoB,CAApB,C;gBrB8RS,aHoDE,MGpDI,O;gBAAN,YHoDE,MGpDY,a;gBAAd,mBHoDE,MGpD0B,c;gBqB3RjC,iBAAc,KAAd,UAA0B,YAA1B,U;kBACI,QAAQ,MnBtGL,KAAK,SmBsGO,KnBtGP,CmBsGA,GAA0B,G;kBAE9B,SAAM,GAAN,MAAc,CAAd,C;oBACI,IAAI,gBAAa,CAAjB,C;sBAAoB,mBAAmB,WAAnB,C;oBACf,SAAW,mBAAF,CAAE,E;oBAAX,mB;oBxB2Ub,IAAI,mCAAJ,C;sBAAA,kBACI,K;;sBAEA,IAAI,mBAAJ,C;wBACI,0B;uBAEJ,6B;sBACI,mBAAO,aAAP,C;sBAPR,kBAQI,I;;oBwBnVI,IAAI,gBAAJ,C;sBxB0UL,MwBzUS,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,E;sBAAP,sB;4BAGR,oBAAa,CAAb,C;oBAGI,WAAW,G;oBACX,UAAQ,C;oBAER,aAAU,CAAV,OAAa,CAAb,M;sBACI,IAAI,WAAU,IAAV,MAAkB,CAAtB,C;wBACI,UAAQ,UAAe,CAAL,I;wBAClB,OAAO,QAAS,C;wBAChB,iC;;wBAEA,K;;;oBAIR,kBAAgB,W;oBAChB,iC;oBAEA,IAAI,mBAAgB,eAAe,KAAf,IAAhB,CAAJ,C;sBxBkTL,MwBjTS,sBAAa,QAAQ,KAAR,IAAb,C;sBACA,oBAAO,e;sBAAP,sB;;oBAKJ,UAAS,WAAU,CAAX,GAAkB,IAAM,G;oBAChC,iC;oBAEA,IAAI,gBAAa,CAAjB,C;sBACI,IAAI,eAAe,OAAf,CAAJ,C;wBACS,WAAe,mBAAN,OAAM,E;wBAAf,qB;wBxBuSrB,IAAI,qCAAJ,C;0BAAA,oBACI,K;;0BAEA,IAAI,mBAAJ,C;4BACI,0B;2BAEJ,6B;0BACI,mBAAO,eAAP,C;0BAPR,oBAQI,I;;wBwB/SY,IAAI,kBAAJ,C;0BxBsSb,MwBrSiB,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;gCAED,IAAI,CAAC,iBAAiB,OAAjB,CAAL,C;wBACH,mBAAmB,OAAnB,C;;wBAEK,WAA8B,mBAArB,cAAc,OAAd,CAAqB,E;wBAA9B,qB;wBxBgSrB,IAAI,qCAAJ,C;0BAAA,oBACI,K;;0BAEA,IAAI,mBAAJ,C;4BACI,0B;2BAEJ,6B;0BACI,mBAAO,eAAP,C;0BAPR,oBAQI,I;;wBwBxSgB,+B;wBAAA,Y;0BACC,WAA6B,mBAApB,aAAa,OAAb,CAAoB,E;0BAA7B,qB;0BxB+RrB,IAAI,qCAAJ,C;4BAAA,oBACI,K;;4BAEA,IAAI,mBAAJ,C;8BACI,0B;6BAEJ,6B;4BACI,mBAAO,eAAP,C;4BAPR,oBAQI,I;;0BwBvSgB,2B;yBADJ,W;0BxB+Rb,MwB5RiB,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;0BACA,oBAAO,E;0BAAP,sB;;sBAIR,UAAQ,C;;;gBrBmO5B,SqB7NI,eAAe,KAAf,I;gBxBiRO,MGnDX,sBAAa,EAAb,C;gBqB3NA,oBAAO,C;;;cxB8QH,0B;cAaA,SAAW,WAAQ,EAAZ,GAAgB,CAAhB,GAA4B,cAAL,MAAK,EAAc,CAAd,C;cuBpMvB,SvBqMZ,M;;4BuBnMoB,O;cAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;YoB6MjC,QAAQ,M;;UAGZ,UAAU,K;UAGN,cAAS,CAAT,C;YAAc,wCAAoB,OAApB,C;;YACd,qBAAQ,M;YAAR,Y;4BAAgB,O;cAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;aAAjC,W;cACI,8BAAiB,OAAjB,C;cACA,yCAAqB,MAArB,C;;cAEI,gB;;UANZ,iB;UASA,IAAI,YAAJ,C;;WAIA,UAAU,I;UACV,UAAU,I;;QACL,iBAAO,CAAP,C;;QAET,IAAI,OAAJ,C;UACI,8BAAiB,OAAjB,C;;;;IvB4KR,IAAI,SAAO,CAAX,C;MAAc,qBAAqB,MAArB,C;IAEd,OAAO,S;EACX,C;EAEA,oC;IACI,MAAM,iCAA6B,iDAA8C,KAA9C,cAA7B,C;EACV,C;EAEA,oC;IAEI,MAAM,iBAAa,uCAAoC,IAApC,WAAb,C;G;EAEV,sC;IAEI,MAAM,iBAAa,uCAAoC,IAApC,sBAAb,C;G;EAEV,0D;IACI,MAAM,iBAAa,oCAAiC,eAAjC,iBAAb,C;G;2G0C9eV,yB;InD6UA,oC;ImD7UA,4B;MAC6C,OnDsVH,emDtVG,oBnDsVH,C;K;GmDvV1C,C;6GAGA,yB;IAAA,yD;IxDuVA,sC;IwDvVA,4B;MAC+C,OxDgWF,gBwDhWE,oBxDgWF,C;K;GwDjW7C,C;yGAGA,yB;IAAA,qD;IvDqXA,kC;IuDrXA,4B;MAC2C,OvD8XJ,cuD9XI,kBvD8XJ,C;K;GuD/XvC,C;2GAGA,yB;IAAA,uD;ItDiYA,oC;IsDjYA,4B;MAC6C,OtD0YH,esD1YG,mBtD0YH,C;K;GsD3Y1C,C;4GAGA,yB;IAAA,yD;IAAA,iD;MACmD,sB;QAAA,SAAc,C;MAAG,sB;QAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;MAC9E,qBAAU,GxB0lGH,QwB1lGP,EAA6B,MAA7B,EAAqC,MAArC,C;IACJ,C;GAHA,C;4GAKA,yB;IAAA,yD;IAAA,iD;MACoD,sB;QAAA,SAAc,C;MAAG,sB;QAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;MAC/E,qBAAU,GxBkpGH,QwBlpGP,EAA8B,MAA9B,EAAsC,MAAtC,C;IACJ,C;GAHA,C;4GAKA,yB;IAAA,yD;IAAA,iD;MACkD,sB;QAAA,SAAc,C;MAAG,sB;QAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;MAC7E,qBAAU,GxB2lGH,QwB3lGP,EAA4B,MAA5B,EAAoC,MAApC,C;IACJ,C;GAHA,C;4GAKA,yB;IAAA,yD;IAAA,iD;MACmD,sB;QAAA,SAAc,C;MAAG,sB;QAAA,SAAc,GAAI,KAAJ,GAAW,MAAX,I;MAC9E,qBAAU,GxB6nGH,QwB7nGP,EAA6B,MAA7B,EAAqC,MAArC,C;IACJ,C;GAHA,C;6GAKA,wB;IAEI,4BAAU,CnDsNyB,KmDtNnC,C;EACJ,C;+GAEA,yB;IAAA,2D;IAAA,+B;MAEI,sBAAW,CxD4N0B,KwD5NrC,C;IACJ,C;GAHA,C;2GAKA,yB;IAAA,uD;IAAA,+B;MAEI,oBAAS,CvDoPwB,KuDpPjC,C;IACJ,C;GAHA,C;6GAKA,yB;IAAA,yD;IAAA,+B;MAEI,qBAAU,CtD0PyB,KsD1PnC,C;IACJ,C;GAHA,C;8GAKA,yB;IAAA,2D;IAAA,mD;MACuD,sB;QAAA,SAAc,C;MAAG,sB;QAAA,SAAc,KAAM,KAAN,GAAa,MAAb,I;MAClF,sBAAW,KxBkjGJ,QwBljGP,EAAgC,MAAhC,EAAwC,MAAxC,C;IACJ,C;GAHA,C;8GAKA,yB;IAAA,2D;IAAA,mD;MACwD,sB;QAAA,SAAc,C;MAAG,sB;QAAA,SAAc,KAAM,KAAN,GAAa,MAAb,I;MACnF,sBAAW,KxB0mGJ,QwB1mGP,EAAiC,MAAjC,EAAyC,MAAzC,C;IACJ,C;GAHA,C;8GAKA,yB;IAAA,2D;IAAA,mD;MACsD,sB;QAAA,SAAc,C;MAAG,sB;QAAA,SAAc,KAAM,KAAN,GAAa,MAAb,I;MACjF,sBAAW,KxBmjGJ,QwBnjGP,EAA+B,MAA/B,EAAuC,MAAvC,C;IACJ,C;GAHA,C;8GAKA,yB;IAAA,2D;IAAA,mD;MACuD,sB;QAAA,SAAc,C;MAAG,sB;QAAA,SAAc,KAAM,KAAN,GAAa,MAAb,I;MAClF,sBAAW,KxBqlGJ,QwBrlGP,EAAgC,MAAhC,EAAwC,MAAxC,C;IACJ,C;GAHA,C;+FCrEA,4B;IACW,Q;;MACH,aAAM,SAAN,C;;MAEA,iB;;IAHJ,W;EAKJ,C;+FAEA,4B;IACW,Q;;MACH,aAAM,SAAN,C;;MAEA,iB;;IAHJ,W;EAKJ,C;E1CZA,kF;EAAA,uE;EAAA,kD;IAOgB,sC;IAAS,gC;G;EAPzB,2CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;E2CMA,6C;IAYI,eAAuB,a;G;EAZ3B,kDAcI,6B;IACI,OAAO,IAAK,Q;EAChB,C;EAhBJ,kDAkBI,oC;IACI,eAAa,K;EACjB,C;EApBJ;;;G;ECD6B,iD;IAuHzB,mC;IAnHA,kBAAO,MAAP,C;IADA,oC;I5CFA,IAAI,E4CKQ,WAAW,I5CLnB,CAAJ,C;MACI,oC4CIyB,uB5CJzB,C;MAKA,CAAE,S;K4CEN,yBAA+C,OAAO,IAAP,C;IAC/C,0BAAuB,SAAO,CAAP,C;IAEvB,iDAG0C,MAH1C,C;G;;;;SAAA,Y;aAAA,yE;K;SAAA,kB;MAII,iF;K;;;;SAO0B,Y;MAAQ,OAAA,sBAAQ,uB;K;SAC1C,oB;MACI,IAAI,gBAAJ,C;QACI,gB;;QAEA,0BAAW,QAAX,C;;IAER,C;;;;SAE2B,Y;MAAQ,OAAA,uBAAS,uB;K;;+CAEhD,iB;IACI,IAAI,CAAC,sBAAQ,wBAAc,IAAd,EAAoB,KAApB,CAAb,C;MACI,MAAM,2BAAsB,sCAAtB,C;KAEd,C;oCAEA,Y;IACI,OAAO,sBAAQ,oBAAU,IAAV,C;EACnB,C;oCAEA,Y;IAAyC,Q;IlD0DlC,gBkD1DkC,sCAAU,I;IAC/C,SAAU,kB;IACiC,gBAA3C,gBAAY,WAAZ,EAAoB,SAApB,EAA+B,uBAA/B,C;IACI,yBlDyCF,SkDzCE,C;IAHgC,OlD6CjC,S;G;0CkDtCP,gB;IAO4B,Q;IANxB,IAAI,sBAAJ,C;MACI,aAAa,W;MACb,IAAI,cAAJ,C;QACI,qB;QACA,MAAO,iBAAQ,IAAR,C;;QAEP,gBAAgB,kDAAc,I;QAC9B,SAAU,iBAAQ,IAAR,C;;KAGtB,C;yCAEA,Y;IACI,IAAI,CAAC,uBAAS,wBAAc,CAAd,EAAiB,EAAjB,CAAd,C;MACI,MAAM,2BAAsB,qCAAtB,C;KAGV,gB;IACA,cAAS,I;EACb,C;0CAEA,Y;IAIa,gBAAT,uB;;MCiRJ,OAAO,IAAP,C;QACI,UAAU,gC;QDjRN,ICkRe,GDlRX,IAAO,CAAX,C;UAAc,MAAM,2BAAsB,kDAAtB,C;QCkRxB,UAAmB,GDjRf,GAAM,CAAN,I;QCkRJ,IAAI,iCAAc,GAAd,EAAmB,GAAnB,CAAJ,C;UAA6B,kB;;;;EDhRjC,C;yCAEA,Y;IAIa,gBAAT,uB;;MCuQJ,OAAO,IAAP,C;QACI,UAAU,gC;QDvQN,ICwQe,GDxQX,GAAM,CAAV,C;UACI,MAAM,2BAAsB,6DAAtB,C;SAEV,ICqQe,GDrQX,GAAM,CAAV,C;UACI,MAAM,2BAAsB,mEAAtB,C;SCoQd,UDjQI,C;QCkQJ,IAAI,iCAAc,GAAd,EAAmB,GAAnB,CAAJ,C;UAA6B,kB;;;;EDhQjC,C;0CAEA,Y;IAKoB,gBAAT,uB;IAAS,uB;;MC4QpB,OAAO,IAAP,C;QACI,UAAU,gC;QD5QN,IC6Qe,GD7QX,IAAO,CAAX,C;UAAc,MAAM,2BAAsB,4CAAtB,C;QC6QxB,UAAmB,GD5Qf,GAAM,CAAN,I;QC6QJ,IAAI,iCAAc,GAAd,EAAmB,GAAnB,CAAJ,C;UAA6B,sBAAO,G;UAAP,wB;;;;ID/Q7B,OAAO,wBAGF,C;EACT,C;EAG4B,oC;IAAE,2C;EAAqC,C;gCADnE,Y;I5C7GA,IAAI,E4C8GQ,mB5C9GR,CAAJ,C;MACI,oC4C6GwB,wB5C7GxB,C;MAKA,CAAE,S;K4C0GI,iC;IAEN,kBAAa,I;IACb,gDAAgB,I;EACpB,C;EAEA,iC;IAAA,qC;IACI,0D;IAyBA,oE;IAgBA,sE;IAeA,oG;G;;;SAjC8B,Y;MAAQ,OAAA,gCAAS,M;K;;EAvBJ,oD;G;;;SAEnC,Y;MAAQ,OAAA,wBAAyB,S;K;;8DAErC,Y;IACI,OAAO,wBAAyB,S;EACpC,C;uEAEA,oB;IAEI,IAAI,kCAAJ,C;MACI,MAAM,8BAAyB,0CAAzB,C;KAGV,wBAAyB,iBAAQ,QAAR,C;EAC7B,C;+DAEA,Y;IACI,wBAAyB,U;EAC7B,C;;;;;EAS4C,yD;G;;;SACjB,Y;MAAQ,Q;K;;mEAEnC,Y;IAAwB,gD;G;EAGoB,wE;IAAE,2D;EAAqD,C;4EADnG,oB;I5CxJR,IAAI,E4CyJgB,aAAa,mCAAY,M5CzJzC,CAAJ,C;MACI,oC4CwJgD,4D5CxJhD,C;MAKA,CAAE,S;K4CoJE,C;oEAEA,Y;EACA,C;;;;;EAI2C,sD;IAAS,qB;G;gEACpD,Y;IACqC,IAAkC,I;IAAnE,OAAO,aAAS,8BAAiB,eAAM,IAAN,CAA1B,EAAsD,IAAtD,EAA4D,0DAA5D,C;EACX,C;yEAEA,oB;IACI,IAAI,kCAAJ,C;MACI,MAAM,8BAAyB,0CAAzB,C;KAGV,8BAAiB,cAAK,QAAS,OAAd,C;EACrB,C;;;;;EAG0D,qE;IAAS,qB;G;+EACnE,Y;IACI,MAAM,mCAA8B,kCAA9B,C;EACV,C;wFAEA,oB;EAEA,C;;;;;;;;;;;EAhER,6C;IAAA,4C;MAAA,2B;KAAA,qC;G;EAjH6B,mC;IAAE,8C;EAAwC,C;;;;;;EAsL3E,uC;IAMyD,oCAAkB,C;G;sH/BzM3E,yB;IAAA,8F;IAAA,kC;MAGI,IAAI,wBAAQ,UAAZ,C;QAA2B,wBAAwB,SAAxB,EAA8B,IAA9B,C;MAC3B,OAAO,iB;IACX,C;GALA,C;EAOA,8C;IAEI,MAAM,8BAAyB,gBAAa,KAAb,uBAAuB,IAAvB,qCAAzB,C;G;gHbPV,yB;IAAA,uF;IAAA,kF;IAAA,kC;IAAA,gF;IAAA,mE;IAAA,gD;MAOgB,sC;MAAS,gC;K;IAPzB,yCAQY,Y;MACI,MAAM,8BAAyB,sBAAzB,C;IACV,C;IAVZ;;;K;IAAA,qC;MAMI,IAAI,CAAC,SAAL,C;QACI,0C;QAKA,CAAE,S;OAEV,C;GAdA,C;EAgBA,iC;G;;;;;;EAhBA,kF;EAAA,uE;EAAA,kD;IAOgB,sC;IAAS,gC;G;EAPzB,2CAQY,Y;IACI,MAAM,8BAAyB,sBAAzB,C;EACV,C;EAVZ;;;G;sHuBEA,yB;IAAA,0B;IAAA,oC;IAAA,sC;MrBqZa,aAAM,gB;MAAN,YAAc,sB;MAAd,mBAA4B,uB;MqBnZjC,iBAAc,KAAd,UAA0B,YAA1B,U;QACI,gBAAgB,MnBkBb,KAAK,SmBlBe,KnBkBf,CmBlBQ,GAA0B,G;QAC1C,IAAI,aAAc,GAAd,MAAsB,GAAtB,IAA8B,CAAC,SAAmB,mBAAV,SAAU,EAAnB,CAAnC,C;UACI,+BAAa,QAAQ,KAAR,IAAb,C;UACA,OAAO,K;;MrB+YnB,SqB3YI,eAAe,KAAf,I;MrB4YJ,+BAAa,EAAb,C;MqBzYA,OAAO,I;IACX,C;GAdA,C;EAgBA,0F;IAAA,wC;IAAA,yB;IAAA,wB;IAAA,2B;IAAA,wB;IAAA,sB;IAAA,uB;IAAA,sB;IAAA,0B;IAAA,kC;EA8DA,C;;;;;;;;2DA9DA,Y;;;;;qCAMkB,C;kCACH,C;gCACF,K;iCACC,K;YAEV,gB;;;;;YAAA,IAAQ,gBAAR,IAAe,iBAAf,KAAuB,CAAvB,C;cAAA,gB;;;YACgB,gB;4BAAA,qBAAU,iBAAV,O;gBAAA,qC;qBAAA,mB;YAAA,Q;;YAAA,+B;YAAA,4B;;;;cAAA,gB;;;;;YAAZ,YAAY,e;;cD4OF,gB;cADd,cAAc,I;cACA,4BC3OV,KD2OU,EAFuC,CAEvC,C;cAAA,iB;gBAAqC,yB;eAAnD,cAAc,I;cACd,WAHqD,C;;;8BAOhC,O;kBAAb,apBnMqC,sBAAgB,kBAAhB,I;kBoBoMrC,S;kBAEA,IAAI,UAAU,IAAd,C;;sBAEe,aAAM,O;sBCpPrB,eAAW,CAAX,C;sBACc,qB;;wBAsFtB,oBAAgB,CAAhB,C;wBACA,gBAAY,CAAZ,C;wBACA,wBAAoB,CAApB,C;wBrB8RS,aqBtXM,MrBsXA,O;wBAAN,YqBtXM,MrBsXQ,a;wBAAd,mBqBtXM,MrBsXsB,c;sCqB3RjC,iBAAc,KAAd,UAA0B,YAA1B,U;0BACI,QAAQ,MnBtGL,KAAK,SmBsGO,KnBtGP,CmBsGA,GAA0B,G;0BAE9B,SAAM,GAAN,MAAc,CAAd,C;4BACI,IAAI,gBAAa,CAAjB,C;8BAAoB,mBAAmB,WAAnB,C;4BACf,SAAW,mBAAF,CAAE,E;4BAAX,mB;;8BA/FT,QAAM,aAAN,C;qCACI,E;kCACI,IAAI,eAAJ,C;oCACI,mBAAM,I;oCACN,kBAAkB,K;oCAAlB,oB;;kCAEJ,kBAAK,I;kCANb,kBAOQ,I;kCAPR,oB;qCASI,E;kCACI,mBAAM,I;kCACN,SAAO,C;kCAXf,kBAYQ,K;kCAZR,oB;wCAeQ,IAAI,eAAJ,C;oCACI,mBAAM,I;oCACN,kBAAkB,K;oCAAlB,oB;;kCAGJ,IAAI,yCAAJ,C;oCACI,MAAM,yBAAqB,sEAArB,C;;kCAEV,mD;kCACI,8BAAO,aAAP,C;kCAxBZ,kBAyBQ,I;kCAzBR,oB;;;;4BA+FI,IAAI,gBAAJ,C;8BAhGD,MAiGK,sBAAa,QAAQ,KAAR,IAAb,C;8BACA,oBAAO,E;8BAAP,sB;oCAGR,oBAAa,CAAb,C;4BAGI,WAAW,G;4BACX,UAAQ,C;4BAER,aAAU,CAAV,OAAa,CAAb,M;8BACI,IAAI,WAAU,IAAV,MAAkB,CAAtB,C;gCACI,UAAQ,UAAe,CAAL,I;gCAClB,OAAO,QAAS,C;gCAChB,iC;;gCAEA,K;;;4BAIR,kBAAgB,W;4BAChB,iC;4BAEA,IAAI,mBAAgB,eAAe,KAAf,IAAhB,CAAJ,C;8BAxHD,MAyHK,sBAAa,QAAQ,KAAR,IAAb,C;8BACA,oBAAO,e;8BAAP,sB;;4BAKJ,UAAS,WAAU,CAAX,GAAkB,IAAM,G;4BAChC,iC;4BAEA,IAAI,gBAAa,CAAjB,C;8BACI,IAAI,eAAe,OAAf,CAAJ,C;gCACS,WAAe,mBAAN,OAAM,E;gCAAf,qB;;kCAnIjB,QAAM,eAAN,C;yCACI,E;sCACI,IAAI,eAAJ,C;wCACI,mBAAM,I;wCACN,oBAAkB,K;wCAAlB,oB;;sCAEJ,kBAAK,I;sCANb,oBAOQ,I;sCAPR,oB;yCASI,E;sCACI,mBAAM,I;sCACN,SAAO,C;sCAXf,oBAYQ,K;sCAZR,oB;4CAeQ,IAAI,eAAJ,C;wCACI,mBAAM,I;wCACN,oBAAkB,K;wCAAlB,oB;;sCAGJ,IAAI,yCAAJ,C;wCACI,MAAM,yBAAqB,sEAArB,C;;sCAEV,mD;sCACI,8BAAO,eAAP,C;sCAxBZ,oBAyBQ,I;sCAzBR,oB;;;;gCAmIY,IAAI,kBAAJ,C;kCApIT,MAqIa,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;kCACA,oBAAO,E;kCAAP,sB;wCAED,IAAI,CAAC,iBAAiB,OAAjB,CAAL,C;gCACH,mBAAmB,OAAnB,C;;gCAEK,WAA8B,mBAArB,cAAc,OAAd,CAAqB,E;gCAA9B,qB;;kCA1IjB,QAAM,eAAN,C;yCACI,E;sCACI,IAAI,eAAJ,C;wCACI,mBAAM,I;wCACN,oBAAkB,K;wCAAlB,oB;;sCAEJ,kBAAK,I;sCANb,oBAOQ,I;sCAPR,oB;yCASI,E;sCACI,mBAAM,I;sCACN,SAAO,C;sCAXf,oBAYQ,K;sCAZR,oB;4CAeQ,IAAI,eAAJ,C;wCACI,mBAAM,I;wCACN,oBAAkB,K;wCAAlB,oB;;sCAGJ,IAAI,yCAAJ,C;wCACI,MAAM,yBAAqB,sEAArB,C;;sCAEV,mD;sCACI,8BAAO,eAAP,C;sCAxBZ,oBAyBQ,I;sCAzBR,oB;;;;gCA0IgB,+B;gCAAA,Y;kCACC,WAA6B,mBAApB,aAAa,OAAb,CAAoB,E;kCAA7B,qB;;oCA3IjB,QAAM,eAAN,C;2CACI,E;wCACI,IAAI,eAAJ,C;0CACI,mBAAM,I;0CACN,oBAAkB,K;0CAAlB,oB;;wCAEJ,kBAAK,I;wCANb,oBAOQ,I;wCAPR,oB;2CASI,E;wCACI,mBAAM,I;wCACN,SAAO,C;wCAXf,oBAYQ,K;wCAZR,oB;8CAeQ,IAAI,eAAJ,C;0CACI,mBAAM,I;0CACN,oBAAkB,K;0CAAlB,oB;;wCAGJ,IAAI,yCAAJ,C;0CACI,MAAM,yBAAqB,sEAArB,C;;wCAEV,mD;wCACI,8BAAO,eAAP,C;wCAxBZ,oBAyBQ,I;wCAzBR,oB;;;;kCA2IgB,2B;iCADJ,W;kCA3IT,MA8Ia,sBAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;kCACA,oBAAO,E;kCAAP,sB;;8BAIR,UAAQ,C;;;wBrBmO5B,SqB7NI,eAAe,KAAf,I;wBAzJW,MrBuXf,sBAAa,EAAb,C;wBqB3NA,oBAAO,C;;;sBA5JC,qC;sBA+BA,IAAI,SAAO,CAAX,C;wBACI,MAAO,sBAAa,MAAb,C;uBAGX,oBAAW,gBAAJ,GAAS,CAAT,GAAqB,cAAL,iBAAK,EAAc,CAAd,C;sBDgNpB,OC9MR,iB;;oCDgNgB,O;sBAAR,QpB1M6B,wBAAgB,oBAAhB,I;;;oBoB6MjC,QAAQ,M;;kBAGZ,UAAU,K;kBAGN,cAAS,CAAT,C;oBAAc,6BChQtB,KDgQsB,EAAoB,OAApB,C;;oBACd,qBAAQ,I;oBAAR,Y;oCAAgB,O;sBAAA,UpB9NU,mBAAW,aAAX,IoB8NV,IAAiB,C;qBAAjC,W;sBACI,mBClQZ,KDkQY,EAAiB,OAAjB,C;sBACA,8BCnQZ,KDmQY,EAAqB,IAArB,C;;sBAEI,gB;;kBANZ,iB;kBASA,IAAI,YAAJ,C;;mBAIA,UAAU,I;kBACV,UAAU,I;;gBACL,eAAO,CAAP,C;;gBAET,IAAI,OAAJ,C;kBACI,mBCjRJ,KDiRI,EAAiB,OAAjB,C;;;;YCnRR,gB;;;YA6CA,IAAI,oBAAO,CAAX,C;cAAc,wBAAwB,iBAAxB,C;YACd,IAAI,eAAJ,C;cACI,mBAAM,I;;YAGV,OAAO,uBAAU,CAAV,IAAe,gB;;;;;;;;;;;;;;EAC1B,C;EA9DA,2F;mBAAA,oF;QAAA,S;aAAA,Q;;aAAA,uB;EA8DA,C;EAEA,uC;IACI,MAAM,iBAAa,uCAAoC,IAApC,gCAAb,C;G;EAEV,kC;IAEI,gBAAgB,C;IAChB,WAAW,G;IACX,YAAY,S;IAEZ,aAAU,CAAV,OAAa,CAAb,M;MACI,IAAI,SAAU,IAAV,MAAkB,CAAtB,C;QACI,QAAQ,QAAe,CAAL,I;QAClB,OAAO,QAAS,C;QAChB,6B;;QAEA,K;;;IAIR,OAAO,S;EACX,C;oHAEA,yB;IAAA,2C;IAAA,8B;IAMA,oF;IAAA,0B;IAAA,oC;IAAA,4E;IAAA,gF;IAAA,oF;IAAA,0E;IAAA,wE;IANA,sC;MAGY,Q;MAAgB,kBAAhB,2D;MAAgB,qB;;QAYxB,oBAAgB,CAAhB,C;QACA,gBAAY,CAAZ,C;QACA,wBAAoB,CAApB,C;QrB8RS,aAAM,kB;QAAN,YAAc,wB;QAAd,mBAA4B,yB;QqB3RjC,iBAAc,KAAd,UAA0B,YAA1B,U;UACI,QAAQ,MnBtGL,KAAK,SmBsGO,KnBtGP,CmBsGA,GAA0B,G;UAE9B,SAAM,GAAN,MAAc,CAAd,C;YACI,IAAI,gBAAa,CAAjB,C;cAAoB,mBAAmB,WAAnB,C;YACpB,IAAI,CAtBe,QAsBd,CAAW,mBAAF,CAAE,EAAX,CAAL,C;cACI,iCAAa,QAAQ,KAAR,IAAb,C;cACA,oBAAO,E;cAAP,sB;oBAGR,oBAAa,CAAb,C;YAGI,WAAW,G;YACX,UAAQ,C;YAER,aAAU,CAAV,OAAa,CAAb,M;cACI,IAAI,WAAU,IAAV,MAAkB,CAAtB,C;gBACI,UAAQ,UAAe,CAAL,I;gBAClB,OAAO,QAAS,C;gBAChB,iC;;gBAEA,K;;;YAIR,kBAAgB,W;YAChB,iC;YAEA,IAAI,mBAAgB,eAAe,KAAf,IAAhB,CAAJ,C;cACI,iCAAa,QAAQ,KAAR,IAAb,C;cACA,oBAAO,e;cAAP,sB;;YAKJ,UAAS,WAAU,CAAX,GAAkB,IAAM,G;YAChC,iC;YAEA,IAAI,gBAAa,CAAjB,C;cACI,IAAI,eAAe,OAAf,CAAJ,C;gBACI,IAAI,CA1DO,QA0DN,CAAe,mBAAN,OAAM,EAAf,CAAL,C;kBACI,iCAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;kBACA,oBAAO,E;kBAAP,sB;wBAED,IAAI,CAAC,iBAAiB,OAAjB,CAAL,C;gBACH,mBAAmB,OAAnB,C;;gBAEA,IAAI,CAjEO,QAiEN,CAA8B,mBAArB,cAAc,OAAd,CAAqB,EAA9B,CAAD,IACA,CAlEO,QAkEN,CAA6B,mBAApB,aAAa,OAAb,CAAoB,EAA7B,CADL,C;kBAGI,iCAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;kBACA,oBAAO,E;kBAAP,sB;;cAIR,UAAQ,C;;;QrBmO5B,SqB7NI,eAAe,KAAf,I;QrB8NJ,iCAAa,EAAb,C;QqB3NA,oBAAO,C;;;MAlFP,wB;IACJ,C;GAJA,C;sHAMA,yB;IAAA,oF;IAAA,0B;IAAA,oC;IAAA,4E;IAAA,gF;IAAA,oF;IAAA,0E;IAAA,wE;IAAA,sC;MASI,oBAAgB,CAAhB,C;MACA,gBAAY,CAAZ,C;MACA,wBAAoB,CAApB,C;MrB8RS,aAAM,gB;MAAN,YAAc,sB;MAAd,mBAA4B,uB;MqB3RjC,iBAAc,KAAd,UAA0B,YAA1B,U;QACI,QAAQ,MnBtGL,KAAK,SmBsGO,KnBtGP,CmBsGA,GAA0B,G;QAE9B,SAAM,GAAN,MAAc,CAAd,C;UACI,IAAI,gBAAa,CAAjB,C;YAAoB,mBAAmB,WAAnB,C;UACpB,IAAI,CAAC,SAAW,mBAAF,CAAE,EAAX,CAAL,C;YACI,+BAAa,QAAQ,KAAR,IAAb,C;YACA,OAAO,E;kBAGf,oBAAa,CAAb,C;UAGI,WAAW,G;UACX,UAAQ,C;UAER,aAAU,CAAV,OAAa,CAAb,M;YACI,IAAI,WAAU,IAAV,MAAkB,CAAtB,C;cACI,UAAQ,UAAe,CAAL,I;cAClB,OAAO,QAAS,C;cAChB,iC;;cAEA,K;;;UAIR,kBAAgB,W;UAChB,iC;UAEA,IAAI,mBAAgB,eAAe,KAAf,IAAhB,CAAJ,C;YACI,+BAAa,QAAQ,KAAR,IAAb,C;YACA,OAAO,e;;UAKX,UAAS,WAAU,CAAX,GAAkB,IAAM,G;UAChC,iC;UAEA,IAAI,gBAAa,CAAjB,C;YACI,IAAI,eAAe,OAAf,CAAJ,C;cACI,IAAI,CAAC,SAAe,mBAAN,OAAM,EAAf,CAAL,C;gBACI,+BAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;gBACA,OAAO,E;sBAER,IAAI,CAAC,iBAAiB,OAAjB,CAAL,C;cACH,mBAAmB,OAAnB,C;;cAEA,IAAI,CAAC,SAA8B,mBAArB,cAAc,OAAd,CAAqB,EAA9B,CAAD,IACA,CAAC,SAA6B,mBAApB,aAAa,OAAb,CAAoB,EAA7B,CADL,C;gBAGI,+BAAa,QAAQ,KAAR,GAAgB,eAAhB,GAAgC,CAAhC,IAAb,C;gBACA,OAAO,E;;YAIf,UAAQ,C;;;MrBmO5B,SqB7NI,eAAe,KAAf,I;MrB8NJ,+BAAa,EAAb,C;MqB3NA,OAAO,C;IACX,C;GAhFA,C;EAmFgC,kD;IAC5B,oB;IACA,sB;IACA,8B;G;;SAAA,Y;MAAA,4B;K;;2CAEA,iB;IACI,IAAI,SAAS,WAAb,C;MACI,wBAAiB,KAAjB,C;KAEJ,OAAO,aAAM,QAAQ,aAAR,IAAN,C;EACX,C;EAG6B,kE;IAAA,mB;MAAE,8CAAoC,kB;IAAY,C;G;EAC7C,4F;IAAA,mB;MAAE,qCAA2B,kBAA3B,WAAyC,6B;IAAQ,C;G;EACxC,0F;IAAA,mB;MAAE,mCAAyB,gBAAzB,WAAqC,6B;IAAQ,C;G;EACxD,sF;IAAA,mB;MAAE,+DAAqD,kBAArD,WAAmE,gB;IAAU,C;G;oDAJnH,gC;IvBvMA,IAAI,EuBwMQ,cAAc,CvBxMtB,CAAJ,C;MACI,oCuBuMyB,gDvBvMzB,C;MAKA,CAAE,S;KANN,IAAI,EuByMQ,cAAc,WvBzMtB,CAAJ,C;MACI,sCuBwM8B,wDvBxM9B,C;MAKA,GAAE,S;KANN,IAAI,EuB0MQ,cAAa,QAAb,SAAyB,WvB1MjC,CAAJ,C;MACI,sCuByMyC,sDvBzMzC,C;MAKA,GAAE,S;KANN,IAAI,EuB2MQ,YAAY,UvB3MpB,CAAJ,C;MACI,sCuB0MgC,4DvB1MhC,C;MAKA,GAAE,S;KuBuMF,OAAO,sBAAkB,YAAlB,EAAyB,gBAAS,UAAT,IAAzB,EAA8C,WAAW,UAAX,IAA9C,C;EACX,C;mDAEA,iB;IACI,MAAM,8BAA0B,iCAA8B,KAA9B,WAAuC,WAAjE,C;EACV,C;;;;;;EAI8B,6B;IAAC,kB;G;;;mHAGD,yB;MZ7KK,4B;M1BwSvC,sC;MsC3HkC,mB;QAAQ,OtCqIG,gB0BlTiB,QY6KpB,UZ7KM,KAAU,EAAI,C1BkTjB,C;O;KsCrIX,C;;;;8GACL,yB;MZ3KS,4B;M1BqStC,sC;MsC1H6B,mB;QAAQ,OtCoIQ,gB0B/SmB,QY2K3B,UZ3KU,GAAS,KAAQ,C1B+SnB,C;O;KsCpIhB,C;;4IAEzB,yB;IZhLmC,4B;I1BwSvC,sC;IsCxHI,mB;MAA2C,OtCkIF,gB0BlTiB,QY6KpB,UZ7KM,KAAU,EAAI,C1BkTjB,C;K;GsClIzC,C;4IACA,yB;IZ9KkC,4B;I1BqStC,sC;IsCvHI,mB;MAA2C,OtCiIF,gB0B/SmB,QY2K3B,UZ3KU,GA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AQT,C;GALA,C;+GAOA,oC;IAII,cAAK,YAAW,MAAX,EAAmB,KAAnB,EAAyC,KAAzC,C;EACT,C;iHAEA,yB;IsB5EA,8F;ItB4EA,2C;MAII,yB;MsB7EA,ItB6EgB,MsB7EZ,eAAQ,UAAZ,C;QAA2B,wBtB6EX,MsB7EW,EtB6EQ,QsB7ER,C;MtB6EtB,gBAAW,MsB5ET,QtB4EF,EAAyC,KAAzC,EAA+D,KAA/D,C;IACT,C;GALA,C;iHAOA,oC;IAII,cAAK,YAAW,MAAX,EAAmB,KAAnB,EAAyC,KAAzC,C;EACT,C;mHAEA,yB;IsB1FA,8F;ItB0FA,2C;MAII,yB;MsB3FA,ItB2FgB,MsB3FZ,eAAQ,UAAZ,C;QAA2B,wBtB2FX,MsB3FW,EtB2FQ,QsB3FR,C;MtB2FtB,gBAAW,MsB1FT,QtB0FF,EAAyC,KAAzC,EAA+D,KAA/D,C;IACT,C;GALA,C;;EwElFA,kF;IAQI,iC;MAAA,oB/CiDyB,C;I+ChDzB,qB;MAAA,Q/CiDa,WAAY,OAAZ,GAAmB,iBAAnB,I;I+C/Cb,YAAY,eAAW,cAAK,OAAhB,EAAwB,cAAK,WAAL,GAAkB,MAAlB,IAAxB,EAAkD,KAAlD,C;IAEZ,IAAI,sBAAJ,C;MrEkIA,iBAAc,CAAd,UqEhIW,KrEgIX,U;QqE/HQ,YrEgIG,KqEhIS,wBAAZ,IAAsD,mBCw/BH,MtEx3BhD,KsEw3BgD,CDx/BG,C;;;MrE+H9D,mBAAc,CAAd,YqE5HW,KrE4HX,Y;QqE3HQ,YrE4HG,OqE5HS,wBAAZ,ICo/BmD,MtEx3BhD,OsEw3BgD,C;;;EDj/B/D,C;EAEA,oF;IAQI,iC;MAAA,oB/CoCyB,C;I+CnCzB,qB;MAAA,Q/CoCa,WAAY,OAAZ,GAAmB,iBAAnB,I;IH3Eb,IkDyCe,MlDzCX,eAAQ,UAAZ,C;MAA2B,wBkDyCZ,MlDzCY,EkDyCO,QlDzCP,C;IkDyC3B,0BAAe,MlDxCR,QkDwCP,EAA6C,WAA7C,EAA0D,iBAA1D,EAA6E,KAA7E,C;EACJ,C;EAEA,gF;IAQI,iC;MAAA,oB/C8DyB,C;I+C7DzB,qB;MAAA,Q/C8Da,WAAY,OAAZ,GAAmB,iBAAnB,I;I+C5Db,YAAY,eAAW,cAAK,OAAhB,EAAwB,cAAK,WAAL,GAAkB,MAAlB,IAAxB,EAAkD,KAAlD,C;IAEZ,IAAI,sBAAJ,C;MrE2FA,iBAAc,CAAd,UqE1FW,KrE0FX,U;QqEzFQ,YrE0FG,KqE1FS,wBAAZ,IAAsD,mBCwgCL,MtE96B9C,KsE86B8C,CDxgCK,C;;;MrEyF9D,mBAAc,CAAd,YqEtFW,KrEsFX,Y;QqErFQ,YrEsFG,OqEtFS,wBAAZ,ICogCiD,MtE96B9C,OsE86B8C,C;;;EDjgC7D,C;EAEA,kF;IAQI,iC;MAAA,oB/CkDyB,C;I+CjDzB,qB;MAAA,Q/CkDa,WAAY,OAAZ,GAAmB,iBAAnB,I;IH/Hb,IkD+Ea,MlD/ET,eAAQ,UAAZ,C;MAA2B,wBkD+Ed,MlD/Ec,EkD+EK,QlD/EL,C;IkD+E3B,wBAAa,MlD9EN,QkD8EP,EAA2C,WAA3C,EAAwD,iBAAxD,EAA2E,KAA3E,C;EACJ,C;EAEA,iF;IAQI,iC;MAAA,oB/C4EyB,C;I+C3EzB,qB;MAAA,Q/C4Ea,WAAY,OAAZ,GAAmB,iBAAnB,I;I+CvEa,UAMA,M;IAT1B,YAAY,eAAW,cAAK,OAAhB,EAAwB,cAAK,WAAL,GAAkB,MAAlB,IAAxB,EAAkD,QAAQ,CAAR,IAAlD,C;IAEZ,IAAI,sBAAJ,C;MAC0B,eAAQ,CAAR,I;MAAtB,iBAAc,CAAd,yBAAqC,CAArC,C;QACI,YAAY,SAAQ,CAAR,QAAY,iBAAZ,IAAZ,IACyC,oBAAnB,mBAAjB,KCi+B4C,CDj+BtC,QAAQ,CAAR,ICi+BsC,CDj+B3B,CAAmB,CAApC,iBAAD,IACiC,oBAAnB,mBAAb,KCg+B4C,CDh+BtC,KCg+BsC,CDh+B/B,CAAmB,CAAhC,WAA6C,EAA7C,CADD,C;;;MAIc,iBAAQ,CAAR,I;MAAtB,mBAAc,CAAd,+BAAqC,CAArC,C;QACI,YAAY,WAAQ,CAAR,QAAY,iBAAZ,IAAZ,IAA2D,oBAAb,KC49BG,CD59BG,OC49BH,CD59BU,CAAb,iBAAD,IACvB,oBAAjB,KC29B4C,CD39BtC,UAAQ,CAAR,IC29BsC,CD39B3B,CAAjB,WAA8B,EAA9B,CADwC,C;;;EAIzD,C;EAEA,mF;IAQI,iC;MAAA,oB/C6DyB,C;I+C5DzB,qB;MAAA,Q/C6Da,WAAY,OAAZ,GAAmB,iBAAnB,I;IHnLb,IkDwHc,MlDxHV,eAAQ,UAAZ,C;MAA2B,wBkDwHb,MlDxHa,EkDwHM,QlDxHN,C;IkDwH3B,yBAAc,MlDvHP,QkDuHP,EAA4C,WAA5C,EAAyD,iBAAzD,EAA4E,KAA5E,C;EACJ,C;EAEA,kF;IAQI,iC;MAAA,oB/CuFyB,C;I+CtFzB,qB;MAAA,Q/CuFa,WAAY,OAAZ,GAAmB,iBAAnB,I;I+CrFb,YAAY,iBAAa,cAAK,OAAlB,EAA0B,cAAK,WAAL,GAAkB,MAAlB,IAA1B,EAAoD,KAApD,C;IAEZ,IAAI,sBAAJ,C;MrEYA,iBAAc,CAAd,UqEXW,KrEWX,U;QqEVQ,YrEWG,KqEXS,wBAAZ,IAAsD,mBC++BD,MtEp+BlD,KsEo+BkD,CD/+BC,C;;;MrEU9D,mBAAc,CAAd,YqEPW,KrEOX,Y;QqENQ,YrEOG,OqEPS,wBAAZ,IC2+BqD,MtEp+BlD,OsEo+BkD,C;;;EDx+BjE,C;EAEA,oF;IAQI,iC;MAAA,oB/C2EyB,C;I+C1EzB,qB;MAAA,Q/C2Ea,WAAY,OAAZ,GAAmB,iBAAnB,I;IHvOb,IkD8Je,MlD9JX,eAAQ,UAAZ,C;MAA2B,wBkD8JZ,MlD9JY,EkD8JO,QlD9JP,C;IkD8J3B,0BAAe,MlD7JR,QkD6JP,EAA6C,WAA7C,EAA0D,iBAA1D,EAA6E,KAA7E,C;EACJ,C;EAEA,mF;IAQI,iC;MAAA,oB/CyEyB,C;I+CxEzB,qB;MAAA,Q/CyEa,WAAY,OAAZ,GAAmB,iBAAnB,I;I+CvEb,YAAY,iBAAa,cAAK,OAAlB,EAA0B,cAAK,WAAL,GAAkB,MAAlB,IAA1B,EAAoD,KAApD,C;IAEZ,IAAI,sBAAJ,C;MrE1BA,iBAAc,CAAd,UqE2BW,KrE3BX,U;QqE4BQ,YrE3BG,KqE2BS,wBAAZ,IAAsD,mBCo+BA,MtE//BnD,KsE+/BmD,CDp+BA,C;;;MrE5B9D,mBAAc,CAAd,YqE+BW,KrE/BX,Y;QqEgCQ,YrE/BG,OqE+BS,wBAAZ,ICg+BsD,MtE//BnD,OsE+/BmD,C;;;ED79BlE,C;EAEA,qF;IAQI,iC;MAAA,oB/C6DyB,C;I+C5DzB,qB;MAAA,Q/C6Da,WAAY,OAAZ,GAAmB,iBAAnB,I;IH/Pb,IkDoMgB,MlDpMZ,eAAQ,UAAZ,C;MAA2B,wBkDoMX,MlDpMW,EkDoMQ,QlDpMR,C;IkDoM3B,2BAAgB,MlDnMT,QkDmMP,EAA8C,WAA9C,EAA2D,iBAA3D,EAA8E,KAA9E,C;EACJ,C;EAEA,yE;IAQI,4B;MAAA,e/CmHoB,C;I+ClHpB,qB;MAAA,Q/CmHa,MAAO,OAAP,GAAc,YAAd,I;I+CjHb,YAAY,eAAW,cAAK,OAAhB,EAAwB,cAAK,WAAL,GAAkB,MAAlB,IAAxB,EAAkD,KAAlD,C;IAEZ,IAAI,sBAAJ,C;MrEhEA,iBAAc,CAAd,UqEkEW,KrElEX,U;QsE43BkE,MtE33BvD,KsE23BuD,IDzzBd,mBAA7B,OrElEZ,KqEkEmB,mBAAP,CAA6B,C;;;MrEnEpD,mBAAc,CAAd,YqEsEW,KrEtEX,Y;QsE43BkE,MtE33BvD,OsE23BuD,IDrzB3C,OrEtEZ,OqEsEmB,mBAAP,C;;;EAG3B,C;EAEA,2E;IAQI,4B;MAAA,e/CsGoB,C;I+CrGpB,qB;MAAA,Q/CsGa,MAAO,OAAP,GAAc,YAAd,I;IH/Ub,IkD2OgB,MlD3OZ,eAAQ,UAAZ,C;MAA2B,wBkD2OX,MlD3OW,EkD2OQ,QlD3OR,C;IkD2O3B,2BAAgB,MlD1OT,QkD0OP,EAA8C,MAA9C,EAAsD,YAAtD,EAAoE,KAApE,C;EACJ,C;EAEA,uE;IAQI,4B;MAAA,e/CgIoB,C;I+C/HpB,qB;MAAA,Q/CgIa,MAAO,OAAP,GAAc,YAAd,I;I+C9Hb,YAAY,eAAW,cAAK,OAAhB,EAAwB,cAAK,WAAL,GAAkB,MAAlB,IAAxB,EAAkD,KAAlD,C;IAEZ,IAAI,sBAAJ,C;MrEvGA,iBAAc,CAAd,UqEwGW,KrExGX,U;QsEk7BgE,MtEj7BrD,KsEi7BqD,IDz0BZ,mBAA7B,OrExGZ,KqEwGmB,mBAAP,CAA6B,C;;;MrEzGpD,mBAAc,CAAd,YqE4GW,KrE5GX,Y;QsEk7BgE,MtEj7BrD,OsEi7BqD,IDr0BzC,OrE5GZ,OqE4GmB,mBAAP,C;;;EAG3B,C;EAEA,yE;IAQI,4B;MAAA,e/CoHoB,C;I+CnHpB,qB;MAAA,Q/CoHa,MAAO,OAAP,GAAc,YAAd,I;IHnYb,IkDiRc,MlDjRV,eAAQ,UAAZ,C;MAA2B,wBkDiRb,MlDjRa,EkDiRM,QlDjRN,C;IkDiR3B,yBAAc,MlDhRP,QkDgRP,EAA4C,MAA5C,EAAoD,YAApD,EAAkE,KAAlE,C;EACJ,C;EAEA,wE;IAQI,4B;MAAA,e/C8IoB,C;I+C7IpB,qB;MAAA,Q/C8Ia,MAAO,OAAP,GAAc,YAAd,I;I+CzIa,UAOA,M;IAV1B,YAAY,eAAW,cAAK,OAAhB,EAAwB,cAAK,WAAL,GAAkB,MAAlB,IAAxB,EAAkD,QAAQ,CAAR,IAAlD,C;IAEZ,IAAI,sBAAJ,C;MAC0B,eAAQ,CAAR,I;MAAtB,iBAAc,CAAd,yBAAqC,CAArC,C;QACI,kBAAkB,SAAQ,CAAR,QAAY,YAAZ,I;QAClB,kBAAkB,OAAO,WAAP,C;QAClB,KCiyBwD,CDjyBlD,KCiyBkD,IDjyBX,mBAA7B,+BAAiB,EAAjB,CAAqB,QAAQ,C;QAC7C,KCgyBwD,CDhyBlD,QAAQ,CAAR,ICgyBkD,IDhyBC,mBAArC,4BAA6B,QAAQ,C;;;MAGvC,iBAAQ,CAAR,I;MAAtB,mBAAc,CAAd,+BAAqC,CAArC,C;QACI,oBAAkB,WAAQ,CAAR,QAAY,YAAZ,I;QAClB,oBAAkB,OAAO,aAAP,C;QAClB,KC0xBwD,CD1xBlD,OC0xBkD,ID1xBxC,iCAAiB,EAAjB,CAAqB,Q;QACrC,KCyxBwD,CDzxBlD,UAAQ,CAAR,ICyxBkD,IDzxBpC,8BAA6B,Q;;;EAG7D,C;EAEA,0E;IAQI,4B;MAAA,e/C4HoB,C;I+C3HpB,qB;MAAA,Q/C4Ha,MAAO,OAAP,GAAc,YAAd,I;IHvbb,IkD6Te,MlD7TX,eAAQ,UAAZ,C;MAA2B,wBkD6TZ,MlD7TY,EkD6TO,QlD7TP,C;IkD6T3B,0BAAe,MlD5TR,QkD4TP,EAA6C,MAA7C,EAAqD,YAArD,EAAmE,KAAnE,C;EACJ,C;EAEA,yE;IAQI,4B;MAAA,e/CsJoB,C;I+CrJpB,qB;MAAA,Q/CsJa,MAAO,OAAP,GAAc,YAAd,I;I+CpJb,YAAY,iBAAa,cAAK,OAAlB,EAA0B,cAAK,WAAL,GAAkB,MAAlB,IAA1B,EAAoD,KAApD,C;IAEZ,IAAI,sBAAJ,C;MrEzLA,iBAAc,CAAd,UqE0LW,KrE1LX,U;QsEw+BoE,MtEv+BzD,KsEu+ByD,ID7yBhB,mBAA7B,OrE1LZ,KqE0LmB,mBAAP,CAA6B,C;;;MrE3LpD,mBAAc,CAAd,YqE8LW,KrE9LX,Y;QsEw+BoE,MtEv+BzD,OsEu+ByD,IDzyB7C,OrE9LZ,OqE8LmB,mBAAP,C;;;EAG3B,C;EAEA,2E;IAQI,4B;MAAA,e/C0IoB,C;I+CzIpB,qB;MAAA,Q/C0Ia,MAAO,OAAP,GAAc,YAAd,I;IH3eb,IkDmWgB,MlDnWZ,eAAQ,UAAZ,C;MAA2B,wBkDmWX,MlDnWW,EkDmWQ,QlDnWR,C;IkDmW3B,2BAAgB,MlDlWT,QkDkWP,EAA8C,MAA9C,EAAsD,YAAtD,EAAoE,KAApE,C;EACJ,C;EAEA,0E;IAQI,4B;MAAA,e/CwIoB,C;I+CvIpB,qB;MAAA,Q/CwIa,MAAO,OAAP,GAAc,YAAd,I;I+CtIb,YAAY,iBAAa,cAAK,OAAlB,EAA0B,cAAK,WAAL,GAAkB,MAAlB,IAA1B,EAAoD,KAApD,C;IAEZ,IAAI,sBAAJ,C;MrE/NA,iBAAc,CAAd,UqEgOW,KrEhOX,U;QsEmgCqE,MtElgC1D,KsEkgC0D,IDlyBjB,mBAA7B,OrEhOZ,KqEgOmB,mBAAP,CAA6B,C;;;MrEjOpD,mBAAc,CAAd,YqEoOW,KrEpOX,Y;QsEmgCqE,MtElgC1D,OsEkgC0D,ID9xB9C,OrEpOZ,OqEoOmB,mBAAP,C;;;EAG3B,C;EAEA,4E;IAQI,4B;MAAA,e/C4HoB,C;I+C3HpB,qB;MAAA,Q/C4Ha,MAAO,OAAP,GAAc,YAAd,I;IHngBb,IkDyYiB,MlDzYb,eAAQ,UAAZ,C;MAA2B,wBkDyYV,MlDzYU,EkDyYS,QlDzYT,C;IkDyY3B,4BAAiB,MlDxYV,QkDwYP,EAA+C,MAA/C,EAAuD,YAAvD,EAAqE,KAArE,C;EACJ,C;EEzYoC,wB;IAIhC,+B;IAJiC,0B;G;EAIjC,6B;IAAA,iC;G;gDACI,gB;IACI,IAAI,aAAQ,OAAR,KAAmB,aAAQ,OAAR,CAAnB,IAAsC,aAAQ,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"}